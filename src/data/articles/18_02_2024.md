# Networking in large-scale iOS Applications

Networking serves as the backbone of mobile applications, facilitating seamless communication and enabling rich user experiences. However, it also introduces complexity, especially when dealing with modular applications that are built from independent features. 

Modularity offers many benefits, such as a faster development cycle and better scalability. But it also requires a robust approach to handle cross-cutting concerns across different features. Since networking is a cross-cutting concern, it cannot easily be encapsulated in any of them. 

In this article, we explore the key concepts to deal with networking in modular iOS applications.

## Concept

- Naive Approach
    ![Naive Approach](article_18_02_2024_naive_approach.svg)
- Abstraction: "HTTPClient"
	![Architecture](article_18_02_2024_architecture.svg)
- Infrastructure: "URLSessionInfrastructure"
- Adding Functionality: Decorators
	![Decorators](article_18_02_2024_decorators.svg)

## Abstraction: "HTTPClient"

```swift
/// Abstraction for executing HTTP network requests.
public protocol HTTPClient {
    /// Executes the given request and returns the received data and response including the StatusCode.
    /// - Parameter request: The request to be executed.
    /// - Returns: The received data and response (including the StatusCode).
    @discardableResult
    func load(request: HTTPRequest) async throws -> (Data, HTTPResponse)
}
```

```swift
/// Abstraction describing an HTTP network request.
public protocol HTTPRequest {
    /// The HTTP method of the request.
    var method: HTTPMethod { get }
    /// The path of the request endpoint.
    var path: HTTPPath { get }
    /// The endpoint version of the request.
    var version: HTTPVersion { get }
    /// The headers to be transmitted with the request.
    var headers: HTTPHeaders? { get }
    /// The query parameters to be transmitted with the request.
    var queryParameter: HTTPQueryParameter? { get }
    /// The content to be transmitted with the request.
    var body: Data? { get }
}

extension HTTPRequest {
    public var headers: HTTPHeaders? { nil }
    public var queryParameter: HTTPQueryParameter? { nil }
    public var body: Data? { nil }
}
```

```swift
/// The HTTP method of the network request.
public enum HTTPMethod: String, Equatable {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case patch = "PATCH"
    case delete = "DELETE"
}

extension HTTPMethod {
    public var name: String {
        rawValue
    }
}
```

```swift
/// The path of the network request.
public typealias HTTPPath = String
```

```swift
/// The version of the HTTP endpoint.
public typealias HTTPVersion = String
```

```swift
/// Standard Header, die bei Anfragen an das Backend übermittelt werden können.
public enum HTTPHeader: String {
    /// Das Datenformat, das vom Client akzeptiert wird (bspw. `application/json`).
    case accept = "Accept"
    /// Die Art des Inhalts, der im Body übermittelt wird (bspw. `application/json`).
    case contentType = "Content-Type"
}
```

```swift
/// Dictionary an Headern, die als Schlüssel-Wert Paare bei der Netzwerk Anfrage gesendet, bzw. empfangen werden.
public typealias HTTPHeaders = [String: String]
```

```swift
/// Key-value pairs transmitted as query parameters in network requests.
public typealias HTTPQueryParameter = [String: String]
```

```swift
/// Contains the response to a network request.
public struct HTTPResponse {
    /// The StatusCode of the response.
    public let statusCode: HTTPStatusCode
    /// The headers of the response.
    public let headers: HTTPHeaders?

    /// Initializes a `HTTPResponse` for a given StatusCode and Header.
    /// - Parameters:
    ///   - statusCode: The StatusCode of the response.
    ///   - headers: The headers of the response.
    public init(statusCode: HTTPStatusCode, headers: HTTPHeaders? = nil) {
        self.statusCode = statusCode
        self.headers = headers
    }
}

extension HTTPResponse {
    /// Status indicating whether it is an informational response.
    /// - seealso: For more information, see [mdm web docs - Information responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#information_responses)
    public var isInformational: Bool {
        (100 ..< 200).contains(statusCode)
    }

    /// Status indicating whether it is a successful response.
    /// - seealso: For more information, see [mdm web docs - Successful responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses)
    public var isSuccess: Bool {
        (200 ..< 300).contains(statusCode)
    }

    /// Status indicating whether it is a redirection response.
    /// - seealso: For more information, see [mdm web docs - Redirection messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages)
    public var isRedirectional: Bool {
        (300 ..< 400).contains(statusCode)
    }

    /// Status indicating whether it is a client error response.
    /// - seealso: For more information, see [mdm web docs - Client error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)
    public var isClientError: Bool {
        (400 ..< 500).contains(statusCode)
    }

    /// Status indicating whether it is a server error response.
    /// - seealso: For more information, see [mdm web docs - Server error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)
    public var isServerError: Bool {
        (500 ..< 600).contains(statusCode)
    }

    /// Status indicating whether it is an error response.
    public var isError: Bool {
        (400 ..< 600).contains(statusCode)
    }
}
```

```swift
/// The StatusCode contained in a response to a network request.
public typealias HTTPStatusCode = Int
```

## Infrastructure: "URLSessionInfrastructure"

```swift
import Foundation

public final class URLSessionClient: HTTPClient {
    enum Error: Swift.Error {
        case noHttpURLResponse
        case invalidHeaderArguments
    }

    private let baseURL: URL
    private let session: URLSession

    public init(baseURL: URL, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }

    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {
        let url = baseURL
            .appending(path: request.version)
            .appending(path: request.path)

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = request.method.name
        urlRequest.httpBody = request.body
        urlRequest.allHTTPHeaderFields = request.headers
        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        components?.queryItems = request.queryParameter?.reduce(into: [URLQueryItem]()) { current, next in
            let item = URLQueryItem(name: next.key, value: next.value)
            current.append(item)
        }

        let (data, response) = try await session.data(for: urlRequest)

        guard let httpURLResponse = response as? HTTPURLResponse else {
            throw Error.noHttpURLResponse
        }

        guard let headers = httpURLResponse.allHeaderFields as? [String: String] else {
            throw Error.invalidHeaderArguments
        }

        let HttpResponse = HTTPResponse(statusCode: httpURLResponse.statusCode, headers: headers)
        return (data, HttpResponse)
    }
}

```

## Adding Functionality: Decorators

### Authentication

```swift
URLSessionClient(baseURL: baseURL, session: session)
    .authenticated(
        accessToken: {
            try await Task.sleep(nanoseconds: 1_000_000)
            return "Bearer <Token>"
        }
    )
```

```swift
/// A `HTTPClient` decorator that extends requests to a client with an authentication token.
public class AuthenticatedHTTPClient: HTTPClient {
    enum Error: Swift.Error {
        /// Error if no AccessToken exists.
        case missingAccessToken
    }

    private let client: HTTPClient
    private let accessToken: () async throws -> String

    /// Decorates requests to a `HTTPClient` with the authentication token.
    /// - Parameters:
    ///   - client: The `HTTPClient` to be decorated.
    ///   - accessToken: A closure providing the AccessToken.
    public init(client: HTTPClient, accessToken: @escaping () async throws -> String) {
        self.client = client
        self.accessToken = accessToken
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {
        var modifiedRequest = ModifiedRequest(request)
        var headers = modifiedRequest.headers ?? [:]

        do {
            headers["Authorization"] = try await accessToken()
        } catch {
            throw Error.missingAccessToken
        }

        modifiedRequest.headers = headers
        return try await client.load(request: modifiedRequest)
    }
}

extension HTTPClient {
    /// Extends requests to a `HTTPClient` with the authentication token.
    /// - Returns: The `HTTPClient` extended with the authentication token.
    public func authenticated(accessToken: @escaping () async throws -> String) -> HTTPClient {
        AuthenticatedHTTPClient(client: self, accessToken: accessToken)
    }
}
```

### Error Handling

```swift
URLSessionClient(baseURL: baseURL, session: session)
    .handlingErrors()
```

```swift
/// Error type encompassing errors that may occur during the execution of network requests.
public enum HTTPError: Error, Equatable {
    /// Error for responses to network requests containing a StatusCode not within `200..<300`.
    case httpCode(statusCode: HTTPStatusCode, data: Data)
}
```

```swift
/// A `HTTPClient` decorator implementing error handling for standard errors.
public class ErrorHandlingHTTPClient: HTTPClient {
    private let client: HTTPClient

    /// Decorates a HTTPClient with standard error handling.
    /// - Parameter client: The client to be decorated.
    public init(client: HTTPClient) {
        self.client = client
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {
        let (data, response) = try await client.load(request: request)

        if !(200 ..< 300).contains(response.statusCode) {
            throw HTTPError.httpCode(statusCode: response.statusCode, data: data)
        } else {
            return (data, response)
        }
    }
}

extension HTTPClient {
    /// Decorates a `HTTPClient` with standard error handling.
    /// - Returns: The `HTTPClient` extended with standard error handling.
    public func handlingErrors() -> HTTPClient {
        ErrorHandlingHTTPClient(client: self)
    }
}
```

### Header Injection

```swift
URLSessionClient(baseURL: baseURL, session: session)
    .injecting(
        headers: [
            "header1": "value1",
            "header2": "value2",
            "header3": "value3"
        ]
    )
```

```swift
/// A `HTTPClient` decorator that extends requests with additional HTTP headers.
public class HeadersInjectingHTTPClient: HTTPClient {
    private let client: HTTPClient
    private let headers: HTTPHeaders

    /// Decorates requests to a HTTPClient with additional headers.
    /// - Parameter client: The client to be decorated.
    /// - Parameter headers: The additional headers to be added to requests to the client.
    /// > Warning: Identically named headers that already exist will be overwritten.
    public init(client: HTTPClient, headers: HTTPHeaders) {
        self.client = client
        self.headers = headers
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {
        var modifiedRequest = ModifiedRequest(request)
        var headers = modifiedRequest.headers ?? [:]
        self.headers.forEach { header in
            headers[header.key] = header.value
        }
        modifiedRequest.headers = headers
        return try await client.load(request: modifiedRequest)
    }
}

extension HTTPClient {
    /// Decorates requests to a `HTTPClient` with additional headers.
    /// - Returns: The `HTTPClient` extended with the additional headers.
    public func injecting(headers: HTTPHeaders) -> HTTPClient {
        HeadersInjectingHTTPClient(client: self, headers: headers)
    }
}
```

### Logging Request and Responses

```swift
URLSessionClient(baseURL: baseURL, session: session)
    .loggingRequestAndResponse()
```

```swift
/// A `HTTPClient` decorator that logs requests.
public class LoggingHTTPClient: HTTPClient {
    private let client: HTTPClient

    /// Logs requests to a HTTPClient
    /// - Parameter client: The client to be decorated.
    public init(client: HTTPClient) {
        self.client = client
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {
        print(describe(request: request))
        let (data, response) = try await client.load(request: request)
        print(describe(response: response, data: data))
        return (data, response)
    }
}

extension LoggingHTTPClient {
    private func describe(request: HTTPRequest) -> String {
        [
            "Outgoing Network Request ⬆️:",
            "-------------------------------",
            "Method: \(request.method.name)",
            "Path: \(request.path)",
            "Version: \(request.version)",
            request.headers.map { "Headers:\n\(describe(dict: $0))" },
            request.queryParameter.map { "Query-Parameter: \(String(describing: $0))" },
            request.body.map { "Body:\n\(describe(data: $0))" },
        ]
        .compactMap { $0 }
        .joined(separator: "\n")
    }

    private func describe(response: HTTPResponse, data: Data) -> String {
        [
            "Incoming Network Response ⬇️:",
            "------------------------------------------",
            "\(describe(response: response))",
            "Body:",
            "\(describe(data: data))",
        ]
        .joined(separator: "\n")
    }

    private func describe(response: HTTPResponse) -> String {
        [
            "StatusCode: \(response.statusCode)",
            response.headers.map { "Headers:\n\(describe(dict: $0))" },
        ]
        .compactMap { $0 }
        .joined(separator: "\n")
    }

    private func describe(data: Data) -> String {
        guard
            let object = try? JSONSerialization.jsonObject(with: data, options: []),
            let data = try? JSONSerialization.data(withJSONObject: object, options: [.prettyPrinted]),
            let value = NSString(data: data, encoding: String.Encoding.utf8.rawValue) 
        else {
            return String(data: data, encoding: .utf8) ?? ""
        }
        
        return String(value)
    }

    private func describe(dict: [String: String]) -> String {
        "\(dict.reduce("") { $0 + "    - \($1.key): \($1.value)\n" })"
    }
}

extension HTTPClient {
    /// Logs requests to a `HTTPClient`
    /// - Returns: The `HTTPClient` extended with request logging.
    public func loggingRequestAndResponse() -> HTTPClient {
        LoggingHTTPClient(client: self)
    }
}
```

```
Outgoing Network Request ⬆️:
-------------------------------
Method: GET
Path: token
Version: v1
Headers:
    - Authorization: Bearer <Token>
    - header1: value1
    - header3: value3
    - header2: value2

Incoming Network Response ⬇️:
------------------------------------------
StatusCode: 200
Headers:
    - Content-Type: application/json; charset=utf-8
    - Connection: keep-alive
    - Date: Sun, 11 Feb 2024 09:48:46 GMT
    - Keep-Alive: timeout=5
    - Content-Length: 5

Body:
token
```

### Infrastructure

## Usage Example: Token API

```swift
enum HTTPClientFactory {
    static func make(_ baseUrl: String) -> HTTPClient {
        let baseURL: URL = URL(string: baseUrl)!
        let configuration = URLSessionConfiguration.ephemeral
        configuration.timeoutIntervalForRequest = 30.0
        let session: URLSession = URLSession(configuration: configuration)
        return URLSessionClient(baseURL: baseURL, session: session)
    }
}
```

```swift
enum HTTPClientFactory {
    static func make(_ baseUrl: String) -> HTTPClient {
        let baseURL: URL = URL(string: baseUrl)!
        let configuration = URLSessionConfiguration.ephemeral
        configuration.timeoutIntervalForRequest = 30.0
        let session: URLSession = URLSession(configuration: configuration)
        return URLSessionClient(baseURL: baseURL, session: session)
            .loggingRequestAndResponse()
            .injecting(
                headers: [
                    "header1": "value1",
                    "header2": "value2",
                    "header3": "value3"
                ]
            )
            .authenticated(
                accessToken: {
                    try await Task.sleep(nanoseconds: 1_000_000)
                    return "Bearer <Token>"
                }
            )
    }
}
```

```swift
enum TokenAPI: HTTPRequest {
    case token
    case update(token: String)
    
    var method: HTTPMethod {
        switch self {
        case .token:
            return .get
        case .update:
            return .post
        }
    }
    
    var path: HTTPPath {
        return "token"
    }
    
    var version: HTTPVersion {
        return "v1"
    }
    
    var body: Data? {
        switch self {
        case let .update(token):
            return token.data(using: .utf8)
        default:
            return nil
        }
    }
}

```

```swift
enum TokenMapper {
    enum Error: Swift.Error {
        case invalidData
    }

    static func map(data: Data, response: HTTPResponse) throws -> String {
        guard
            response.isSuccess,
            let token = String(data: data, encoding: .utf8)
        else {
            throw Error.invalidData
        }
        
        return token
    }
}
```

```swift
@main
struct NetworkingApp: App {
    private let httpClient: HTTPClient = HTTPClientFactory.make("http://localhost:3000/")

    var body: some Scene {
        WindowGroup {
            ContentView(loadToken: httpClient.loadToken)
        }
    }
}
```

```swift
private extension HTTPClient {
    func loadToken() async throws -> String {
        let (data, response) = try await self.load(request: TokenAPI.token)
        return try TokenMapper.map(data: data, response: response)
    }
}
```

```swift
struct ContentView: View {
    @State private var token: String?
    
    private let loadToken: () async throws -> String
    
    init(loadToken: @escaping () async throws -> String) {
        self.loadToken = loadToken
    }

    var body: some View {
        NavigationStack {
            Text(token ?? "")
                .navigationTitle("Networking")
                .task { token = try? await loadToken() }
        }
    }
}
```