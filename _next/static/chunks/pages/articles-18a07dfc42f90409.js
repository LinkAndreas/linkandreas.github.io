(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[91],{9588:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return Articles}});var i=t(7294),o=t(2962),a=t(7631),r=t.n(a);let s=[{id:"2024-03-16",date:r()(new Date("2024-03-16")),markdown:'# Networking for Large-Scale iOS Applications\n\nNetworking serves as the backbone of mobile applications, facilitating seamless communication and enabling rich user experiences. However, it also introduces complexity, especially when dealing with modular applications that are built from independent features. \n\nModularity offers many benefits, such as a faster development cycle and better scalability. But it also requires a robust approach to handle cross-cutting concerns among features. Since networking is a cross-cutting concern, it cannot be easily encapsulated in any of them. \n\nIn this article, we explore a lightweight approach for dealing with networking in modular iOS applications.\n\n## Naive Approach\n\nFirst, let\'s take a look at the naive approach, where multiple independent features directly depend on the networking package.\n\n![Naive Approach](article_18_02_2024_naive_approach.svg)\n\nEven though the latter encapsulates the ability to communicate over the network, it adds up to the total build time of each feature, since compiling the feature requires compilation of the entire network package as well. Especially when working in feature teams, it is desirable to minimize the amount of direct dependencies so that we can benefit from shorter build times and a fast feedback loop.\n\n## Lightweight Approach in modular Applications\n\nTo ensure that we do not need to compile the network-related code when working on a feature, we introduce a lightweight abstraction called `HTTPClient` that is exposed to every feature but does not contain a concrete implementation.\n\n```swift\n/// Abstraction for executing HTTP network requests.\npublic protocol HTTPClient {\n    /// Executes the given request and returns the received data and response including the StatusCode.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The received data and response (including the StatusCode).\n    @discardableResult\n    func load(request: HTTPRequest) async throws -> (Data, HTTPResponse)\n}\n```\n\nThe abstraction only consists of the `load(request:)` method, that given an `HTTPRequest` returns the received data along with the `HTTPResponse`. The `HTTPRequest` contains all information necessary to perform the request, like the `method`, `path`, `headers` and `queryParameters`. In addition, the `body` parameter is used to specify the content that is transmitted with the request.\n\n```swift\n/// Abstraction describing an HTTP network request.\npublic protocol HTTPRequest {\n    /// The HTTP method of the request.\n    var method: HTTPMethod { get }\n    /// The path of the request endpoint.\n    var path: HTTPPath { get }\n    /// The endpoint version of the request.\n    var version: HTTPVersion { get }\n    /// The headers to be transmitted with the request.\n    var headers: HTTPHeaders? { get }\n    /// The query parameters to be transmitted with the request.\n    var queryParameter: HTTPQueryParameter? { get }\n    /// The content to be transmitted with the request.\n    var body: Data? { get }\n}\n```\n\nSome parameters are declared *optional* since they may not be necessary for every request. Hence, developers have the flexibility to omit these parameters, streamlining the implementation and improving code readability.\n\n```swift\nextension HTTPRequest {\n    public var headers: HTTPHeaders? { nil }\n    public var queryParameter: HTTPQueryParameter? { nil }\n    public var body: Data? { nil }\n}\n```\n\nLet\'s briefly go through the meaning of each of the parameters.\n\nFirst, the `HTTPMethod` enumeration corresponds to the methods permitted for HTTP requests. Alongside `GET` for data retrieval, it also includes `POST` for creating a resource, as well as `PUT` and `PATCH` for updating the resource, and `DELETE` for removing it when no longer needed.\n\n```swift\n/// The HTTP method of the network request.\npublic enum HTTPMethod: String, Equatable {\n    case get = "GET"\n    case post = "POST"\n    case put = "PUT"\n    case patch = "PATCH"\n    case delete = "DELETE"\n}\n\nextension HTTPMethod {\n    public var name: String {\n        rawValue\n    }\n}\n```\n\nNext, the `HTTPPath` in conjunction with the `HTTPVersion` specifies the endpoint targeted by the request. Both are defined as type aliases of `String` to better derive a semantic meaning when looking at the type itself.\n\n```swift\n/// The path of the network request.\npublic typealias HTTPPath = String\n/// The version of the HTTP endpoint.\npublic typealias HTTPVersion = String\n```\n\nNext, `HTTPHeader` defines standard headers that are included in most requests. For instance, the `contentType` attribute specifies the type of content being transmitted in the request body.\n\n```swift\n/// Standard headers that can be transmitted in requests to the backend.\npublic enum HTTPHeader: String {\n    /// The data format accepted by the client (e.g., `application/json`).\n    case accept = "Accept"\n    /// The type of content being sent in the body (e.g., `application/json`).\n    case contentType = "Content-Type"\n}\n```\n\nFinally, similar to `HTTPPath`, both `HTTPHeaders` and `HTTPQueryParameter` utilize type aliases to give meaning to the underlying `String` key-value pairs.\n\n```swift\n/// Dictionary of headers sent or received as key-value pairs in network requests.\npublic typealias HTTPHeaders = [String: String]\n/// Key-value pairs transmitted as query parameters in network requests.\npublic typealias HTTPQueryParameter = [String: String]\n```\n\nHaving referred to the properties of an `HTTPRequest`, let\'s now shift our focus to the `HTTPResponse` that is received upon successful execution of `load(request:)`.\n\n```swift\n/// Contains the response to a network request.\npublic struct HTTPResponse {\n    /// The StatusCode of the response.\n    public let statusCode: HTTPStatusCode\n    /// The headers of the response.\n    public let headers: HTTPHeaders?\n\n    /// Initializes a `HTTPResponse` for a given StatusCode and Header.\n    /// - Parameters:\n    ///   - statusCode: The StatusCode of the response.\n    ///   - headers: The headers of the response.\n    public init(statusCode: HTTPStatusCode, headers: HTTPHeaders? = nil) {\n        self.statusCode = statusCode\n        self.headers = headers\n    }\n}\n\n/// The StatusCode contained in a response to a network request.\npublic typealias HTTPStatusCode = Int\n```\n\nIn contrast to the request, the `HTTPResponse` only comprises two properties: the `statusCode` and `headers`. While the status code communicates the outcome of the request, the `headers` are optional and enable the server to provide supplementary information to the client alongside the response.\n\nFurthermore, extensions are implemented to streamline the determination of the response\'s nature, categorizing it into types such as `informational`, `successful`, `redirection`, `client error`, or `server error`. This eliminates the need to memorize status code ranges.\n\n```swift\nextension HTTPResponse {\n    /// Status indicating whether it is an informational response.\n    /// - seealso: For more information, see [mdm web docs - Information responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#information_responses)\n    public var isInformational: Bool {\n        (100 ..< 200).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a successful response.\n    /// - seealso: For more information, see [mdm web docs - Successful responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses)\n    public var isSuccess: Bool {\n        (200 ..< 300).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a redirection response.\n    /// - seealso: For more information, see [mdm web docs - Redirection messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages)\n    public var isRedirectional: Bool {\n        (300 ..< 400).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a client error response.\n    /// - seealso: For more information, see [mdm web docs - Client error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n    public var isClientError: Bool {\n        (400 ..< 500).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a server error response.\n    /// - seealso: For more information, see [mdm web docs - Server error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n    public var isServerError: Bool {\n        (500 ..< 600).contains(statusCode)\n    }\n\n    /// Status indicating whether it is an error response.\n    public var isError: Bool {\n        (400 ..< 600).contains(statusCode)\n    }\n}\n```\n\nAs a result, relying solely on the `HTTPClient` abstraction has a negligible impact on the feature\'s build time. Moreover, the feature avoids dealing with 3rd party dependencies like `Moya`, `Alamofire` or Apple\'s `URLSession`. Instead, it only uses the abstraction to communicate over the network and assumes that a concrete implementation will be provided by another entity. This assumption is key for decoupling features from cross-cutting concerns and developing them in isolation.\n\n![Architecture](article_18_02_2024_feature_abstraction.svg)\n\n## Infrastructure: "URLSessionInfrastructure"\n\nStill, when integrating the feature, we need to ensure that its requirements are fulfilled by a concrete implementation. The latter is provided by infrastructure modules that may use a third-party library to achieve the intended result. For instance, the `URLSessionInfrastructure` package may use Apple\'s `URLSession` to execute the request.\n\n![Architecture](article_18_02_2024_feature_abstraction_infrastructure.svg)\n\nIn this manner, only the infrastructure package directly relies on third-party frameworks, such that each feature stays agnostic from infrastructure details. Below you can find an example implementation of the `URLSessionClient`:\n\n```swift\nimport Foundation\n\npublic final class URLSessionClient: HTTPClient {\n    enum Error: Swift.Error {\n        case noHttpURLResponse\n        case invalidHeaderArguments\n    }\n\n    private let baseURL: URL\n    private let session: URLSession\n\n    public init(baseURL: URL, session: URLSession = .shared) {\n        self.baseURL = baseURL\n        self.session = session\n    }\n\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        let url = baseURL\n            .appending(path: request.version)\n            .appending(path: request.path)\n\n        var urlRequest = URLRequest(url: url)\n        urlRequest.httpMethod = request.method.name\n        urlRequest.httpBody = request.body\n        urlRequest.allHTTPHeaderFields = request.headers\n        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)\n        components?.queryItems = request.queryParameter?.reduce(into: [URLQueryItem]()) { current, next in\n            let item = URLQueryItem(name: next.key, value: next.value)\n            current.append(item)\n        }\n\n        let (data, response) = try await session.data(for: urlRequest)\n\n        guard let httpURLResponse = response as? HTTPURLResponse else {\n            throw Error.noHttpURLResponse\n        }\n\n        guard let headers = httpURLResponse.allHeaderFields as? [String: String] else {\n            throw Error.invalidHeaderArguments\n        }\n\n        let HttpResponse = HTTPResponse(statusCode: httpURLResponse.statusCode, headers: headers)\n        return (data, HttpResponse)\n    }\n}\n```\n\nFirst, the `load(request:)` method constructs a `URLRequest` along with its query items based on the information given in the `HTTPRequest`. It\'s important to note that `URLRequest` is considered an infrastructure detail, as it\'s provided by Apple\'s `URLSession`. Second, the `session` is used to execute the request and wait for the reception of a response. Finally, the received response is interpreted as an `HTTPURLResponse` from which `headers` and `statusCode` are extracted.\n\nBy separating the feature from infrastructure details, we can integrate all components within the *composition root*. The latter serves as the translation layer between modules without requiring them to have knowledge of each other. This way, features can be developed in isolation by different feature teams, which is essential for large-scale modular applications.\n\n![Architecture](article_18_02_2024_architecture.svg)\n\n## Adding Functionality: Decorators\n\nEspecially within large-scale applications, we frequently encounter new or evolving business requirements, such as *logging* or *authentication*. Instead of modifying the infrastructure module, we can utilize the decorator pattern to add functionality without altering the underlying implementation. Consider the `AuthenticatedHTTPClient` as an illustration: it provides the same interface as the `HTTPClient`, yet it injects a Bearer token with every request. Through this approach, decorations are linked together until the desired behavior is achieved.\n\n![Decorators](article_18_02_2024_decorators.svg)\n\nLet\'s take a moment to highlight four decorations of the `HTTPClient` to deal with *authentication*, *error handling*, *header injection* as well as *logging*\n\n### Authentication\n\nFirst, let\'s start by taking a look at how we can add *authentication* to an existing `HTTPClient`. Given the client, as well as a closure that returns an access token, the `AuthenticatedHTTPClient` injects the token as an `Authentication` header into every request. Note that the closure providing the token is asynchronous and may return an error when the token retrieval fails. In case, no token could be retrieved, the client throws the `missingAccessToken` error.\n\n```swift\n/// A `HTTPClient` decorator that extends requests to a client with an authentication token.\npublic class AuthenticatedHTTPClient: HTTPClient {\n    enum Error: Swift.Error {\n        /// Error if no AccessToken exists.\n        case missingAccessToken\n    }\n\n    private let client: HTTPClient\n    private let accessToken: () async throws -> String\n\n    /// Decorates requests to a `HTTPClient` with the authentication token.\n    /// - Parameters:\n    ///   - client: The `HTTPClient` to be decorated.\n    ///   - accessToken: A closure providing the AccessToken.\n    public init(client: HTTPClient, accessToken: @escaping () async throws -> String) {\n        self.client = client\n        self.accessToken = accessToken\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        var modifiedRequest = ModifiedRequest(request)\n        var headers = modifiedRequest.headers ?? [:]\n\n        do {\n            headers["Authorization"] = try await accessToken()\n        } catch {\n            throw Error.missingAccessToken\n        }\n\n        modifiedRequest.headers = headers\n        return try await client.load(request: modifiedRequest)\n    }\n}\n```\n\nThe following extension allows to easily chain the `AuthenticatedHttpClient` with an existing client:\n\n```swift\nextension HTTPClient {\n    /// Extends requests to a `HTTPClient` with the authentication token.\n    /// - Returns: The `HTTPClient` extended with the authentication token.\n    public func authenticated(accessToken: @escaping () async throws -> String) -> HTTPClient {\n        AuthenticatedHTTPClient(client: self, accessToken: accessToken)\n    }\n}\n```\n\nThen, an existing client is augmented by calling `.authenticated` with a closure providing the access token.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .authenticated(\n        accessToken: {\n            try await Task.sleep(nanoseconds: 1_000_000)\n            return "Bearer <Token>"\n        }\n    )\n```\n\nNote that the access token retrieval is asynchronous because the token may expire. If the token becomes invalid, the client can request a new token using the refresh token from the authentication server.\n\n### Error Handling\n\nLike `authentication`, we can introduce an additional decorator that handles errors for responses with status codes outside `200..<300` by default. However, this does not prevent us from handling the error on the call side. Rather, handlers can be chained to deal with the error suitably, thanks to their composable nature.\n\n```swift\n/// Error type encompassing errors that may occur during the execution of network requests.\npublic enum HTTPError: Error, Equatable {\n    /// Error for responses to network requests containing a StatusCode not within `200..<300`.\n    case httpCode(statusCode: HTTPStatusCode, data: Data)\n}\n```\n\nThe `ErrorHandlingHTTPClient` examines the response status code and throws an `HTTPError.httpCode(statusCode:data:)` error if it falls outside the expected range. This simplifies error handling for the client. Within the feature, where we have a better understanding of the error, we can provide more specific details on how to handle it.\n\n```swift\n/// A `HTTPClient` decorator implementing error handling for standard errors.\npublic class ErrorHandlingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n\n    /// Decorates a HTTPClient with standard error handling.\n    /// - Parameter client: The client to be decorated.\n    public init(client: HTTPClient) {\n        self.client = client\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        let (data, response) = try await client.load(request: request)\n\n        if !(200 ..< 300).contains(response.statusCode) {\n            throw HTTPError.httpCode(statusCode: response.statusCode, data: data)\n        } else {\n            return (data, response)\n        }\n    }\n}\n\nextension HTTPClient {\n    /// Decorates a `HTTPClient` with standard error handling.\n    /// - Returns: The `HTTPClient` extended with standard error handling.\n    public func handlingErrors() -> HTTPClient {\n        ErrorHandlingHTTPClient(client: self)\n    }\n}\n```\n\nSimilar to the previous extensions, default error handling is added by calling `handlingErrors()` on an existing client.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .handlingErrors()\n```\n\n### Header Injection\n\nNow, we will discuss the `HeadersInjectingHTTPClient`. This client enables the injection of custom headers into the request.\n\n```swift\n/// A `HTTPClient` decorator that extends requests with additional HTTP headers.\npublic class HeadersInjectingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n    private let headers: HTTPHeaders\n\n    /// Decorates requests to a HTTPClient with additional headers.\n    /// - Parameter client: The client to be decorated.\n    /// - Parameter headers: The additional headers to be added to requests to the client.\n    /// > Warning: Identically named headers that already exist will be overwritten.\n    public init(client: HTTPClient, headers: HTTPHeaders) {\n        self.client = client\n        self.headers = headers\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        var modifiedRequest = ModifiedRequest(request)\n        var headers = modifiedRequest.headers ?? [:]\n        self.headers.forEach { header in\n            headers[header.key] = header.value\n        }\n        modifiedRequest.headers = headers\n        return try await client.load(request: modifiedRequest)\n    }\n}\n\nextension HTTPClient {\n    /// Decorates requests to a `HTTPClient` with additional headers.\n    /// - Returns: The `HTTPClient` extended with the additional headers.\n    public func injecting(headers: HTTPHeaders) -> HTTPClient {\n        HeadersInjectingHTTPClient(client: self, headers: headers)\n    }\n}\n```\n\nCustom headers are frequently utilized to provide additional information about the client, such as its version or the operating system on which the application is running. Additionally, the client may need to specify the desired data format for the response. In both of these cases, the required information can be injected by calling the `injecting(headers:)` extension on an existing client.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .injecting(\n        headers: [\n            "header1": "value1",\n            "header2": "value2",\n            "header3": "value3"\n        ]\n    )\n```\n\n### Logging Request and Responses\n\nFinally, we will discuss how to handle logging with the `LoggingHTTPClient`. Similar to the previous decorators, this client follows the `HTTPClient` protocol and describes the request and response after the call. Please note that we utilized `print` statements for the sake of simplicity. In a production-level application, a dedicated logger with an appropriate queuing mechanism would be used to ensure that events are logged in the order in which they occur.\n\n```swift\n/// A `HTTPClient` decorator that logs requests.\npublic class LoggingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n\n    /// Logs requests to a HTTPClient\n    /// - Parameter client: The client to be decorated.\n    public init(client: HTTPClient) {\n        self.client = client\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        print(describe(request: request))\n        let (data, response) = try await client.load(request: request)\n        print(describe(response: response, data: data))\n        return (data, response)\n    }\n}\n```\n\nBelow, you can find utility functions that prepare the request and response in a human-readable format. This allows developers to quickly verify whether the request was successful or if the server responded with the expected status code. To enhance the implementation, consider storing the log on disk or exporting it for further investigation.\n\n```swift\nextension LoggingHTTPClient {\n    private func describe(request: HTTPRequest) -> String {\n        [\n            "Outgoing Network Request ⬆️:",\n            "-------------------------------",\n            "Method: \\(request.method.name)",\n            "Path: \\(request.path)",\n            "Version: \\(request.version)",\n            request.headers.map { "Headers:\\n\\(describe(dict: $0))" },\n            request.queryParameter.map { "Query-Parameter: \\(String(describing: $0))" },\n            request.body.map { "Body:\\n\\(describe(data: $0))" },\n        ]\n        .compactMap { $0 }\n        .joined(separator: "\\n")\n    }\n\n    private func describe(response: HTTPResponse, data: Data) -> String {\n        [\n            "Incoming Network Response ⬇️:",\n            "------------------------------------------",\n            "\\(describe(response: response))",\n            "Body:",\n            "\\(describe(data: data))",\n        ]\n        .joined(separator: "\\n")\n    }\n\n    private func describe(response: HTTPResponse) -> String {\n        [\n            "StatusCode: \\(response.statusCode)",\n            response.headers.map { "Headers:\\n\\(describe(dict: $0))" },\n        ]\n        .compactMap { $0 }\n        .joined(separator: "\\n")\n    }\n\n    private func describe(data: Data) -> String {\n        guard\n            let object = try? JSONSerialization.jsonObject(with: data, options: []),\n            let data = try? JSONSerialization.data(withJSONObject: object, options: [.prettyPrinted]),\n            let value = NSString(data: data, encoding: String.Encoding.utf8.rawValue) \n        else {\n            return String(data: data, encoding: .utf8) ?? ""\n        }\n        \n        return String(value)\n    }\n\n    private func describe(dict: [String: String]) -> String {\n        "\\(dict.reduce("") { $0 + "    - \\($1.key): \\($1.value)\\n" })"\n    }\n}\n```\n\nUsing the following extension, we can activate logging for all network requests:\n\n```swift\nextension HTTPClient {\n    /// Logs requests to a `HTTPClient`\n    /// - Returns: The `HTTPClient` extended with request logging.\n    public func loggingRequestAndResponse() -> HTTPClient {\n        LoggingHTTPClient(client: self)\n    }\n}\n\nURLSessionClient(baseURL: baseURL, session: session)\n    .loggingRequestAndResponse()\n```\n\nHere is an example of a human-readable printout of a request/response pair. The log clearly breaks down the outgoing request, including its `method`, `path`, `version`, and `headers`. The incoming response is also detailed, including its status code, headers, and body content.\n\n```\nOutgoing Network Request ⬆️:\n-------------------------------\nMethod: GET\nPath: token\nVersion: v1\nHeaders:\n    - Authorization: Bearer <Token>\n    - header1: value1\n    - header2: value2\n    - header3: value3\n\nIncoming Network Response ⬇️:\n------------------------------------------\nStatusCode: 200\nHeaders:\n    - Content-Type: application/json; charset=utf-8\n    - Connection: keep-alive\n    - Date: Sun, 11 Feb 2024 09:48:46 GMT\n    - Keep-Alive: timeout=5\n    - Content-Length: 5\n\nBody:\ntoken\n```\n\n### Usage Example: Token API\n\nThe `HTTPClient` protocol is a suitable abstraction for making features agnostic of infrastructure details. Decorators allow for the dynamic addition of functionality without having to adapt the underlying implementation. Let\'s examine a usage example to see how these components interact.\n\nConsider a simple REST API (`TokenAPI`) that enables users to retrieve and update a token. While the `token` endpoint does not require a request body, the `update` endpoint expects the new token to be stored on the server.\n\n```swift\nenum TokenAPI: HTTPRequest {\n    case token\n    case update(token: String)\n    \n    var method: HTTPMethod {\n        switch self {\n        case .token:\n            return .get\n        case .update:\n            return .post\n        }\n    }\n    \n    var path: HTTPPath {\n        return "token"\n    }\n    \n    var version: HTTPVersion {\n        return "v1"\n    }\n    \n    var body: Data? {\n        switch self {\n        case let .update(token):\n            return token.data(using: .utf8)\n        default:\n            return nil\n        }\n    }\n}\n```\n\nAdditionally, we define the `TokenMapper` to translate the received data and `HTTPResponse` into a token. Please note that the mapping may fail if invalid data is received.\n\n```swift\nenum TokenMapper {\n    enum Error: Swift.Error {\n        case invalidData\n    }\n\n    static func map(data: Data, response: HTTPResponse) throws -> String {\n        guard\n            response.isSuccess,\n            let token = String(data: data, encoding: .utf8)\n        else {\n            throw Error.invalidData\n        }\n        \n        return token\n    }\n}\n```\n\nNext, we instantiate a concrete `HTTPClient` to perform the request. In this case, we decided to use Apple\'s `URLSession` by using the `URLSessionClient` with an `ephemeral` session and a request timeout interval of 30 seconds.\n\n```swift\nenum HTTPClientFactory {\n    static func make(_ baseUrl: String) -> HTTPClient {\n        let baseURL: URL = URL(string: baseUrl)!\n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.timeoutIntervalForRequest = 30.0\n        let session: URLSession = URLSession(configuration: configuration)\n        return URLSessionClient(baseURL: baseURL, session: session)\n    }\n}\n```\n\nBy utilizing the extensions, we can include `logging` and `authentication`, as well as the necessary `headers` to execute the request. It is important to note that the order in which the extensions are applied is significant, as it determines the sequence in which the decorations are applied.\n\n```swift\nenum HTTPClientFactory {\n    static func make(_ baseUrl: String) -> HTTPClient {\n        let baseURL: URL = URL(string: baseUrl)!\n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.timeoutIntervalForRequest = 30.0\n        let session: URLSession = URLSession(configuration: configuration)\n        return URLSessionClient(baseURL: baseURL, session: session)\n            .loggingRequestAndResponse()\n            .injecting(\n                headers: [\n                    "header1": "value1",\n                    "header2": "value2",\n                    "header3": "value3"\n                ]\n            )\n            .authenticated(\n                accessToken: {\n                    try await Task.sleep(nanoseconds: 1_000_000)\n                    return "Bearer <Token>"\n                }\n            )\n    }\n}\n```\n\nThe `ContentView` requires a token to be retrieved through the `loadToken` closure provided in its initializer. This approach ensures that the UI is not dependent on the specific `HTTPClient` used to execute the request. By using SwiftUI\'s `task` modifier, the request is automatically made when the content is loaded on screen.\n\n```swift\nstruct ContentView: View {\n    @State private var token: String?\n    \n    private let loadToken: () async throws -> String\n    \n    init(loadToken: @escaping () async throws -> String) {\n        self.loadToken = loadToken\n    }\n\n    var body: some View {\n        NavigationStack {\n            Text(token ?? "")\n                .navigationTitle("Networking")\n                .task { token = try? await loadToken() }\n        }\n    }\n}\n```\n\nThe UI and `httpClient` are connected in the `composition root`. This layer translates the view\'s request and passes it to the `httpClient`. The response is then mapped using the `TokenMapper` to match the signature of the `loadToken` method.\n\n```swift\n@main\nstruct NetworkingApp: App {\n    private let httpClient: HTTPClient = HTTPClientFactory.make("http://localhost:3000/")\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView(loadToken: httpClient.loadToken)\n        }\n    }\n}\n\nprivate extension HTTPClient {\n    func loadToken() async throws -> String {\n        let (data, response) = try await self.load(request: TokenAPI.token)\n        return try TokenMapper.map(data: data, response: response)\n    }\n}\n```\n\n# Conclusion\n\nIn this article, we introduced a lightweight approach to dealing with cross-cutting concerns like networking in modular iOS applications. By following the principles outlined here, developers can keep features agnostic of infrastructure details and benefit from a faster development cycle and the scalability of their modular iOS applications.\n\n# References:\n\n- [The URL loading system](https://developer.apple.com/documentation/foundation/url_loading_system) - Apple\n- [Composition Root](https://blog.ploeh.dk/2011/07/28/CompositionRoot/) - Mark Seemann\n\nHappy Coding \uD83D\uDE80',title:"Networking for Large-Scale iOS Applications",description:`Networking serves as the backbone of mobile applications, 
            facilitating seamless communication and enabling rich user experiences. 
            However, it also introduces complexity, especially when dealing with 
            modular applications that are built from independent features.
            Modularity offers many benefits, such as a faster development cycle 
            and better scalability. But it also requires a robust approach to handle 
            cross-cutting concerns among features. Since networking is a 
            cross-cutting concern, it cannot be easily encapsulated in any of them.
            In this article, we explore a lightweight approach for dealing with 
            networking in modular iOS applications.`},{id:"2023-04-17",date:r()(new Date("2023-04-17")),markdown:'# Automating your iOS App Development Workflow: Continuous Deployment with GitHub Actions\n\nIn agile software development, continuous deployment is key to collect user feedback leading to more reliable and successful iOS apps. Still, deploying to AppStore Connect is challenging due to managing signing certificates, provisioning profiles, and build numbers. In this article, we\'ll explore how to automate this process, allowing you to release your apps with a single button press.\n\n## Environment Variables\n\nFirst, we need to configure the following environment variables in your project\'s settings (`Project` > `Settings` > `Security` > `Secrets and Environment Variables` > `actions`):\n\n| Key                       | Value (Example)   |\n|---------------------------|-------------------|\n| APP_ID                    | 1234567           |\n| TEAM_ID                   | A123456789        |\n| BUNDLE_ID                 | com.example.app   |\n| PROVISIONING_PROFILE_NAME | Distribution      |\n| SIMULATOR_DEVICE_TYPE     | iPhone-14         |\n| SIMULATOR_RUNTIME         | iOS-16-2          |\n\nExplanation:\n- `APP_ID`: The identifier that uniquely identifies the application.\n  - Location: AppStore Connect > Apps > App > App Information > Apple ID\n- `TEAM_ID`: The identifier for the team enrolled in the Apple Developer Program.\n  - Location: AppStore Connect > Edit Profile > TeamID\n- `BUNDLE_ID`: The identifier used by Apple to uniquely identify the application.\n  - Location: AppStore Connect > Apps > App > App Information > Bundle Identifier\n- `PROVISIONING_PROFILE_NAME`: The name of the provisioning profile.\n- `SIMULATOR_DEVICE_TYPE`: The simulator device used to run tests in the workflow.\n- `SIMULATOR_RUNTIME`: The Runtime version of the iOS simulator.\n\n## Secrets\n\nNext, we create the following secrets in the project\'s settings:\n\n| Key                            | Value (Example)      |\n|--------------------------------|----------------------|\n| API_KEY_BASE64       	         | XXXXXXXXXX           |\n| API_KEY_ID                     | XXXXXXXXXX           |\n| API_KEY_ISSUER_ID              | XXXXXXXXXX           |\n| KEYCHAIN_PASSWORD              | XXXXXXXXXX           |\n| SIGNING_CERTIFICATE_BASE64     | XXXXXXXXXX           |\n| SIGNING_CERTIFICATE_PASSWORD   | XXXXXXXXXX           |\n| PROVISIONING_PROFILE_BASE64    | XXXXXXXXXX           |\n\nGithub secrets store sensitive information in the project\'s repository and provide them as encrypted workflow configuration variables to the workflows, ensuring that their values are hidden from the web interface and can only be updated, not seen, once stored.\n\nExplanation:\n- `API_KEY_BASE64`: The private key to authorize against the AppStore Connect API encoded in base64 format.\n- `API_KEY_ID`: The key\'s Id.\n  - Location: App Store Connect > Users and Access > Keys\n- `API_KEY_ISSUER_ID`: The identifier of the issuer who created the authentication token.\n  - Location: App Store Connect > Users and Access > Keys > Issuer Id\n- `KEYCHAIN_PASSWORD`: The password used to unlock the keychain.\n- `SIGNING_CERTIFICATE_BASE64`: The signing certificate encoded in base64 format.\n- `SIGNING_CERTIFICATE_PASSWORD`: The password for your Apple signing certificate.\n- `PROVISIONING_PROFILE_BASE64`: The provisioning profile encoded in base64 format.\n\nYou can use the following commands to encode secrets in base64 format and copy it to the pasteboard:\n\n```sh\n# API_KEY_BASE64\nopenssl base64 -in AuthKey_{KEY_ID}.p8 | pbcopy\n\n# SIGNING_CERTIFICATE_BASE64\nopenssl base64 -in {SIGNING_CERTIFICATE_NAME}.p12 | pbcopy \n\n# PROVISIONING_PROFILE_BASE64\nopenssl base64 -in {PROVISIONING_PROFILE_NAME}.mobileprovision | pbcopy \n```\n\n## Deployment Workflow\n\nHaving specified all secrets and configuration variables, we can create a dedicated workflow that automates deployment to AppStore Connect. This way, we can distribute the application to TestFlight and get feedback from internal- and external testers.\n\nWe start with the following blueprint:\n\n```yml\nname: Deploy to App Store Connect\n\non:\n  workflow_dispatch:\n\njobs:\n  archive-and-deploy:\n    runs-on: macos-latest\n\n    steps:\n        ...\n```\n\nNote that only the manual trigger via the web interface is included to better control when deployment is made. Still, it is possible to enable automatic deployment whenever the `main` branch is updated:\n\n```yaml\non:\n  push:\n    branches:\n      - main\n```\n\n###  Step 1: Checkout Repository\n\nFirst, we use the checkout step to gain access to the source code:\n\n```yaml\n- name: Checkout repository\n  uses: actions/checkout@v3\n```\n\n### Step 2: Install App Store Connect API Key \n\nNext, we need to install the private key to the agent such that it can communicate with AppStore Connect:\n\n```sh\nmkdir ~/.private_keys\necho -n "$API_KEY_BASE64" | base64 --decode --output ~/.private_AuthKey_${{ secrets.API_KEY_ID }}.p8\necho "After saving:"\nls ~/.private_keys\n```\n\nThe API Key is decoded from the base64-encoded secret and stored in the current directory.\n\n### Step 3: Install Signing Certificate\n\nNext, the signing certificate is decoded and stored in the `app-signing` keychain. We unlock the keychain to have access to the signing certificate when archiving the application:\n\n```sh\nSIGNING_CERTIFICATE_PATH=$RUNNER_TEMP/signing_certificate.p12\nKEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n# Read Signing Certificate\necho -n "$SIGNING_CERTIFICATE_BASE64" | base64 --decode -o "$SIGNING_CERTIFICATE_PATH"\n\n# Create Keychain\nsecurity create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"\nsecurity set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"\nsecurity unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"\n\n# Import Signing Certificate to Keychain\nsecurity import "$SIGNING_CERTIFICATE_PATH" -P "$SIGNING_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"\nsecurity list-keychain -d user -s "$KEYCHAIN_PATH"\n```\n\n### Step 4: Install Provisioning Profile\n\nSimilarly, the provising profile is decoded and stored in the agent\'s library directory(`~/Library/MobileDevice/Provisioning\\ Profiles`):\n\n```sh\nPROVISIONING_PROFILE_PATH=$RUNNER_TEMP/provisioning_profile.mobileprovision\n\n# Read Provisioning Profile\necho -n "$PROVISIONING_PROFILE_BASE64" | base64 --decode -o "$PROVISIONING_PROFILE_PATH"\n\n# Import Provisioning Profile\nmkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\ncp $PROVISIONING_PROFILE_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n```\n\nThe provisioning profiles specify the devices the application is allowed to run. In addition, they ensure that the app is from a trusted source and has not been tampered with. \n\n### Step 5: Configure `exportOptions.plist`\n\nNext, we inject the provisioning profile\'s name, the Team- and Bundle-ID into the `exportOptions.plist` that is used by `xcodebuild` when distributing the archive. The injection is done using the `sed` command with which we can replace the placeholders `{{Placeholder}}` with their corresponding values:\n\n```sh\n- name: Configure exportOptions.plist\n  env: \n    TEAM_ID: ${{ vars.TEAM_ID }}\n    BUNDLE_ID: ${{ vars.BUNDLE_ID }}\n    PROVISIONING_PROFILE_NAME: ${{ vars.PROVISIONING_PROFILE_NAME }}\n  run: |\n    sed -i \'\' "s/{{TEAM_ID}}/$TEAM_ID/g" exportOptions.plist\n    sed -i \'\' "s/{{BUNDLE_ID}}/$BUNDLE_ID/g" exportOptions.plist\n    sed -i \'\' "s/{{PROVISIONING_PROFILE_NAME}}/$PROVISIONING_PROFILE_NAME/g" exportOptions.plist\n```\n\nThis way, we can customize the export process and specify the distribution method as well as the provisioning profile, used when code signing the app.\n\n```xml\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n    <key>method</key>\n    <string>app-store</string>\n    <key>teamID</key>\n    <string>{{TEAM_ID}}</string>\n    <key>uploadSymbols</key>\n    <true/>\n    <key>signingStyle</key>\n    <string>manual</string>\n    <key>provisioningProfiles</key>\n    <dict>\n        <key>{{BUNDLE_ID}}</key>\n        <string>{{PROVISIONING_PROFILE_NAME}}</string>\n    </dict>\n</dict>\n</plist>\n```\n\n### Step 6: Inject Build Number\n\nNow that we have the signing certificate, provisioning profile and API Key in place, we need to determine the build number.\nEach buildnmber submitted to AppStore Connect is required to be strictly greater than the maximum known build number of all builds ever submitted. Since manually keeping track of build numbers is tedious, we utitlize the workflow\'s built-in counter, i.e., `github.run_number` that is incremented on every build. This way, we only need to specify the marketing version that is shown in the AppStore:  \n\n```sh\nbuildNumber=${{ github.run_number }}\necho "Current build number: $buildNumber"\nagvtool new-version -all $buildNumber\n```\n\n### Step 7: Build, Sign and Archive\n\nHaving setup the environment, we can archive the application as an `xcarchive`. Note that we use manual signing with the provising profile that we imported in an earlier step: \n\n```sh\nset -o pipefail && xcodebuild clean archive \\\n  -scheme "App" \\\n  -archivePath $RUNNER_TEMP/App.xcarchive \\\n  -sdk iphoneos \\\n  -configuration Release \\\n  -destination generic/platform=iOS \\\n  CODE_SIGN_STYLE=Manual \\\n  PROVISIONING_PROFILE_SPECIFIER=Distribution | xcpretty\n```\n\n### Step 8: Export Archive\n\nAs soon as the archive is built, we can export the iOS AppStore Package (`.ipa`) considering the `exportOptions`.\n\n```sh\nARTIFACT_FILEPATH=$RUNNER_TEMP/App.ipa\nset -o pipefail && xcodebuild -exportArchive \\\n  -archivePath $RUNNER_TEMP/App.xcarchive \\\n  -exportOptionsPlist exportOptions.plist \\\n  -exportPath $RUNNER_TEMP | xcpretty\n```\n\n### Step 9: Publish Archive\n\nAn iOS AppStore Package (`.ipa`) is technically identical to a `zip` file and can be extracted by renaming it\'s file extension. That\'s why it makes sence to publish it as a workflow artifact, such that we can access to the package and verify whether all ressources are properly bundled:\n\n```yaml\n- name: Publish App.ipa file\n  uses: actions/upload-artifact@v3\n  with:\n    name: App.ipa\n    path: ${{ runner.temp }}/App.ipa\n```\n\n### Step 10: Validate Build Artifact\n\nBefore uploading the application package to AppStore Connect, we use the `altool` command to validate it. In case the AppStore will not accept the package the validation will fail. E.g., we might have missed adding an App Icon which is required by the store:\n\n```sh\nxcrun altool --validate-app \\\n  -f ${{ runner.temp }}/App.ipa \\\n  -t ios \\\n  --apiKey ${{ secrets.API_KEY_ID }} \\\n  --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n```\n\n### Step 11: Upload Build Artifact to AppStore Connect\n\nIn case the validation succeeded, we can upload the package via the AppStore Connect API.\n\n```sh\nxcrun altool --upload-app \\\n  -f ${{ runner.temp }}/App.ipa \\\n  -t ios \\\n  --apiKey ${{ secrets.API_KEY_ID }} \\\n  --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n```\n\n### Step 12: Cleanup keychain and provisioning profile\n\nEven though Github\'s own runners always ensure that we start with a clean environment it is best practive to clean up certificates that are no longer needed. In case we would use a self hosted runner, these artifacts could otherwiese remain and cause unintended side-effects on subsequent builds.\n\n```sh\nsecurity delete-keychain $RUNNER_TEMP/app-signing.keychain-db\nrm ~/Library/MobileDevice/Provisioning\\ Profiles/provisioning_profile.mobileprovision\n```\n\n### Deploy to AppStore Connect Workflow\n\nFinally, we obtain the following worklow that is stored as `deploy.yml` in the `.github/workflows` directory:\n\n```yml\nname: Deploy to AppStore Connect\n\non:\n  workflow_dispatch:\n\njobs:\n  archive-and-deploy:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Install App Store Connect Api Key\n        env:\n          API_KEY_BASE64: ${{ secrets.API_KEY_BASE64 }}\n        run: |\n          mkdir ~/.private_keys\n          echo -n "$API_KEY_BASE64" | base64 --decode --output ~/.private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8\n          echo "After saving:"\n          ls ~/.private_keys\n\n      - name: Install Signing Certificate\n        env:\n          SIGNING_CERTIFICATE_BASE64: ${{ secrets.SIGNING_CERTIFICATE_BASE64 }}\n          SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}\n          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}\n        run: |\n          SIGNING_CERTIFICATE_PATH=$RUNNER_TEMP/signing_certificate.p12\n          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n          # Read Signing Certificate\n          echo -n "$SIGNING_CERTIFICATE_BASE64" | base64 --decode -o "$SIGNING_CERTIFICATE_PATH"\n\n          # Create Keychain\n          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"\n          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"\n          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"\n\n          # Import Signing Certificate to Keychain\n          security import "$SIGNING_CERTIFICATE_PATH" -P "$SIGNING_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"\n          security list-keychain -d user -s "$KEYCHAIN_PATH"\n\n      - name: Install Provisioning Profile\n        env:\n          PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}\n        run: |\n          PROVISIONING_PROFILE_PATH=$RUNNER_TEMP/provisioning_profile.mobileprovision\n\n          # Read Provisioning Profile\n          echo -n "$PROVISIONING_PROFILE_BASE64" | base64 --decode -o "$PROVISIONING_PROFILE_PATH"\n\n          # Import Provisioning Profile\n          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\n          cp $PROVISIONING_PROFILE_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n\n      - name: Inject Build Number\n        run: |\n          buildNumber=${{ github.run_number }}\n          echo "Current build number: $buildNumber"\n          agvtool new-version -all $buildNumber\n          sed -i "" "s/CFBundleVersion/$buildNumber/" exportOptions.plist\n\n      - name: Configure exportOptions.plist\n        env: \n          TEAM_ID: ${{ vars.TEAM_ID }}\n          BUNDLE_ID: ${{ vars.BUNDLE_ID }}\n          PROVISIONING_PROFILE_NAME: ${{ vars.PROVISIONING_PROFILE_NAME }}\n        run: |\n          sed -i \'\' "s/{{TEAM_ID}}/$TEAM_ID/g" exportOptions.plist\n          sed -i \'\' "s/{{BUNDLE_ID}}/$BUNDLE_ID/g" exportOptions.plist\n          sed -i \'\' "s/{{PROVISIONING_PROFILE_NAME}}/$PROVISIONING_PROFILE_NAME/g" exportOptions.plist\n\n      - name: Build, Sign and Archive\n        run: |\n          set -o pipefail && xcodebuild clean archive \\\n            -scheme "App" \\\n            -archivePath $RUNNER_TEMP/App.xcarchive \\\n            -sdk iphoneos \\\n            -configuration Release \\\n            -destination generic/platform=iOS \\\n            CODE_SIGN_STYLE=Manual \\\n            PROVISIONING_PROFILE_SPECIFIER=Distribution | xcpretty\n\n      - name: Export archive\n        run: |\n          ARTIFACT_FILEPATH=$RUNNER_TEMP/App.ipa\n          set -o pipefail && xcodebuild -exportArchive \\\n            -archivePath $RUNNER_TEMP/App.xcarchive \\\n            -exportOptionsPlist exportOptions.plist \\\n            -exportPath $RUNNER_TEMP | xcpretty\n\n      - name: Publish App.ipa file\n        uses: actions/upload-artifact@v3\n        with:\n          name: App.ipa\n          path: ${{ runner.temp }}/App.ipa\n      \n      - name: Validate Build Artifact\n        run: |\n          xcrun altool --validate-app \\\n            -f ${{ runner.temp }}/App.ipa \\\n            -t ios \\\n            --apiKey ${{ secrets.API_KEY_ID }} \\\n            --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n\n      - name: Upload Build Artifact to TestFlight\n        run: |\n          xcrun altool --upload-app \\\n            -f ${{ runner.temp }}/App.ipa \\\n            -t ios \\\n            --apiKey ${{ secrets.API_KEY_ID }} \\\n            --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n\n      - name: Clean up keychain and provisioning profile\n        if: ${{ always() }}\n        run: |\n          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db\n          rm ~/Library/MobileDevice/Provisioning\\ Profiles/provisioning_profile.mobileprovision\n```\n\n# Conclusion\n\nIn this article, we went through the necessary steps to automate deployment of an iOS application via Github Actions. Having setup the dedicated workflow, we can release the app upon the press of a button and rather focus on building features while getting valuable feedback from testers and users. \n\n# References:\n\n- [Sign Xcode Applications](https://docs.github.com/en/actions/deployment/deploying-xcode-applications/installing-an-apple-certificate-on-macos-runners-for-xcode-development) - Github\n- [iOS CI/CD Worklfow using Github Actions](https://www.cobeisfresh.com/blog/how-to-implement-a-ci-cd-workflow-for-ios-using-github-actions) - cobeisfresh\n\nHappy Coding \uD83D\uDE80',title:"Automating your iOS App Development Workflow: Continuous Deployment with GitHub Actions",description:`In agile software development, continuous deployment is key to collect 
            user feedback leading to more reliable and successful iOS apps. Still, deploying to 
            AppStore Connect is challenging due to managing signing certificates, provisioning profiles, 
            and build numbers. In this article, we'll explore how to automate this process, allowing 
            you to release your apps with a single button press.`},{id:"2023-04-10",date:r()(new Date("2023-04-10")),markdown:'# Automating your iOS App Development Workflow: Continuous Testing with GitHub Actions\n\nAre you striving to iterate quickly to deliver new features, all while ensuring the reliability and performance of your iOS applications? Efficient workflows are key to achieving this goal. In this article, we\'ll explore how we can leverage the power of GitHub Actions to automate testing as part of the continuous integration process for iOS applications.\n\nLet\'s focus on the required steps to automate test execution when a pull-request is created:\n\n## Test Execution Workflow\n\nUnit tests are crucial in software development as they identify errors early in the process and enable safe code refactoring without regression. Running them often is particularly important in large-scale projects with multiple developers involved to obtain valuable feedback and maintain high code quality standards.\n\nWe initiate the "Unit Tests" workflow by establishing a blueprint that runs on agents featuring the latest macOS version. The workflow is either triggered manually via the Web interface or automatically upon branch activity after pull request creation:\n\n```yml\nname: Unit Tests\non:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  execute-unit-tests:\n    runs-on: macos-latest\n\n    steps:\n      ...\n```\n\nNext, we specify the steps that are required to execute unit tests on the agent:\n\n### Step 1: Checkout Repository\n\nFirst, we need to checkout the repository to gain access to the source code. Github Actions offers the `checkout@v3` step that checks-out your repository under `GITHUB_WORKSPACE`:\n\n```yaml\n- name: Checkout repository\n  uses: actions/checkout@v3\n```\n\n### Step 2: Create and Boot \'iPhoneForTesting\' Simulator\n\nNext, we create and boot the iOS Simulator, that is utilized to execute the tests. By default, `xcodebuild` selects any of the existing simulators on the agent, which may result in issues, particularly when using snapshot testing, due to potential variations in device dimensions and properties. \n\n`SIMULATOR_DEVICE_TYPE` and `SIMULATOR_RUNTIME` are environment variables that specify the exact device type and runtime. This way, all tests are executed on the same simulator accross agents. After the simulator is booted, we store its identifier in an environment variable (`SIMULATOR_IDENTIFIER`) to reference it as destination during test execution: \n\n```sh\nidentifier=$(\n  xcrun simctl create iPhoneForTesting \\\n  com.apple.CoreSimulator.SimDeviceType.$SIMULATOR_DEVICE_TYPE \\\n  com.apple.CoreSimulator.SimRuntime.$SIMULATOR_RUNTIME\n)\necho "Created iPhoneForTesting with identifier: $identifier"\nxcrun simctl boot $identifier\necho "Booted iPhoneForTesting with identifier: $identifier"\necho "SIMULATOR_IDENTIFIER=$identifier" >> $GITHUB_ENV\n```\n\n### Step 3: Execute Tests\n\nAs soon as the simulator is configured, we set it as destination and execute the tests after cleaning the project (`xcodebuild clean test`). Note that we set a custom `derivedDataPath` as well as `resultBundlePath` and also enable Code Covergae to access code coverage reports. In addition, we pipe the output generated from `xcodebuild`, store it in a local `xcodebuild.log` file and also pass it on to `xcpretty` that prints the output in a human readable format to the console.\n\n```sh\nset -o pipefail && xcodebuild clean test \\\n  -scheme "App" \\\n  -derivedDataPath $RUNNER_TEMP/build \\\n  -configuration \'Debug\' \\\n  -destination "platform=iOS Simulator,id=${SIMULATOR_IDENTIFIER}" \\\n  -resultBundlePath $RUNNER_TEMP/App.xcresult \\\n  -enableCodeCoverage YES | tee $RUNNER_TEMP/xcodebuild.log | xcpretty\n```\n\nWithout specifying `set -o pipefail` the command will only consider the exit status of the rightmost command, i.e., of `xcpretty`. By specifying `set -o pipefail` we ensure that output of `xcodebuild` is considered for the exit status of the whole command.\n\n### Step 4: Publish xcodebuild.log\n\nThe `xcodebuild.log` file contains the raw output of `xcodebuild` and is useful to investigate why the command has failed. Sometimes the error is hard to find and may be hidden by `xcpretty`. Publising the raw output as build artifact allows us to better understand what went wrong:\n\n```yaml\n- name: Publish xcodebuild.log\n  uses: actions/upload-artifact@v3\n  with:\n    name: xcodebuild.log\n    path: ${{ runner.temp }}/xcodebuild.log\n```\n\n### Step 5: Remove \'iPhoneForTesting\' Simulator\n\nFinally, after test execution is done, we can remove the simulator from the agent. Note that instead of only removing the simulator thet was created in the second step, we search for the identifiers of all simulators named `iPhoneForTesting` to cleanup the agent even when a previous removal has failed:\n\n```sh\nkillall Simulator 2>&1 || true\nxcrun simctl list devices | \\\n  grep "iPhoneForTesting" | \\\n  grep -E -o -i "([0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12})" | \\\n  while read -r identifier; do \\\n    xcrun simctl delete "$identifier"; \\\n    "Removed simulator with identifier: $identifier"; \\\n  done\n```\n\n### Unit Test Workflow\n\nAfter combining all steps, we obtain the following worklow that is stored as `test.yml` in the `.github/workflows` directory:\n\n```yml\nname: Unit Tests\non:\n  workflow_dispatch:\n\njobs:\n  execute-unit-tests:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Create and Boot \'iPhoneForTesting\' Simulator\n        env: \n          SIMULATOR_DEVICE_TYPE: ${{ vars.SIMULATOR_DEVICE_TYPE }}\n          SIMULATOR_RUNTIME: ${{ vars.SIMULATOR_RUNTIME }}\n        run: |\n          identifier=$(xcrun simctl create iPhoneForTesting com.apple.CoreSimulator.SimDeviceType.$SIMULATOR_DEVICE_TYPE com.apple.CoreSimulator.SimRuntime.$SIMULATOR_RUNTIME)\n          echo "Created iPhoneForTesting with identifier: $identifier"\n          xcrun simctl boot $identifier\n          echo "Booted iPhoneForTesting with identifier: $identifier"\n          echo "SIMULATOR_IDENTIFIER=$identifier" >> $GITHUB_ENV\n\n      - name: Test\n        env:\n          SIMULATOR_IDENTIFIER: ${{ env.SIMULATOR_IDENTIFIER }}\n        run: |\n          set -o pipefail && xcodebuild clean test \\\n            -scheme "App" \\\n            -derivedDataPath $RUNNER_TEMP/build\\\n            -configuration \'Debug\' \\\n            -destination "platform=iOS Simulator,id=${SIMULATOR_IDENTIFIER}" \\\n            -resultBundlePath $RUNNER_TEMP/App.xcresult \\\n            -enableCodeCoverage YES | tee $RUNNER_TEMP/xcodebuild.log | xcpretty\n\n      - name: Publish xcodebuild.log\n        uses: actions/upload-artifact@v3\n        with:\n          name: xcodebuild.log\n          path: ${{ runner.temp }}/xcodebuild.log\n\n      - name: Remove \'iPhoneForTesting\' Simulator\n        if: ${{ always() }}\n        run: |\n          killall Simulator 2>&1 || true\n          xcrun simctl list devices | \\\n            grep "iPhoneForTesting" | \\\n            grep -E -o -i "([0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12})" | \\\n            while read -r identifier; do xcrun simctl delete "$identifier"; echo "Removed simulator with identifier: $identifier"; done\n```\n\n# Conclusion\n\nIn this article, we explored how we can leverage the power of github actions to automate test execution whenever a pull-request is created. This is particularly useful in larger teams, as it effectively minimizes the occurrence of bugs and ensures continuous enhancement of the codebase.\n\n# References:\n\n- [Quickstart for Github Actions](https://docs.github.com/en/actions/quickstart) - Github\n- [Building from the Command Line with Xcode](https://developer.apple.com/library/archive/technotes/tn2339/_index.html) - Apple\n\nHappy Coding \uD83D\uDE80',title:"Automating your iOS App Development Workflow: Continuous Testing with GitHub Actions",description:`Are you striving to iterate quickly to deliver new features,
            all while ensuring the reliability and performance of your iOS application? 
            Efficient workflows are key to achieving this goal. In this article, we'll explore 
            how we can leverage the power of GitHub Actions to automate testing as part of the 
            continuous integration process for iOS applications.`},{id:"2022-11-13",date:r()(new Date("2022-11-13")),markdown:'# Story Numbers in Commit Messages: Leveraging the power of Git Hooks\n\nEspecially in large software projects with many developers involved, it is best practice to include the story number from the ticket system like Jira or Azure DevOps in every commit. This will let you refer to the original requirements quickly and see how the team thought about the feature, bug fix or release when it was developed. Still, manually adding the number to every commit is cumbersome. Hence, today, we will learn how to automatically derive the story number from the branch name and automate that procedure using Git Commit Hooks.\n\n![Branch History](article_13_11_2022_branch_history.png)\n\n## Story Number Extraction\n\nWe assume that branches are named according to the Git Flow naming conventions, i.e., production code is contained in the `master` while pre-production code is found in the `develop` branch. The latter is the starting point for features, bug-fixes and releases, while hotfixes are made from the `master` branch.\n\nBranches other than the `master` and `develop` also contain the story number in their name, represented as `SN-XXXXXX`, where `XXXXXX` are digits. The prefix `SN` as well as the number of digits may vary depending on the naming conventions used in your project. As a result, branch names match the following pattern:\n\n- /**\\<type\\>**/**SN-XXXXXX**-\\<description\\>, where `X in [0-9]` and `<type> in {feature, release, bugfix, hotfix}`\n\nSubsequently, examples for each branch type are given:\n- /**feature**/**SN-362845**-Add-dynamic-island-support\n- /**release**/**SN-284321**-Release-v3.0.0\n- /**bugfix**/**SN-839453**-Fix-memory-leak-in-home-tab\n- /**hotfix**/**SN-839453**-Fix-app-crash-in-onboarding\n\nThe idea is to automatically derive the story number from the branch name and include it in every commit. To achieve this, we leverage the power of git commit hooks to modify the message before the commit is made. As a result, adding the number becomes much simpler, since it does not need to be remembered among consecutive commits. Instead, developers only have to specify the story number once when the branch is created.\n\n## Shell Script: Prepare Commit Message Hook\n\nBelow, you can find the script that is executed as soon as a commit is made:\n\n```sh\n#!/bin/bash\n\ndetermine_branch_name() {\n  git rev-parse --abbrev-ref HEAD\n}\n\ndetermine_story_number() {\n  content=$1\n  \n  echo "$content" |\\\n    grep -Eo \'^(\\w+/)*(\\w+[-_])?[0-9]+\' |\\\n    grep -Eo \'(\\w+[-])+[0-9]+\' |\\\n    tr "[:lower:]" "[:upper:]"\n}\n\ncontained_in_list() {\n  list=$1\n  delimiter=$2\n  item=$3\n  [[ "$list" =~ ($delimiter|^)$item($delimiter|$) ]]\n}\n\nCOMMIT_EDITMSG_FILE=$1\nCOMMIT_MESSAGE=$(cat "$COMMIT_EDITMSG_FILE")\nBRANCH_NAME=$(determine_branch_name)\nSTORY_NUMBER=$(determine_story_number "$BRANCH_NAME")\nEXCLUDED_BRANCES="master, develop"\n\nif [ -n "$BRANCH_NAME" ] &&  ! contained_in_list "$EXCLUDED_BRANCES" ", " "$BRANCH_NAME"; then\n  if [ "$STORY_NUMBER" = "" ] || [[ "$COMMIT_MESSAGE" == "[$STORY_NUMBER]"* ]]; then\n    exit 0\n  else\n    echo "[$STORY_NUMBER] $COMMIT_MESSAGE" > "$COMMIT_EDITMSG_FILE"\n  fi\nfi\n``` \n\nFirst, we request a non-ambiguous abbreviation for the object referenced by HEAD:\n   \n```sh\ndetermine_branch_name() {\n  git rev-parse --abbrev-ref HEAD\n}\n```\n\nGiven the branch name, `determine_story_number` chains multiple extended regular expressions to identify the story number in case it exists. In addition, all lowercased letters are replaced by upper case letters:\n\n```sh\ndetermine_story_number() {\n  content=$1\n  \n  echo "$content" |\\\n    grep -Eo \'^(\\w+/)*(\\w+[-_])?[0-9]+\' |\\\n    grep -Eo \'(\\w+[-])+[0-9]+\' |\\\n    tr "[:lower:]" "[:upper:]"\n}\n```\n\n> Note: paths with an arbitrary step count are allowed:\n>    - /feature/SN-374324-Implement-Dark-Mode\n>    - /feature/navigation/SN-725342-Handle-In-App-Deeplink\n\nTo ensure that commits on the `master` or `develop` branch are not affected, we exit early in case that the branch is mentioned in the list of excluded branches. Likewise, we also ensure that the original commit message does not contain the story number yet. When all previous conditions are met, the original commit message is prefixed with the story number by modifying the content of the `COMMIT_EDITMSG_FILE`:\n\n```sh\nif [ -n "$BRANCH_NAME" ] &&  ! contained_in_list "$EXCLUDED_BRANCES" ", " "$BRANCH_NAME"; then\n  if [ "$STORY_NUMBER" = "" ] || [[ "$COMMIT_MESSAGE" == "[$STORY_NUMBER]"* ]]; then\n    exit 0\n  else\n    echo "[$STORY_NUMBER] $COMMIT_MESSAGE" > "$COMMIT_EDITMSG_FILE"\n  fi\nfi\n```\n\n## Using the Prepare Commit Message Hook in your Projects\n\nThe following steps are necessary to activate the hook in your project:\n\n1. Navigate to the *hooks*\' directory:\n\n   ```sh\n   cd /<git-repository>/.git/hooks\n   ```\n\n2. Create a file called `prepare-commit-msg`:\n\n   ```sh\n   touch prepare-commit-msg\n   ```\n\n   > Note: You can also remove the suffix `.sample` from `prepare-commit-msg.sample` in case it exists.\n\n3. Copy the script as the `prepare-commit-msg` hook\'s content:\n\n   ```sh\n   cat <script content> > prepare-commit-msg\n   ```\n\n4. Make the hook executable by updating its permissions:\n\n   ```sh\n   chmod a+x prepare-commit-msg\n   ```\n\nThat\'s it! As soon as the hook is active, the story number is read from the branch name and automatically included in every commit. \n\n# References:\n\n- [Git Commit Messages - Best Practices](https://initialcommit.com/blog/git-commit-messages-best-practices) - Matthew Forsyth\n- [Branch Naming Conventions](https://deepsource.io/blog/git-branch-naming-conventions/) - Sanket\n\nHappy Coding \uD83D\uDE80',title:"Story Numbers in Commit Messages: Leveraging the power of Git Hooks",description:`Especially in large software projects with many developers involved,
            it is best practice to include the story number from the ticket system
            like Jira or Azure DevOps in every commit. This will let you refer to
            the original requirements quickly and see how the team thought about the
            feature, bug fix or release when it was developed. Still, manually adding
            the number to every commit is cumbersome. Hence, today, we will learn how
            to automatically derive the story number from the branch name and automate
            that procedure using Git Commit Hooks.`},{id:"2022-03-16",date:r()(new Date("2022-03-16")),markdown:'![Logo](article_16_03_2022_logo_dark.png)\n\nToday we are going to take a look at how we can deal with asynchronous data in SwiftUI applications. Modern apps heavily rely on resources that are received over the network, and hence may be affected by connectivity issues or data loss. If, for example, you travel by train within Germany, you may be surprised how often you will experience radio gaps or interruptions due to weak cellular reception. Hence, we as developers have to design our apps to include feedback when an action takes longer than expected and offer the ability to retry the action in case that it failed. This way, we can make our apps stand out, since they can cope with conditions that are far from optimal.\n\nThis article introduces the reusable component `AsyncResourceView` that abstracts loading as well as failure states when fetching asynchronous data, such that we can focus on features rather than writing repetitive error-prone code.\n\n![Simple Example](article_16_03_2022_simple_example_tiny_dark.gif)\n\n## View Store\n\nFirst, let\'s implement the `AsyncResourceViewStore<Resource>` that is responsible for driving the UI. Given the loader, the store initially remains in the `notRequested` state until `loadResource` is called and the `loading` state is entered. Finally, depending on the result of the operation, either the `success` or `failure` state is entered.\n\nNote that the store is independent of SwiftUI and may be used with an alternative UI framework in the future. In addition, we ensure that state changes only occur on the main thread using the `@MainActor` annotation:\n\n```swift\npublic final class AsyncResourceViewStore<Resource>: ObservableObject {\n    public typealias Loader = () async throws -> Resource\n\n    public enum State {\n        case notRequested\n        case loading\n        case success(Resource)\n        case failure(Error)\n    }\n\n    @Published public var state: State\n\n    private var loader: Loader?\n\n    public init(state: State = .notRequested, loader: Loader? = nil) {\n        self.state = state\n        self.loader = loader\n    }\n\n    @MainActor\n    public func loadResource() async {\n        guard let loader = loader else { return }\n\n        state = .loading\n\n        do {\n            let resource = try await loader()\n            state = .success(resource)\n        } catch {\n            state = .failure(error)\n        }\n    }\n}\n```\n\n## Testing\n\nEven though its implementation looks simple, let\'s include unit tests to ensure that we are free to refactor the store in the future without changing its behavior. \n\nFirst, the store should be in the `notRequested` state. The `makeSUT` helper instantiates the `AsyncResourceViewStore` with a loader stub, such that we have control over its outcome when making assertions about the expected behavior.\n\nSecond, we expect the store to enter the `success` state when the resource loading succeeded. Similarly, we expect the store to enter the `failure` state in case that the resource loading failed.\n\nFinally, we also expect the store to enter the `success` state after the resource loading initially failed but later succeeded. This way, we ensure that the user will have the option to retry the action in case that it failed.\n\n```swift\nfinal class AsyncResourceViewStoreTests: XCTestCase {\n    func test_store_entersNotRequestedStateOnInit() {\n        let (sut, _) = makeSUT()\n\n        expectState(of: sut, toEqual: .notRequested)\n    }\n\n    func test_store_entersSuccessStateWhenResourceLoadingSucceeded() async throws {\n        let anyText = "any Text"\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .success(anyText)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .success(anyText))\n    }\n\n    func test_store_entersFailureStateWhenResourceLoadingFailed() async throws {\n        let error = anyNSError()\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .failure(error)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .failure(error))\n    }\n\n    func test_store_entersSuccessStateAfterResourceLoadingInitiallyFailed() async throws {\n        let anyText = "any Text"\n        let error = anyNSError()\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .failure(error)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .failure(error))\n\n        loaderStub.loadResult = .success(anyText)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .success(anyText))\n    }\n}\n\nextension AsyncResourceViewStoreTests {\n    typealias SUT = AsyncResourceViewStore<String>\n\n    private func makeSUT(expectedResult: Result<String, Error> = .success("")) -> (SUT, LoaderStub) {\n        let stub = LoaderStub()\n        let sut = SUT(loader: stub.load)\n        return (sut, stub)\n    }\n\n    private func anyNSError() -> NSError {\n        return NSError(domain: "any domain", code: 42, userInfo: nil)\n    }\n\n    private func expectState(\n        of sut: SUT,\n        toEqual expectedState: SUT.State,\n        file: StaticString = #filePath,\n        line: UInt = #line\n    ) {\n        switch (sut.state, expectedState) {\n        case (.notRequested, .notRequested), (.loading, .loading), (.success, .success):\n            break\n\n        case let (.failure(receivedError as NSError), .failure(expectedError as NSError)):\n            XCTAssertEqual(receivedError, expectedError, file: file, line: line)\n\n        default:\n            XCTFail("State \\(sut.state), does not match \\(expectedState)", file: file, line: line)\n        }\n    }\n\n    private class LoaderStub {\n        var loadResult: Result<String, Error>!\n\n        func load() async throws -> String {\n            switch loadResult! {\n            case let .success(text):\n                return text\n\n            case let .failure(error):\n                throw error\n            }\n        }\n    }\n}\n```\n\n## View\n\nAs we completed the store, let\'s continue with the `AsyncResourceView` that renders its children using the state-specific closures. While the `notRequested-`, `failure-` and `loading-` views are optional, we are required to specify the `success` view given the resource. This way, we can break down complexity and only have to deal with a single instead of multiple states at once.\n\n```swift\npublic struct AsyncResourceView<Resource>: View {\n    public typealias ViewStore = AsyncResourceViewStore<Resource>\n    public typealias NotRequestedView = (@escaping () -> Void) -> AnyView\n    public typealias LoadingView = () -> AnyView\n    public typealias FailureView = (Error, @escaping () -> Void) -> AnyView\n    public typealias SuccessView = (Resource) -> AnyView\n\n    @ObservedObject private var store: ViewStore\n\n    private var notRequestedView: NotRequestedView\n    private var loadingView: LoadingView\n    private var failureView: FailureView\n    private var successView: SuccessView\n\n    public init(\n        store: ViewStore,\n        notRequestedView: @escaping NotRequestedView = { AnyView(AsyncResourceDefaultNotRequestedView(load: $0)) },\n        loadingView: @escaping LoadingView = { AnyView(AsyncResourceDefaultLoadingView()) },\n        failureView: @escaping FailureView = { AnyView(AsyncResourceDefaultFailureView(error: $0, retry: $1)) },\n        successView: @escaping SuccessView\n    ) {\n        self.store = store\n        self.notRequestedView = notRequestedView\n        self.loadingView = loadingView\n        self.failureView = failureView\n        self.successView = successView\n    }\n\n    public var body: some View {\n        switch store.state {\n        case .notRequested:\n            return notRequestedView(loadResource)\n\n        case .loading:\n            return loadingView()\n\n        case let .success(resource):\n            return successView(resource)\n\n        case let .failure(error):\n            return failureView(error, loadResource)\n        }\n    }\n\n    private func loadResource() {\n        Task { await store.loadResource() }\n    }\n}\n```\n\n### Default Views\n\n#### AsyncResourceDefaultNotRequestedView\n\nFor example, using the `notRequested` view, we can specify how the UI should look like until the resource is requested. Note that the default representation is not visible and is only used to trigger the callback as soon as it appeared. Instead, one can also think of a visual representation that features a button to let the user decide when the action is run.\n\n```swift\npublic struct AsyncResourceDefaultNotRequestedView: View {\n    private let load: () -> Void\n\n    public init(load: @escaping () -> Void) {\n        self.load = load\n    }\n\n    public var body: some View {\n        Color.clear\n            .onAppear(perform: load)\n    }\n}\n```\n\n#### AsyncResourceDefaultLoadingView\n\nIn contrast, the default `loading` view is visible and will indicate progress until either the *success* or *failure-* state is entered.\n\n```swift\npublic struct AsyncResourceDefaultLoadingView: View {\n    private let title: String\n\n    public init(title: String = "Loading") {\n        self.title = title\n    }\n\n    public var body: some View {\n        ProgressView(title)\n    }\n}\n```\n\n#### AsyncResourceDefaultFailureView\n\nFinally, in case no `failure` closure exists, the `AsyncResourceDefaultFailureView` renders a counterclockwise arrow to retry the action in case that it failed. Note that custom views may also consider the error to provide additional information about why the action did not work as intended.\n\n![Default Failure View](article_16_03_2022_default_failure_view.png)\n\n```swift\npublic struct AsyncResourceDefaultFailureView: View {\n    private let error: Error\n    private let retry: () -> Void\n\n    public init(error: Error, retry: @escaping () -> Void) {\n        self.error = error\n        self.retry = retry\n    }\n\n    public var body: some View {\n        VStack(spacing: 16) {\n            Button(action: retry) {\n                Image(systemName: "arrow.counterclockwise")\n                    .font(.system(size: 25))\n                    .tint(.accentColor)\n            }\n        }\n    }\n}\n```\n\n## Previews\n\nUndoubtedly, one of the great advantages of SwiftUI over UI Kit is that we can get real-time feedback about how the rendering is composed. This is especially true when dealing with interactive previews that offer great insights into the look and feel of a component. Subsequently, you can find examples for a static as well as interactive preview:\n\n```swift\nstruct AsyncResourceView_Previews: PreviewProvider {\n    static var previews: some View {\n        NavigationView {\n            AsyncResourceView(\n                store: AsyncResourceViewStore(state: .success("Hello World")),\n                successView: { text in\n                    AnyView(Text(text))\n                }\n            )\n            .navigationTitle("Static Preview")\n        }\n\n        NavigationView {\n            AsyncResourceView(\n                store: AsyncResourceViewStore(loader: loader),\n                notRequestedView: { load in\n                    AnyView(\n                        Button("Load Resource", action: load)\n                            .buttonStyle(.borderedProminent)\n                    )\n                },\n                successView: { text in\n                    AnyView(Text(text))\n                }\n            )\n            .navigationTitle("Interactive Preview")\n        }\n    }\n}\n\nprivate let loader: () async throws -> String = {\n    try await Task.sleep(nanoseconds: 2_000_000_000)\n\n    if Bool.random() {\n        return "Hello World"\n    } else {\n        throw NSError(domain: "any domain", code: 42, userInfo: nil)\n    }\n}\n```\n\nWhile the static preview renders itself based on the predefined state of the store, the interactive preview explicitly communicates with the loader and waits until the result is made. Since, the loader may fail, we throw a dice and either return the resource (i.e., “Hello World”) or an error. The latter will result in the failure state, where we can retry the action without leaving the preview.\n\n## Use Case Example: "Color Gallery"\n\n![Gallery Example](article_16_03_2022_gallery_example_dark_optimized.gif)\n\nTo visualize how the component is used, let\'s implement a color gallery where items are arranged in a three-column grid. Each item features the `AsyncResourceView` to request its color from the loader that will either return a random color or fail after [0.3, 3.0] seconds. As stated above, a retry button is shown in case the action failed. \n\n```swift\n@main\nstruct AsyncResourceGalleryApp: App {\n    @StateObject\n    private var store: GalleryStore = .init()\n\n    var body: some Scene {\n        WindowGroup {\n            GalleryView(\n                store: store,\n                itemView: { item -> AnyView in\n                    let store = AsyncResourceViewStore<Color>(loader: loader(item))\n                    return AnyView(GalleryItemView(store: store))\n                }\n            )\n            .onAppear(perform: store.onAppear)\n        }\n    }\n}\n\nextension AsyncResourceGalleryApp {\n    private func loader(_ item: GalleryItem) -> (() async throws -> Color) {\n        return {\n            let duration = UInt64.random(in: 300_000_000 ... 3_000_000_000)\n            try await Task.sleep(nanoseconds: duration)\n            if Int.random(in: 0...5) == 4 {\n                throw NSError(domain: "", code: 42, userInfo: nil)\n            } else {\n                return item.color\n            }\n        }\n    }\n}\n```\n\nSince we do not specify a custom `notRequested` view, the default view is used that requests the resource as soon as it appeared. By wrapping the items in SwiftUI\'s `LazyVGrid` they are only created when needed.\n\n```swift\nstruct GalleryView: View {\n    private var store: GalleryStore\n    private let columns: [GridItem] = [\n        GridItem(.flexible(minimum: 50), spacing: 50),\n        GridItem(.flexible(minimum: 50), spacing: 50),\n        GridItem(.flexible(minimum: 50), spacing: 50)\n    ]\n    private let itemView: (GalleryItem) -> AnyView\n\n    init(store: GalleryStore, itemView: @escaping (GalleryItem) -> AnyView) {\n        self.store = store\n        self.itemView = itemView\n    }\n\n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: columns, spacing: 50) {\n                ForEach(store.items, id: \\.self) { item in\n                    itemView(item)\n                        .frame(width: 100, height: 100)\n                }\n            }\n            .padding()\n        }\n    }\n}\n```\n\nEach of the items is driven by its own store, i.e., `AsyncResourceViewStore` that transitions between states depending on how long the action takes.\n\n```swift\nstruct GalleryItemView: View {\n    private let store: AsyncResourceViewStore<Color>\n\n    init(store: AsyncResourceViewStore<Color>) {\n        self.store = store\n    }\n\n    var body: some View {\n        AsyncResourceView(store: store) { color in\n            AnyView(color)\n        }\n    }\n}\n```\n\nFinally, we create a `GalleryStore` that drives the composition and provides a color for each individual loader.\n\n```swift\nfinal class GalleryStore: ObservableObject {\n    @Published var items: [GalleryItem] = []\n\n    func onAppear() {\n        items = (0 ..< 100)\n            .map { _ in Color.random }\n            .map { GalleryItem(color: $0 )}\n    }\n}\n\nstruct GalleryItem: Hashable {\n    let id: UUID\n    let color: Color\n\n    init(id: UUID = .init(), color: Color) {\n        self.id = id\n        self.color = color\n    }\n}\n```\n\n# Conclusion\n\nIn this article, I presented the `AsyncResourceView`, a consistent way to deal with asynchronous resources in SwiftUI applications. Using the component, we can avoid repetitive code and spend more time on implementing features rather than writing the same loading- or error handling code throughout the App. You can checkout the project on GitHub ([Link](https://github.com/LinkAndreas/AsyncResourceView)). \n\nHappy Coding \uD83D\uDE80\n\n\n\n\n',title:"AsyncResourceView: Simplified Resource Loading",description:`Modern apps heavily rely on resources that are received
            over the network, and hence may be affected by connectivity issues
            or data loss. If, for example, you travel by train within Germany,
            you may be surprised how often you will experience radio gaps or
            interruptions due to weak cellular reception. Hence, we as developers
            have to design our apps to include feedback when an action takes longer
            than expected and offer the ability to retry the action in case that
            it failed. This way, we can make our apps stand out, since they can
            cope with conditions that are far from optimal.
    
            AsyncResourceView offers a consistent way to deal with loading as well as
            error states in SwiftUI applications. This way, developers can focus on
            features rather than writing repetitive error-prone code.`},{id:"2021-03-09",date:r()(new Date("2021-03-09")),markdown:'![Licenses App](article_09_03_2021_app.png)\n\n# Building a native macOS app using SwiftUI and Combine\n\nHave you ever been asked to put together the list of licenses of all frameworks that are used within your iOS, iPad OS, or macOS app? Manually completing this task quickly becomes tedious but may be required due to legal- or customer requests.\n\nTo mitigate this issue, I developed **Licenses**, a native macOS app that automates this procedure by collecting and exporting your licenses into a single spreadsheet (CSV) file.\n\nIn this article, I want to share my experience as well as the challenges that I faced when developing the app using _SwiftUI 2.0_ and _Combine_. This way, I hope to provide additional documentation on how declarative macOS apps can be built and to encourage others to also bring their ideas to the Mac.\n\nYou can get the latest version of Licenses in the Mac AppStore ([Link](https://apps.apple.com/us/app/licenses/id1545822966)) or check out the project on GitHub ([Link](https://github.com/LinkAndreas/Licenses)).\n\n# Architecture\n\n_Licenses_, uses a redux-inspired architecture, as illustrated in figure 1, consisting of Data-, Bloc-, ViewStore- and UI-related components. This way, state changes only occur within the bloc\'s reducer function, transforming incoming actions as well as the current state to an updated state that is ultimately consumed by the UI.\n\n![Architecture](article_09_03_2021_architecture.png)\n\nAlso, side effects are performed by returning publishers from the reducer resulting in additional actions that are sent to the bloc. Hence, asynchronous work is treated similarly to synchronous work in the way that it only affects the state from within the reducer. Thus, the correctness of the reducer and as such the correctness of all state changes becomes testable through unit tests.\n\nNote that blocs are not directly connected to the UI, but rather via view stores that act as the main communication gateway of the view. As a result, domain-specific knowledge is not exposed, but rather gets translated into view-specific models that only include the formatted data that is ready to be shown in the UI. As an example, instead of passing repositories, i.e., `[GitHubRepository]`, to the view directly, we can rather pass a list of items, i.e., `[ListItem]`, where each item only consists of UI-related data (e.g., `title` or `subtitle`) and omits any internal data that is repository-specific. Similarly, view actions are translated into domain-specific actions that are forwarded by the view store to the bloc. Excluding business- and domain-specific knowledge out of the view keeps them lean and facilitates simplified previews using mock data in Xcode.\n\nHaving established an architectural overview of the app, let\'s focus on the business logic in terms of the processing pipeline and CSV export.\n\n# Business Logic:\n\nUsers can select manifests in _Licenses_ by either dragging them on top of the application\'s window or choosing them manually from disk. In this regard, it does not matter whether a single or multiple files are selected or whether they are kept in an enclosing folder. Either way, _Licenses_ searches for manifests at the specified location and forwards their `filePaths: [URL]` to the processing pipeline. As soon as licenses could be derived, the user can export them into a single spreadsheet file (CSV).\n\n## The Manifest Processing Pipeline:\n\nAs illustrated in figure 2, decoding and extracting licenses involves three consecutive steps:\n\n![Manifest Processing Pipeline](article_09_03_2021_flow.png)\n\n### Step 1: Manifest Publisher:\n\nFirst, _Licenses_ searches for files named "Package.resolved" (SwiftPm), "Cartfile.resolved" (Carthage) or "Podfile.lock" (CocoaPods) and instantiates a `Manifest` for each occurence respectively.\n\n```swift\nimport Combine\nimport Foundation\n\nstruct ManifestPublisher: Publisher {\n    typealias Output = Manifest\n    typealias Failure = Never\n\n    private let subject: PassthroughSubject<Manifest, Never> = .init()\n    private let dispatchGroup: DispatchGroup = .init()\n    private let dispatchQueue: DispatchQueue = .global(qos: .userInitiated)\n    private let filePaths: [URL]\n\n    init(filePaths: [URL] = []) {\n        self.filePaths = filePaths\n    }\n\n    func receive<S>(subscriber: S) where S: Subscriber, Self.Failure == S.Failure, Self.Output == S.Input {\n        subject.subscribe(subscriber)\n\n        search(at: filePaths)\n    }\n\n    private func search(at filePaths: [URL] = []) {\n        filePaths.forEach { filePath in\n            dispatchGroup.enter()\n            dispatchQueue.async(group: dispatchGroup) {\n                defer { self.dispatchGroup.leave() }\n\n                var isDirectory: ObjCBool = false\n                let fileManager: FileManager = .init()\n\n                guard fileManager.fileExists(atPath: filePath.path, isDirectory: &isDirectory) else { return }\n\n                if isDirectory.boolValue {\n                    let enumerator = fileManager.enumerator(at: filePath, includingPropertiesForKeys: nil)\n                    while let nextFilePath: URL = enumerator?.nextObject() as? URL {\n                        guard let manifest = Manifest(fromFilePath: nextFilePath) else { continue }\n\n                        self.subject.send(manifest)\n                    }\n                } else {\n                    guard let manifest = Manifest(fromFilePath: filePath) else { return }\n\n                    self.subject.send(manifest)\n                }\n            }\n        }\n\n        dispatchGroup.notify(queue: .main) {\n            self.subject.send(completion: .finished)\n        }\n    }\n}\n```\n\nThe initializer matches the last component of the given file path against a predefined set of identifiers. As soon as a match is made, the package manager associated with the file name is assigned to the manifest. Note that the latter is required to determine the decoding strategy that is used to derive packages from the manifest.\n\n```swift\nstruct Manifest: Equatable {\n    var packageManager: PackageManager\n    var content: String\n    var filePath: URL\n\n    init(\n        packageManager: PackageManager,\n        content: String,\n        filePath: URL\n    ) {\n        self.packageManager = packageManager\n        self.content = content\n        self.filePath = filePath\n    }\n\n    init?(fromFilePath filePath: URL) {\n        switch filePath.lastPathComponent {\n        case "Cartfile.resolved":\n            self.packageManager = .carthage\n\n        case "Podfile.lock":\n            self.packageManager = .cocoaPods\n\n        case "Package.resolved":\n            self.packageManager = .swiftPm\n\n        default:\n            return nil\n        }\n\n        guard let content = try? String(contentsOf: filePath, encoding: .utf8) else { return nil }\n\n        self.content = content\n        self.filePath = filePath\n    }\n}\n\n```\n\n### Step 2: ManifestDecodingStrategy\n\nSecond, _Licenses_ tries to retrieve the minimum set of data, like the name, author, and version of the package by applying the decoding strategy that is associated with its type. Since the decoding may fail due to syntax errors or missing information, _Licenses_ tries to handle these cases gracefully by continuing decoding the remaining set of manifests.\n\nNote that the algorithm makes use of the strategy pattern to be easily extensible in the future if new package managers come along. This way, we can define additional strategies by conforming to the `ManifestDecodingStrategy` protocol:\n\n```swift\nprotocol ManifestDecodingStrategy {\n    func decode(content: String) -> AnyPublisher<GithubRepository, Never>\n}\n\n```\n\nAs an example, please consider the implementation of the `SwiftPmManifestDecodingStrategy` as stated below. If the strategy could decode the given content as `ResolvedPackagesEntity` it publishes an instance of `GithubRepository` for each package respectively.\n\n```swift\nimport Combine\nimport Foundation\n\nstruct SwiftPmManifestDecodingStrategy: ManifestDecodingStrategy {\n    func decode(content: String) -> AnyPublisher<GithubRepository, Never> {\n        guard\n            let data = content.data(using: .utf8),\n            let resolvedPackages = try? JSONDecoder().decode(ResolvedPackagesEntity.self, from: data)\n        else {\n            return Empty<GithubRepository, Never>().eraseToAnyPublisher()\n        }\n\n        return resolvedPackages\n            .object\n            .pins\n            .publisher\n            .compactMap { (package: PinEntity) -> GithubRepository? in\n                guard\n                    let (name, author) = GithubRepositoryUrlDecoder.decode(repositoryUrlString: package.repositoryUrl)\n                else { return nil }\n\n                let url: URL = GithubRepositoryUrlEncoder.encode(name: name, author: author)\n\n                return .init(\n                    packageManager: .swiftPm,\n                    name: name,\n                    version: package.state.version,\n                    author: author,\n                    url: url\n                )\n            }\n            .eraseToAnyPublisher()\n    }\n}\n```\n\nIt is important to note that packages derived from CocoaPod manifests do not include their author and hence require additional processing before licenses are fetched using the GitHub API.\nThe `CocoaPodsRepositoryProcessor` takes care of this requirement and uses the package manager\'s centralized registry named "CocoaPodsTrunk" to retrieve the missing information of the package.\n\n### Step 3: LicenseProcessor - Retrieving Licenses from GitHub:\n\nFinally, given the name and author of a package we have collected sufficient information to retrieve its licenses using the Github API:\n\n```swift\nstruct LicenseRepositoryProcessor: RepositoryProcessor {\n    func process(repository: GithubRepository) -> AnyPublisher<GithubRepository, Never> {\n        guard\n            repository.license == nil,\n            let (name, author) = GithubRepositoryUrlDecoder.decode(repositoryURL: repository.url)\n        else {\n            return Just<GithubRepository>(repository)\n                .eraseToAnyPublisher()\n        }\n\n        return API.requestMappedModel(\n            Github.license(name: name, author: author),\n            mapper: GithubLicenseModelMapper.map\n        )\n        .receive(on: RunLoop.main)\n        .map { license in\n            let modifiedRepository: GithubRepository = repository\n            modifiedRepository.license = license\n            return modifiedRepository\n        }\n        .catch { _ in Just<GithubRepository>(repository) }\n        .eraseToAnyPublisher()\n    }\n}\n```\n\nNote that network requests in _Licenses_ are made using _Aphrodite_ ([Link](https://github.com/LinkAndreas/Aphrodite)), a lightweight, generic, and reactive network layer that is built on top of Combine and `NSURLSession`. This way, the `LicenseRepositoryProcessor` does not need to deal with the raw data that is returned from the Github API but rather uses a simplified model that results from the clear entity- and domain model separation offered by Aphrodite.\n\nConsequently, all the above-mentioned steps are executed by the reducer directly or returned as side effects resulting in additional actions that are fed back into the bloc. Thus, state changes can only happen at a predefined location. Subsequently, please find the handling of the\xa0`.fetchLicenses` action that corresponds to the third step of the processing pipeline:\n\n```swift\nimport Combine\nimport Foundation\n\nstruct AppReducer: BlocReducer {\n    func reduce(\n        state: inout AppState,\n        action: AppAction,\n        environment: AppEnvironment\n    ) -> Effect<AppAction, Never> {\n        switch action {\n        case .fetchLicenses:\n            return state.repositories\n                .filter { $0.license == nil }\n                .publisher\n                .flatMap(maxPublishers: .max(3)) { repository in\n                    Just(repository)\n                        .flatMap { (repository: GithubRepository) -> AnyPublisher<GithubRepository, Never> in\n                            environment.cocoaPodsProcessor.process(repository: repository)\n                                .eraseToAnyPublisher()\n                        }\n                        .flatMap { repository in\n                            environment.licenseProcessor.process(repository: repository)\n                                .eraseToAnyPublisher()\n                        }\n                }\n                .receive(on: RunLoop.main)\n                .map(AppAction.didProcess(repository:))\n                .prepend(AppAction.didStartFetchingLicenses)\n                .append(AppAction.didStopFetchingLicenses)\n                .eraseToEffect()\n\n            ...\n        }\n    }\n}\n```\n\nAs a result, we obtain the enriched list of repositories (`[GithubRepository]`), ready to be exported or shown in the UI.\n\n## CSV Export\n\nTo export licenses into a machine-readable format, _Licenses_ uses the `CSVRowFactory` to generate the header as well as the body including the `name`, `version`, `author`, and `license` of the given repositories. Note that the content of each row gets normalized to avoid malformed data:\n\n```swift\nstruct CSVRowFactory {\n    func makeRows(from repositories: [GithubRepository]) -> [[String]] {\n        [makeHeaderRow()] + repositories.map(makeRow(from:))\n    }\n}\n\nextension CSVRowFactory {\n    private func makeHeaderRow() -> [String] {\n        [\n            L10n.Csv.Header.Name.title,\n            L10n.Csv.Header.Version.title,\n            L10n.Csv.Header.PackageManager.title,\n            L10n.Csv.Header.Author.title,\n            L10n.Csv.Header.LicenseUrl.title,\n            L10n.Csv.Header.LicenseName.title,\n            L10n.Csv.Header.LicenseContent.title\n        ]\n    }\n\n    private func makeRow(from repository: GithubRepository) -> [String] {\n        normalize(\n            row: [\n                repository.name,\n                repository.version,\n                repository.packageManager.rawValue,\n                repository.author ?? "",\n                repository.license?.downloadURL ?? "",\n                repository.license?.license?.name ?? "",\n                repository.license?.decodedContent ?? ""\n            ]\n        )\n    }\n\n    private func normalize(row: [String]) -> [String] {\n        row.map { string in\n            guard string.contains("\\"") || string.contains(",") else { return string }\n\n            let doubleQuotesEscapedString: String = string.replacingOccurrences(of: "\\"", with: "\\"\\"")\n            return "\\("\\"")\\(doubleQuotesEscapedString)\\("\\"")"\n        }\n    }\n}\n```\n\nFinally, each generated row is written to the specified destination:\n\n```swift\nimport Foundation\n\nenum CSVExporterError: Error {\n    case columnMismatch\n}\n\nprotocol CSVExporter {\n    func exportCSV(fromRows rows: [[String]], toDestination destination: URL)\n}\n\nstruct DefaultCSVExporter: CSVExporter {\n    func exportCSV(fromRows rows: [[String]], toDestination destination: URL) {\n        do {\n            let csvString: String = try makeCSV(fromRows: rows)\n            try csvString.write(to: destination, atomically: true, encoding: .utf8)\n        } catch {\n            print(error.localizedDescription)\n        }\n    }\n\n    private func makeCSV(fromRows rows: [[String]]) throws -> String {\n        var numberOfColumnsInHeader: Int?\n        return try (0 ... (rows.count - 1)).reduce("") { csv, index in\n            let nextRow: [String] = rows[index]\n\n            if index == 0 {\n                numberOfColumnsInHeader = nextRow.count\n            } else {\n                guard\n                    let numberOfColumnsInHeader = numberOfColumnsInHeader,\n                    nextRow.count == numberOfColumnsInHeader\n                else {\n                    throw CSVExporterError.columnMismatch\n                }\n            }\n\n            return csv + (index > 0 ? "\\n" : "") + "\\(nextRow.joined(separator: ","))"\n        }\n    }\n}\n\n```\n\n# User Interface\n\nHaving referred to the _processing pipeline_ and CSV export as the main driver of the app, let\'s focus on the UI as well as the challenges that I faced when bringing _Licenses_ to the Mac.\n\n## App Lifecycle\n\nWith the introduction of the SwiftUI lifecycle at WWDC 2020, Apple removed the need for an `App-/SceneDelegate` and offered a declarative API to specify the entry point of the app. _Licenses_ uses a `WindowGroup` as well as a preferences pane that is accessible via the menu as its building blocks. Additional entries like the app\'s privacy policy are realized using the `.commands()` modifier:\n\n![Menu Command](article_09_03_2021_menuCommand.png)\n\n```swift\nimport SwiftUI\n\n@main\nstruct LicensesApp: App {\n    @NSApplicationDelegateAdaptor(AppDelegate.self) var delegate: AppDelegate\n\n    var body: some Scene {\n        WindowGroup {\n            WindowContentContainerView()\n                .frame(\n                    minWidth: 1_000,\n                    idealWidth: 1_200,\n                    minHeight: 650,\n                    idealHeight: 800,\n                    alignment: .center\n                )\n        }.commands {\n            CommandGroup(after: .help) {\n                Button(L10n.PrivacyPolicy.title) {\n                    guard let url = URL(string: L10n.PrivacyPolicy.url) else { return }\n\n                    NSWorkspace.shared.open(url)\n                }\n            }\n        }\n\n        Settings {\n            SettingsContainerView()\n        }\n    }\n}\n```\n\nWhen adopting the SwiftUI lifecycle, it was difficult at first to come up with a solution to specify that the application should terminate as soon as the last window was closed. Luckily, Apple provides the `@NSApplicationDelegateAdaptor` property wrapper that supports functionality that is not covered by the declarative approach yet. This way, the intended behavior is specified in an additional `AppDelegate` class:\n\n```swift\nfinal class AppDelegate: NSObject, NSApplicationDelegate {\n    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {\n        return true\n    }\n}\n```\n\n## Bloc- and ViewStoreProvider\n\nWithin the window group, container views are used to provide the bloc as well as the view store for the window\'s content view. Note that the `BlocProvider` uses the `@StateObject` property wrapper internally to ensure that the lifetime of the bloc is bound to the lifespan of the window. To request a bloc via the `BlocProvider` we only need to provide the bloc\'s initial state as well as its reducer function that is used for handling state changes of the window. Finally, given the bloc, the `ViewStoreProvider` establishes the mapping between the view-specific state/actions as well as the domain-specific state/actions using the `WindowContentViewStateMapper` and `WindowContentViewActionMapper` respectively. Injecting providers via container views keeps our content views lean and facilitates UI development using SwiftUI previews.\n\n```swift\nstruct WindowContentContainerView: View {\n    var body: some View {\n        BlocProvider<AppState, AppAction, AppEnvironment>(\n            initialState: .initial,\n            reducer: AppReducer().eraseToAnyBlocReducer(),\n            environment: DefaultEnvironment()\n        ) { bloc in\n            ViewStoreProvider(\n                statePublisher: AnyStatePublisher(\n                    publisher: bloc,\n                    stateMapper: WindowContentViewStateMapper.map(state:)\n                ),\n                actionReceiver: AnyActionReceiver(\n                    receiver: bloc,\n                    actionMapper: WindowContentViewActionMapper.map(action:)\n                )\n            ) { store in\n                WindowContentView(store: store)\n            }\n        }\n    }\n}\n```\n\n## Window Content\n\nIn _Licenses_ the `WindowContentView` is made of smaller views that together compose the UI:\n\n![App Structure](article_09_03_2021_appStructure.png)\n\nHence, the content view uses the `ViewStore` of its parent to derive smaller stores that are dedicated for each child. As an example, the file drop area\'s store is derived from the parent by limiting its scope to the `fileDropAreaState` property. In addition, the `actionMapper` establishes the mapping between `FileDropAreaViewActions` and `WindowActions`.\n\n```swift\nstruct WindowContentView: View {\n    @ObservedObject var store: ViewStore<WindowContentViewState, WindowContentViewAction>\n\n    var body: some View {\n        FileDropAreaView(\n            store: store.derived(\n                stateMapper: \\.fileDropAreaState,\n                actionMapper: WindowContentViewAction.fileDropArea(action:)\n            )\n        ) {\n            NavigationView {\n                MasterView(\n                    store: store.derived(\n                        stateMapper: \\.masterState,\n                        actionMapper: WindowContentViewAction.master(action:)\n                    )\n                )\n                DetailView(\n                    store: store.derived(\n                        stateMapper: \\.detailState,\n                        actionMapper: WindowContentViewAction.detail(action:)\n                    )\n                )\n            }\n            .toolbar {\n                ToolbarItems(\n                    store: store.derived(\n                        stateMapper: \\.toolbarState,\n                        actionMapper: WindowContentViewAction.toolbar(action:)\n                    )\n                )\n            }\n        }\n        .sheet(\n            isPresented: store.binding(\n                get: \\.isOnboardingPresented,\n                send: { isOnboardingPresented in .updateIsOnboardingCompleted(!isOnboardingPresented) }\n            ),\n            content: {\n                OnboardingView(\n                    store: store.derived(\n                        stateMapper: \\.onboardingState,\n                        actionMapper: WindowContentViewAction.onboarding(action:)\n                    )\n                )\n            }\n        )\n        .onAppear { store.send(.didAppear) }\n        .onDisappear { store.send(.didDisappear) }\n    }\n}\n```\n\n### File Drop Area\n\nNote that SwiftUI features the `onDrop(of:isTargeted:content)` modifier which is well-suited for our needs. In addition to the supported file type, i.e., "public.file-url", we also specify a binding to `isTargeted` property of the store. Note that the binding is derived from the store such that it sends a `.didUpdateIsTargeted(Bool)` action as soon as a change is made. Similarly, the view store is notified by the view when files of the specified type are detected (`.didSelectProviders([NSItemProvider]`).\n\n```swift\nimport SwiftUI\n\nstruct FileDropAreaView<Content: View>: View {\n    @ObservedObject var store: ViewStore<FileDropAreaViewState, FileDropAreaViewAction>\n\n    private let content: () -> Content\n\n    init(\n        store: ViewStore<FileDropAreaViewState, FileDropAreaViewAction>,\n        @ViewBuilder content: @escaping () -> Content\n    ) {\n        self._store = .init(initialValue: store)\n        self.content = content\n    }\n\n    var body: some View {\n        GeometryReader { geometry in\n            Group {\n                VStack {\n                    self.content()\n                        .onDrop(\n                            of: store.supportedFileTypes,\n                            isTargeted: store.binding(\n                                get: \\.isTargeted,\n                                send: { isTargeted in .didUpdateIsTargeted(isTargeted) }\n                            )\n                        ) { providers -> Bool in\n                            store.send(.didSelectProviders(providers))\n                            return true\n                        }\n                        .border(store.borderColor)\n                }\n                .frame(width: geometry.size.width, height: geometry.size.height)\n            }\n        }\n    }\n}\n```\n\nThe file drop area\'s content consists of the `NavigationView` that establishes the master-detail relationship between the repository list (master) and the repository\'s detail view. Note that the latter is only shown when repositories exist. Otherwise, a placeholder is shown asking the user to either import manifests manually from disk or to use one of the example-manifests that are bundled with the app.\n\n![Detail Placeholder](article_09_03_2021_placeholder.png)\n\n### Repository List (Master)\n\nAs soon as manifests are selected, detected repositories are shown in NavigationView\'s sidebar. Unfortunately, I could not find a solution to specify different styles for the background of a list item, similar to what is offered by the `.emphasized` style of `NSTableViewCell`. The behavior is desired since we can improve the readability of the selected item by adapting the font color of the title and subtitle label in case that the item is selected:\n\n![Emphasized State](article_09_03_2021_emphasizedState.png)\n\nAlthough you can pass a binding to access the selected item, it does not account for the emphasized state of the cell and is only changed when the selection got made. To provide feedback even before the cursor is lifted, I decided to bridge to a standard `NSTableView` using the `NSViewControllerRepresentable` protocol:\n\n```swift\nimport SwiftUI\n\nstruct RepositoryListView: NSViewControllerRepresentable {\n    @ObservedObject var store: ViewStore<RepositoryListViewState, RepositoryListViewAction>\n\n    func updateNSViewController(_ nsViewController: RepositoryListViewController, context: Context) {\n        return\n    }\n\n    func makeNSViewController(context: Context) -> RepositoryListViewController {\n        return .init(store: store)\n    }\n}\n\nstruct RepositoryListView_Previews: PreviewProvider {\n    static var previews: some View {\n        RepositoryListView(store: .constant(state: PreviewData.RepositoryList.state))\n    }\n}\n```\n\nNote that in the future we can drop the `NSTableView` and rather use SwiftUI\'s default `List` component as soon as the emphasized state is supported. If you are interested in the detailed implementation of the `NSTableView` please have a look at the source code on Github ([Link](https://github.com/LinkAndreas/Licenses)).\n\n### Repository Metadata (Detail)\n\nThe detail view of the `NavigationView` provides additional metadata about the selected repository, like the license\'s type and content that was fetched using the Github API:\n\n```swift\nstruct DetailView: View {\n    @ObservedObject var store: ViewStore<DetailViewState, DetailViewAction>\n\n    var body: some View {\n        Group {\n            ViewStoreWithNonOptionalStateProvider(\n                from: store.derived(stateMapper: \\.listState).withoutActions,\n                success: DetailListView.init(store:),\n                failure: ViewStoreWithNonOptionalStateProvider(\n                    from: store.derived(\n                        stateMapper: \\.placeholderState,\n                        actionMapper: DetailViewAction.placeholder(action:)\n                    ),\n                    success: DetailPlaceholderView.init(store:)\n                )\n            )\n        }\n        .navigationTitle(store.navigationTitle)\n        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)\n    }\n}\n```\n\nNote that the detail view uses the `ViewStoreWithNonOptionalStateProvider` instead of the default `ViewStoreProvider` since the parent\'s `listState` and `placeholderState` may be `nil`. The `DetailViewStateMapper` decides whether the placeholder or a repository\'s metadata is shown. Hence, the `ViewStoreWithNonOptionalStateProvider` only renders the `DetailListView` in case that the parent\'s `listState` is not `nil`. Otherwise the provider fallbacks to the failure case and renders the provided component in case it exists. Similarly, the `DetailPlaceholderView` is only shown if the parent\'s `placeholderState` is not `nil`. This way, the `ViewStoreWithNonOptionalStateProvider` provides a non-optional state to the child if the parent\'s state is not `nil`. Otherwise, it the `failure` view is rendered.\n\n### Toolbar\n\nThe toolbar provides quick access to the main features of the app. As an example, users can import manifests using the toolbar\'s primary action. Besides, users can toggle the sidebar\'s visibility using the navigation button of the bar. Unfortunately, `NavigationView` does not offer a modifier to specify the sidebar\'s visibility. Instead, we can search for the `SplitViewController` that is the first responder in the key window and toggle its sidebar:\n\n```swift\nimport SwiftUI\n\nstruct ToolbarItems: ToolbarContent {\n    @ObservedObject var store: ViewStore<ToolbarItemsState, ToolbarItemsAction>\n\n    var body: some ToolbarContent {\n        ToolbarItem(placement: .navigation) {\n            Button(\n                action: {\n                    NSApp.keyWindow?.firstResponder?.tryToPerform(\n                        #selector(NSSplitViewController.toggleSidebar(_:)),\n                        with: nil\n                    )\n                },\n                label: {\n                    Image(systemName: store.toggleMenuItemState.imageSystemName)\n                        .foregroundColor(Color(store.toggleMenuItemState.tintColor))\n                }\n            )\n            .help(store.toggleMenuItemState.hint)\n            .disabled(store.toggleMenuItemState.isDisabled)\n        }\n\n        ToolbarItem(placement: .primaryAction) {\n            Button(\n                action: {\n                    FileImporter.openFiles { filePaths in\n                        store.send(.didChooseManifests(filePaths))\n                    }\n                },\n                label: {\n                    Image(systemName: store.chooseManifestsItemState.imageSystemName)\n                        .foregroundColor(Color(store.chooseManifestsItemState.tintColor))\n                }\n            )\n            .help(store.chooseManifestsItemState.hint)\n            .disabled(store.chooseManifestsItemState.isDisabled)\n        }\n        ToolbarItemGroup(placement: .automatic) {\n            Button(\n                action: { store.send(.didTriggerRefresh) },\n                label: {\n                    Image(systemName: store.refreshItemState.imageSystemName)\n                        .foregroundColor(Color(store.refreshItemState.tintColor))\n                }\n            )\n            .disabled(store.refreshItemState.isDisabled)\n            .help(store.refreshItemState.hint)\n            Button(\n                action: {\n                    FileExporter.exportFile { destination in\n                        store.send(.didChooseExportDestination(destination))\n                    }\n                },\n                label: {\n                    Image(systemName: store.exportItemState.imageSystemName)\n                        .foregroundColor(Color(store.exportItemState.tintColor))\n                }\n            )\n            .disabled(store.exportItemState.isDisabled)\n            .help(store.exportItemState.hint)\n        }\n    }\n}\n```\n\nTo prevent unintended behavior while licenses are fetched, we disable the toolbar buttons using the `.disabled()` modifier. Also, the `.help()` modifier attaches a tooltip to each button, providing additional guidance for the user.\n\n### Onboarding\n\nFinally, the `.sheet()` modifier is used to present the `OnboardingView` in case that _Licenses_ is opened for the very first time.\n\n![Onboarding](article_09_03_2021_onboarding.png)\n\nNote that we do not specify an action mapper, since the `SupportedManifestsView` is static and does not include any interaction. Instead, we use the `.withoutActions` property to derive an actionless store from the parent.\n\n```swift\nimport SwiftUI\n\nstruct OnboardingView: View {\n    @ObservedObject var store: ViewStore<OnboardingViewState, OnboardingViewAction>\n\n    var body: some View {\n        VStack(spacing: 16) {\n            VStack(spacing: 0) {\n                Image("icon")\n                    .resizable()\n                    .aspectRatio(contentMode: .fit)\n                    .frame(width: 90, height: 90, alignment: .center)\n                Spacer()\n                    .frame(height: 16)\n                Text(store.title)\n                    .font(.largeTitle)\n                Spacer()\n                    .frame(height: 16)\n                Text(store.subtitle)\n                    .multilineTextAlignment(.center)\n                Spacer()\n                    .frame(height: 16)\n                SupportedManifestsView(\n                    store: store.derived(stateMapper: \\.supportedManifestsState).withoutActions\n                )\n            }\n\n            Spacer()\n\n            Button(store.primaryButtonTitle) {\n                store.send(.didTriggerPrimaryButton)\n            }\n            .buttonStyle(BrandedButtonStyle())\n        }\n        .padding(48)\n        .frame(width: 500, height: 500, alignment: .center)\n    }\n}\n```\n\n# Conclusion\n\nThis article walked you through the steps that I took when building a native Mac app using _SwiftUI 2.0_ and _Combine_ from scratch. This way, I wanted to explore the capabilities of Swift UI and tried to examine whether it can be used in production. Even though a lot of the things that are offered by UIKit, like the `.emphasized` background style of a cell, are still missing, I appreciate the declarative nature of SwiftUI on the Mac. This way, we can avoid spending time on standard components like the master-detail view and rather focus on features that make up the app.\n\nHappy Coding \uD83D\uDE80\n\n# References:\n\n- [LicensePlist](https://github.com/mono0926/LicensePlist) - Masayuki Ono\n- [The Composable Architecture](https://github.com/pointfreeco/swift-composable-architecture) - Point-Free\n- [Redux like state Containers in SwiftUI](https://swiftwithmajid.com/2019/09/18/redux-like-state-container-in-swiftui/) - Swift with Majid\n',title:"Building a native macOS app using SwiftUI and Combine",description:`Have you ever been asked to put together the list of licenses 
            of all frameworks that are used within your iOS, iPad OS, or
            macOS app? Manually completing this task quickly becomes
            tedious but may be required due to legal- or customer
            requests.
    
            To mitigate this issue, I developed Licenses, a native macOS
            app that automates this procedure by collecting and exporting
            your licenses into a single spreadsheet (CSV) file.`}];var l=t(1664),c=t.n(l),d=t(81),u=t.n(d);function ArticleItem(e){let{id:n,title:t,body:o,date:a}=e;return i.createElement("div",{className:u().articleItemContainer},i.createElement("div",{className:u().dateContainer},i.createElement("h3",{className:"timityOrange"},a)),i.createElement(c(),{href:`articles/${n}`},t),o)}var h=t(3839),p=t.n(h);function Articles(){return i.createElement(i.Fragment,null,i.createElement(o.PB,{title:"Articles - Link Andreas",description:"Articles about iOS Development.",canonical:"https://www.linkandreas.de/articles",openGraph:{url:"https://www.linkandreas.de/articles",title:"Articles - Link Andreas",description:"Articles about iOS Development.",images:[],siteName:"Andreas Link"},twitter:{handle:"@handle",site:"@site",cardType:"summary_large_image"}}),i.createElement("div",{className:p().articlesContainer},i.createElement("div",null,s.map((e,n)=>i.createElement(ArticleItem,{key:n,id:e.id,date:new Date(Date.parse(e.date)).toLocaleDateString("en-US",{year:"numeric",month:"long",day:"numeric"}),title:e.title,body:i.createElement("div",null,e.description.split("\n\n").map((e,n)=>i.createElement("p",{key:n},e)))})))))}},245:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles",function(){return t(9588)}])},81:function(e){e.exports={articleItemContainer:"ArticleItem_articleItemContainer__lIgtY",dateContainer:"ArticleItem_dateContainer__GtzqG"}},3839:function(e){e.exports={articlesContainer:"Articles_articlesContainer__URmiE"}},2016:function(e){e.exports=function(e,n){var t=Math.floor(e).toString();for(void 0===n&&(n=2);t.length<n;)t="0"+t;var i=e.toString().split(".")[1];return i?t+"."+i:t}},7631:function(e,n,t){"use strict";var i=t(2016);function getTZOString(e){return(e>0?"-":"+")+i(Math.abs(Math.floor(e/60)),2)+i(Math.abs(e%60),2)}e.exports=function(e){return["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][e.getDay()]+", "+i(e.getDate(),2)+" "+["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"][e.getMonth()]+" "+e.getFullYear()+" "+i(e.getHours(),2)+":"+i(e.getMinutes(),2)+":"+i(e.getSeconds(),2)+" "+getTZOString(e.getTimezoneOffset())},e.exports.getTZOString=getTZOString}},function(e){e.O(0,[774,888,179],function(){return e(e.s=245)}),_N_E=e.O()}]);