{"pageProps":{"article":{"id":"16_03_2022","date":"16th of March 2022","markdown":"![Logo](article_16_03_2022_logo_dark.png)\n\nToday we are going to take a look at how we can deal with asynchronous data in SwiftUI applications. Modern apps heavily rely on resources that are received over the network, and hence may be affected by connectivity issues or data loss. If, for example, you travel by train within Germany, you may be surprised how often you will experience radio gaps or interruptions due to weak cellular reception. Hence, we as developers have to design our apps to include feedback when an action takes longer than expected and offer the ability to retry the action in case that it failed. This way, we can make our apps stand out, since they can cope with conditions that are far from optimal.\n\nThis article introduces the reusable component `AsyncResourceView` that abstracts loading as well as failure states when fetching asynchronous data, such that we can focus on features rather than writing repetitive error-prone code.\n\n![Simple Example](article_16_03_2022_simple_example_tiny_dark.gif)\n\n## View Store\n\nFirst, let's implement the `AsyncResourceViewStore<Resource>` that is responsible for driving the UI. Given the loader, the store initially remains in the `notRequested` state until `loadResource` is called and the `loading` state is entered. Finally, depending on the result of the operation, either the `success` or `failure` state is entered.\n\nNote that the store is independent of SwiftUI and may be used with an alternative UI framework in the future. In addition, we ensure that state changes only occur on the main thread using the `@MainActor` annotation:\n\n```swift\npublic final class AsyncResourceViewStore<Resource>: ObservableObject {\n    public typealias Loader = () async throws -> Resource\n\n    public enum State {\n        case notRequested\n        case loading\n        case success(Resource)\n        case failure(Error)\n    }\n\n    @Published public var state: State\n\n    private var loader: Loader?\n\n    public init(state: State = .notRequested, loader: Loader? = nil) {\n        self.state = state\n        self.loader = loader\n    }\n\n    @MainActor\n    public func loadResource() async {\n        guard let loader = loader else { return }\n\n        state = .loading\n\n        do {\n            let resource = try await loader()\n            state = .success(resource)\n        } catch {\n            state = .failure(error)\n        }\n    }\n}\n```\n\n## Testing\n\nEven though its implementation looks simple, let's include unit tests to ensure that we are free to refactor the store in the future without changing its behavior. \n\nFirst, the store should be in the `notRequested` state. The `makeSUT` helper instantiates the `AsyncResourceViewStore` with a loader stub, such that we have control over its outcome when making assertions about the expected behavior.\n\nSecond, we expect the store to enter the `success` state when the resource loading succeeded. Similarly, we expect the store to enter the `failure` state in case that the resource loading failed.\n\nFinally, we also expect the store to enter the `success` state after the resource loading initially failed but later succeeded. This way, we ensure that the user will have the option to retry the action in case that it failed.\n\n```swift\nfinal class AsyncResourceViewStoreTests: XCTestCase {\n    func test_store_entersNotRequestedStateOnInit() {\n        let (sut, _) = makeSUT()\n\n        expectState(of: sut, toEqual: .notRequested)\n    }\n\n    func test_store_entersSuccessStateWhenResourceLoadingSucceeded() async throws {\n        let anyText = \"any Text\"\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .success(anyText)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .success(anyText))\n    }\n\n    func test_store_entersFailureStateWhenResourceLoadingFailed() async throws {\n        let error = anyNSError()\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .failure(error)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .failure(error))\n    }\n\n    func test_store_entersSuccessStateAfterResourceLoadingInitiallyFailed() async throws {\n        let anyText = \"any Text\"\n        let error = anyNSError()\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .failure(error)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .failure(error))\n\n        loaderStub.loadResult = .success(anyText)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .success(anyText))\n    }\n}\n\nextension AsyncResourceViewStoreTests {\n    typealias SUT = AsyncResourceViewStore<String>\n\n    private func makeSUT(expectedResult: Result<String, Error> = .success(\"\")) -> (SUT, LoaderStub) {\n        let stub = LoaderStub()\n        let sut = SUT(loader: stub.load)\n        return (sut, stub)\n    }\n\n    private func anyNSError() -> NSError {\n        return NSError(domain: \"any domain\", code: 42, userInfo: nil)\n    }\n\n    private func expectState(\n        of sut: SUT,\n        toEqual expectedState: SUT.State,\n        file: StaticString = #filePath,\n        line: UInt = #line\n    ) {\n        switch (sut.state, expectedState) {\n        case (.notRequested, .notRequested), (.loading, .loading), (.success, .success):\n            break\n\n        case let (.failure(receivedError as NSError), .failure(expectedError as NSError)):\n            XCTAssertEqual(receivedError, expectedError, file: file, line: line)\n\n        default:\n            XCTFail(\"State \\(sut.state), does not match \\(expectedState)\", file: file, line: line)\n        }\n    }\n\n    private class LoaderStub {\n        var loadResult: Result<String, Error>!\n\n        func load() async throws -> String {\n            switch loadResult! {\n            case let .success(text):\n                return text\n\n            case let .failure(error):\n                throw error\n            }\n        }\n    }\n}\n```\n\n## View\n\nAs we completed the store, let's continue with the `AsyncResourceView` that renders its children using the state-specific closures. While the `notRequested-`, `failure-` and `loading-` views are optional, we are required to specify the `success` view given the resource. This way, we can break down complexity and only have to deal with a single instead of multiple states at once.\n\n```swift\npublic struct AsyncResourceView<Resource>: View {\n    public typealias ViewStore = AsyncResourceViewStore<Resource>\n    public typealias NotRequestedView = (@escaping () -> Void) -> AnyView\n    public typealias LoadingView = () -> AnyView\n    public typealias FailureView = (Error, @escaping () -> Void) -> AnyView\n    public typealias SuccessView = (Resource) -> AnyView\n\n    @ObservedObject private var store: ViewStore\n\n    private var notRequestedView: NotRequestedView\n    private var loadingView: LoadingView\n    private var failureView: FailureView\n    private var successView: SuccessView\n\n    public init(\n        store: ViewStore,\n        notRequestedView: @escaping NotRequestedView = { AnyView(AsyncResourceDefaultNotRequestedView(load: $0)) },\n        loadingView: @escaping LoadingView = { AnyView(AsyncResourceDefaultLoadingView()) },\n        failureView: @escaping FailureView = { AnyView(AsyncResourceDefaultFailureView(error: $0, retry: $1)) },\n        successView: @escaping SuccessView\n    ) {\n        self.store = store\n        self.notRequestedView = notRequestedView\n        self.loadingView = loadingView\n        self.failureView = failureView\n        self.successView = successView\n    }\n\n    public var body: some View {\n        switch store.state {\n        case .notRequested:\n            return notRequestedView(loadResource)\n\n        case .loading:\n            return loadingView()\n\n        case let .success(resource):\n            return successView(resource)\n\n        case let .failure(error):\n            return failureView(error, loadResource)\n        }\n    }\n\n    private func loadResource() {\n        Task { await store.loadResource() }\n    }\n}\n```\n\n### Default Views\n\n#### AsyncResourceDefaultNotRequestedView\n\nFor example, using the `notRequested` view, we can specify how the UI should look like until the resource is requested. Note that the default representation is not visible and is only used to trigger the callback as soon as it appeared. Instead, one can also think of a visual representation that features a button to let the user decide when the action is run.\n\n```swift\npublic struct AsyncResourceDefaultNotRequestedView: View {\n    private let load: () -> Void\n\n    public init(load: @escaping () -> Void) {\n        self.load = load\n    }\n\n    public var body: some View {\n        Color.clear\n            .onAppear(perform: load)\n    }\n}\n```\n\n#### AsyncResourceDefaultLoadingView\n\nIn contrast, the default `loading` view is visible and will indicate progress until either the *success* or *failure-* state is entered.\n\n```swift\npublic struct AsyncResourceDefaultLoadingView: View {\n    private let title: String\n\n    public init(title: String = \"Loading\") {\n        self.title = title\n    }\n\n    public var body: some View {\n        ProgressView(title)\n    }\n}\n```\n\n#### AsyncResourceDefaultFailureView\n\nFinally, in case no `failure` closure exists, the `AsyncResourceDefaultFailureView` renders a counterclockwise arrow to retry the action in case that it failed. Note that custom views may also consider the error to provide additional information about why the action did not work as intended.\n\n![Default Failure View](article_16_03_2022_default_failure_view.png)\n\n```swift\npublic struct AsyncResourceDefaultFailureView: View {\n    private let error: Error\n    private let retry: () -> Void\n\n    public init(error: Error, retry: @escaping () -> Void) {\n        self.error = error\n        self.retry = retry\n    }\n\n    public var body: some View {\n        VStack(spacing: 16) {\n            Button(action: retry) {\n                Image(systemName: \"arrow.counterclockwise\")\n                    .font(.system(size: 25))\n                    .tint(.accentColor)\n            }\n        }\n    }\n}\n```\n\n## Previews\n\nUndoubtedly, one of the great advantages of SwiftUI over UI Kit is that we can get real-time feedback about how the rendering is composed. This is especially true when dealing with interactive previews that offer great insights into the look and feel of a component. Subsequently, you can find examples for a static as well as interactive preview:\n\n```swift\nstruct AsyncResourceView_Previews: PreviewProvider {\n    static var previews: some View {\n        NavigationView {\n            AsyncResourceView(\n                store: AsyncResourceViewStore(state: .success(\"Hello World\")),\n                successView: { text in\n                    AnyView(Text(text))\n                }\n            )\n            .navigationTitle(\"Static Preview\")\n        }\n\n        NavigationView {\n            AsyncResourceView(\n                store: AsyncResourceViewStore(loader: loader),\n                notRequestedView: { load in\n                    AnyView(\n                        Button(\"Load Resource\", action: load)\n                            .buttonStyle(.borderedProminent)\n                    )\n                },\n                successView: { text in\n                    AnyView(Text(text))\n                }\n            )\n            .navigationTitle(\"Interactive Preview\")\n        }\n    }\n}\n\nprivate let loader: () async throws -> String = {\n    try await Task.sleep(nanoseconds: 2_000_000_000)\n\n    if Bool.random() {\n        return \"Hello World\"\n    } else {\n        throw NSError(domain: \"any domain\", code: 42, userInfo: nil)\n    }\n}\n```\n\nWhile the static preview renders itself based on the predefined state of the store, the interactive preview explicitly communicates with the loader and waits until the result is made. Since, the loader may fail, we throw a dice and either return the resource (i.e., â€œHello Worldâ€) or an error. The latter will result in the failure state, where we can retry the action without leaving the preview.\n\n## Use Case Example: \"Color Gallery\"\n\n![Gallery Example](article_16_03_2022_gallery_example_dark_optimized.gif)\n\nTo visualize how the component is used, let's implement a color gallery where items are arranged in a three-column grid. Each item features the `AsyncResourceView` to request its color from the loader that will either return a random color or fail after [0.3, 3.0] seconds. As stated above, a retry button is shown in case the action failed. \n\n```swift\n@main\nstruct AsyncResourceGalleryApp: App {\n    @StateObject\n    private var store: GalleryStore = .init()\n\n    var body: some Scene {\n        WindowGroup {\n            GalleryView(\n                store: store,\n                itemView: { item -> AnyView in\n                    let store = AsyncResourceViewStore<Color>(loader: loader(item))\n                    return AnyView(GalleryItemView(store: store))\n                }\n            )\n            .onAppear(perform: store.onAppear)\n        }\n    }\n}\n\nextension AsyncResourceGalleryApp {\n    private func loader(_ item: GalleryItem) -> (() async throws -> Color) {\n        return {\n            let duration = UInt64.random(in: 300_000_000 ... 3_000_000_000)\n            try await Task.sleep(nanoseconds: duration)\n            if Int.random(in: 0...5) == 4 {\n                throw NSError(domain: \"\", code: 42, userInfo: nil)\n            } else {\n                return item.color\n            }\n        }\n    }\n}\n```\n\nSince we do not specify a custom `notRequested` view, the default view is used that requests the resource as soon as it appeared. By wrapping the items in SwiftUI's `LazyVGrid` they are only created when needed.\n\n```swift\nstruct GalleryView: View {\n    private var store: GalleryStore\n    private let columns: [GridItem] = [\n        GridItem(.flexible(minimum: 50), spacing: 50),\n        GridItem(.flexible(minimum: 50), spacing: 50),\n        GridItem(.flexible(minimum: 50), spacing: 50)\n    ]\n    private let itemView: (GalleryItem) -> AnyView\n\n    init(store: GalleryStore, itemView: @escaping (GalleryItem) -> AnyView) {\n        self.store = store\n        self.itemView = itemView\n    }\n\n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: columns, spacing: 50) {\n                ForEach(store.items, id: \\.self) { item in\n                    itemView(item)\n                        .frame(width: 100, height: 100)\n                }\n            }\n            .padding()\n        }\n    }\n}\n```\n\nEach of the items is driven by its own store, i.e., `AsyncResourceViewStore` that transitions between states depending on how long the action takes.\n\n```swift\nstruct GalleryItemView: View {\n    private let store: AsyncResourceViewStore<Color>\n\n    init(store: AsyncResourceViewStore<Color>) {\n        self.store = store\n    }\n\n    var body: some View {\n        AsyncResourceView(store: store) { color in\n            AnyView(color)\n        }\n    }\n}\n```\n\nFinally, we create a `GalleryStore` that drives the composition and provides a color for each individual loader.\n\n```swift\nfinal class GalleryStore: ObservableObject {\n    @Published var items: [GalleryItem] = []\n\n    func onAppear() {\n        items = (0 ..< 100)\n            .map { _ in Color.random }\n            .map { GalleryItem(color: $0 )}\n    }\n}\n\nstruct GalleryItem: Hashable {\n    let id: UUID\n    let color: Color\n\n    init(id: UUID = .init(), color: Color) {\n        self.id = id\n        self.color = color\n    }\n}\n```\n\n# Conclusion\n\nIn this article, I presented the `AsyncResourceView`, a consistent way to deal with asynchronous resources in SwiftUI applications. Using the component, we can avoid repetitive code and spend more time on implementing features rather than writing the same loading- or error handling code throughout the App. You can checkout the project on GitHub ([Link](https://github.com/LinkAndreas/AsyncResourceView)). \n\nHappy Coding ðŸš€\n\n\n\n\n","title":"AsyncResourceView: Simplified Resource Loading","description":"Modern apps heavily rely on resources that are received\n            over the network, and hence may be affected by connectivity issues\n            or data loss. If, for example, you travel by train within Germany,\n            you may be surprised how often you will experience radio gaps or\n            interruptions due to weak cellular reception. Hence, we as developers\n            have to design our apps to include feedback when an action takes longer\n            than expected and offer the ability to retry the action in case that\n            it failed. This way, we can make our apps stand out, since they can\n            cope with conditions that are far from optimal.\n    \n            AsyncResourceView offers a consistent way to deal with loading as well as\n            error states in SwiftUI applications. This way, developers can focus on\n            features rather than writing repetitive error-prone code."}},"__N_SSG":true}