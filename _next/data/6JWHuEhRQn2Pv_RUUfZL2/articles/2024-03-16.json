{"pageProps":{"article":{"id":"2024-03-16","date":"Sat, 16 Mar 2024 00:00:00 +0000","markdown":"# Networking for Large-Scale iOS Applications\n\nNetworking serves as the backbone of mobile applications, facilitating seamless communication and enabling rich user experiences. However, it also introduces complexity, especially when dealing with modular applications that are built from independent features. \n\nModularity offers many benefits, such as a faster development cycle and better scalability. But it also requires a robust approach to handle cross-cutting concerns among features. Since networking is a cross-cutting concern, it cannot be easily encapsulated in any of them. \n\nIn this article, we explore a lightweight approach for dealing with networking in modular iOS applications.\n\n## Naive Approach\n\nFirst, let's take a look at the naive approach, where multiple independent features directly depend on the networking package.\n\n![Naive Approach](article_18_02_2024_naive_approach.svg)\n\nEven though the latter encapsulates the ability to communicate over the network, it adds up to the total build time of each feature, since compiling the feature requires compilation of the entire network package as well. Especially when working in feature teams, it is desirable to minimize the amount of direct dependencies so that we can benefit from shorter build times and a fast feedback loop.\n\n## Lightweight Approach in modular Applications\n\nTo ensure that we do not need to compile the network-related code when working on a feature, we introduce a lightweight abstraction called `HTTPClient` that is exposed to every feature but does not contain a concrete implementation.\n\n```swift\n/// Abstraction for executing HTTP network requests.\npublic protocol HTTPClient {\n    /// Executes the given request and returns the received data and response including the StatusCode.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The received data and response (including the StatusCode).\n    @discardableResult\n    func load(request: HTTPRequest) async throws -> (Data, HTTPResponse)\n}\n```\n\nThe abstraction only consists of the `load(request:)` method, that given an `HTTPRequest` returns the received data along with the `HTTPResponse`. The `HTTPRequest` contains all information necessary to perform the request, like the `method`, `path`, `headers` and `queryParameters`. In addition, the `body` parameter is used to specify the content that is transmitted with the request.\n\n```swift\n/// Abstraction describing an HTTP network request.\npublic protocol HTTPRequest {\n    /// The HTTP method of the request.\n    var method: HTTPMethod { get }\n    /// The path of the request endpoint.\n    var path: HTTPPath { get }\n    /// The endpoint version of the request.\n    var version: HTTPVersion { get }\n    /// The headers to be transmitted with the request.\n    var headers: HTTPHeaders? { get }\n    /// The query parameters to be transmitted with the request.\n    var queryParameter: HTTPQueryParameter? { get }\n    /// The content to be transmitted with the request.\n    var body: Data? { get }\n}\n```\n\nSome parameters are declared *optional* since they may not be necessary for every request. Hence, developers have the flexibility to omit these parameters, streamlining the implementation and improving code readability.\n\n```swift\nextension HTTPRequest {\n    public var headers: HTTPHeaders? { nil }\n    public var queryParameter: HTTPQueryParameter? { nil }\n    public var body: Data? { nil }\n}\n```\n\nLet's briefly go through the meaning of each of the parameters.\n\nFirst, the `HTTPMethod` enumeration corresponds to the methods permitted for HTTP requests. Alongside `GET` for data retrieval, it also includes `POST` for creating a resource, as well as `PUT` and `PATCH` for updating the resource, and `DELETE` for removing it when no longer needed.\n\n```swift\n/// The HTTP method of the network request.\npublic enum HTTPMethod: String, Equatable {\n    case get = \"GET\"\n    case post = \"POST\"\n    case put = \"PUT\"\n    case patch = \"PATCH\"\n    case delete = \"DELETE\"\n}\n\nextension HTTPMethod {\n    public var name: String {\n        rawValue\n    }\n}\n```\n\nNext, the `HTTPPath` in conjunction with the `HTTPVersion` specifies the endpoint targeted by the request. Both are defined as type aliases of `String` to better derive a semantic meaning when looking at the type itself.\n\n```swift\n/// The path of the network request.\npublic typealias HTTPPath = String\n/// The version of the HTTP endpoint.\npublic typealias HTTPVersion = String\n```\n\nNext, `HTTPHeader` defines standard headers that are included in most requests. For instance, the `contentType` attribute specifies the type of content being transmitted in the request body.\n\n```swift\n/// Standard headers that can be transmitted in requests to the backend.\npublic enum HTTPHeader: String {\n    /// The data format accepted by the client (e.g., `application/json`).\n    case accept = \"Accept\"\n    /// The type of content being sent in the body (e.g., `application/json`).\n    case contentType = \"Content-Type\"\n}\n```\n\nFinally, similar to `HTTPPath`, both `HTTPHeaders` and `HTTPQueryParameter` utilize type aliases to give meaning to the underlying `String` key-value pairs.\n\n```swift\n/// Dictionary of headers sent or received as key-value pairs in network requests.\npublic typealias HTTPHeaders = [String: String]\n/// Key-value pairs transmitted as query parameters in network requests.\npublic typealias HTTPQueryParameter = [String: String]\n```\n\nHaving referred to the properties of an `HTTPRequest`, let's now shift our focus to the `HTTPResponse` that is received upon successful execution of `load(request:)`.\n\n```swift\n/// Contains the response to a network request.\npublic struct HTTPResponse {\n    /// The StatusCode of the response.\n    public let statusCode: HTTPStatusCode\n    /// The headers of the response.\n    public let headers: HTTPHeaders?\n\n    /// Initializes a `HTTPResponse` for a given StatusCode and Header.\n    /// - Parameters:\n    ///   - statusCode: The StatusCode of the response.\n    ///   - headers: The headers of the response.\n    public init(statusCode: HTTPStatusCode, headers: HTTPHeaders? = nil) {\n        self.statusCode = statusCode\n        self.headers = headers\n    }\n}\n\n/// The StatusCode contained in a response to a network request.\npublic typealias HTTPStatusCode = Int\n```\n\nIn contrast to the request, the `HTTPResponse` only comprises two properties: the `statusCode` and `headers`. While the status code communicates the outcome of the request, the `headers` are optional and enable the server to provide supplementary information to the client alongside the response.\n\nFurthermore, extensions are implemented to streamline the determination of the response's nature, categorizing it into types such as `informational`, `successful`, `redirection`, `client error`, or `server error`. This eliminates the need to memorize status code ranges.\n\n```swift\nextension HTTPResponse {\n    /// Status indicating whether it is an informational response.\n    /// - seealso: For more information, see [mdm web docs - Information responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#information_responses)\n    public var isInformational: Bool {\n        (100 ..< 200).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a successful response.\n    /// - seealso: For more information, see [mdm web docs - Successful responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses)\n    public var isSuccess: Bool {\n        (200 ..< 300).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a redirection response.\n    /// - seealso: For more information, see [mdm web docs - Redirection messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages)\n    public var isRedirectional: Bool {\n        (300 ..< 400).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a client error response.\n    /// - seealso: For more information, see [mdm web docs - Client error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n    public var isClientError: Bool {\n        (400 ..< 500).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a server error response.\n    /// - seealso: For more information, see [mdm web docs - Server error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n    public var isServerError: Bool {\n        (500 ..< 600).contains(statusCode)\n    }\n\n    /// Status indicating whether it is an error response.\n    public var isError: Bool {\n        (400 ..< 600).contains(statusCode)\n    }\n}\n```\n\nAs a result, relying solely on the `HTTPClient` abstraction has a negligible impact on the feature's build time. Moreover, the feature avoids dealing with 3rd party dependencies like `Moya`, `Alamofire` or Apple's `URLSession`. Instead, it only uses the abstraction to communicate over the network and assumes that a concrete implementation will be provided by another entity. This assumption is key for decoupling features from cross-cutting concerns and developing them in isolation.\n\n![Architecture](article_18_02_2024_feature_abstraction.svg)\n\n## Infrastructure: \"URLSessionInfrastructure\"\n\nStill, when integrating the feature, we need to ensure that its requirements are fulfilled by a concrete implementation. The latter is provided by infrastructure modules that may use a third-party library to achieve the intended result. For instance, the `URLSessionInfrastructure` package may use Apple's `URLSession` to execute the request.\n\n![Architecture](article_18_02_2024_feature_abstraction_infrastructure.svg)\n\nIn this manner, only the infrastructure package directly relies on third-party frameworks, such that each feature stays agnostic from infrastructure details. Below you can find an example implementation of the `URLSessionClient`:\n\n```swift\nimport Foundation\n\npublic final class URLSessionClient: HTTPClient {\n    enum Error: Swift.Error {\n        case noHttpURLResponse\n        case invalidHeaderArguments\n    }\n\n    private let baseURL: URL\n    private let session: URLSession\n\n    public init(baseURL: URL, session: URLSession = .shared) {\n        self.baseURL = baseURL\n        self.session = session\n    }\n\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        let url = baseURL\n            .appending(path: request.version)\n            .appending(path: request.path)\n\n        var urlRequest = URLRequest(url: url)\n        urlRequest.httpMethod = request.method.name\n        urlRequest.httpBody = request.body\n        urlRequest.allHTTPHeaderFields = request.headers\n        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)\n        components?.queryItems = request.queryParameter?.reduce(into: [URLQueryItem]()) { current, next in\n            let item = URLQueryItem(name: next.key, value: next.value)\n            current.append(item)\n        }\n\n        let (data, response) = try await session.data(for: urlRequest)\n\n        guard let httpURLResponse = response as? HTTPURLResponse else {\n            throw Error.noHttpURLResponse\n        }\n\n        guard let headers = httpURLResponse.allHeaderFields as? [String: String] else {\n            throw Error.invalidHeaderArguments\n        }\n\n        let HttpResponse = HTTPResponse(statusCode: httpURLResponse.statusCode, headers: headers)\n        return (data, HttpResponse)\n    }\n}\n```\n\nFirst, the `load(request:)` method constructs a `URLRequest` along with its query items based on the information given in the `HTTPRequest`. It's important to note that `URLRequest` is considered an infrastructure detail, as it's provided by Apple's `URLSession`. Second, the `session` is used to execute the request and wait for the reception of a response. Finally, the received response is interpreted as an `HTTPURLResponse` from which `headers` and `statusCode` are extracted.\n\nBy separating the feature from infrastructure details, we can integrate all components within the *composition root*. The latter serves as the translation layer between modules without requiring them to have knowledge of each other. This way, features can be developed in isolation by different feature teams, which is essential for large-scale modular applications.\n\n![Architecture](article_18_02_2024_architecture.svg)\n\n## Adding Functionality: Decorators\n\nEspecially within large-scale applications, we frequently encounter new or evolving business requirements, such as *logging* or *authentication*. Instead of modifying the infrastructure module, we can utilize the decorator pattern to add functionality without altering the underlying implementation. Consider the `AuthenticatedHTTPClient` as an illustration: it provides the same interface as the `HTTPClient`, yet it injects a Bearer token with every request. Through this approach, decorations are linked together until the desired behavior is achieved.\n\n![Decorators](article_18_02_2024_decorators.svg)\n\nLet's take a moment to highlight four decorations of the `HTTPClient` to deal with *authentication*, *error handling*, *header injection* as well as *logging*\n\n### Authentication\n\nFirst, let's start by taking a look at how we can add *authentication* to an existing `HTTPClient`. Given the client, as well as a closure that returns an access token, the `AuthenticatedHTTPClient` injects the token as an `Authentication` header into every request. Note that the closure providing the token is asynchronous and may return an error when the token retrieval fails. In case, no token could be retrieved, the client throws the `missingAccessToken` error.\n\n```swift\n/// A `HTTPClient` decorator that extends requests to a client with an authentication token.\npublic class AuthenticatedHTTPClient: HTTPClient {\n    enum Error: Swift.Error {\n        /// Error if no AccessToken exists.\n        case missingAccessToken\n    }\n\n    private let client: HTTPClient\n    private let accessToken: () async throws -> String\n\n    /// Decorates requests to a `HTTPClient` with the authentication token.\n    /// - Parameters:\n    ///   - client: The `HTTPClient` to be decorated.\n    ///   - accessToken: A closure providing the AccessToken.\n    public init(client: HTTPClient, accessToken: @escaping () async throws -> String) {\n        self.client = client\n        self.accessToken = accessToken\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        var modifiedRequest = ModifiedRequest(request)\n        var headers = modifiedRequest.headers ?? [:]\n\n        do {\n            headers[\"Authorization\"] = try await accessToken()\n        } catch {\n            throw Error.missingAccessToken\n        }\n\n        modifiedRequest.headers = headers\n        return try await client.load(request: modifiedRequest)\n    }\n}\n```\n\nThe following extension allows to easily chain the `AuthenticatedHttpClient` with an existing client:\n\n```swift\nextension HTTPClient {\n    /// Extends requests to a `HTTPClient` with the authentication token.\n    /// - Returns: The `HTTPClient` extended with the authentication token.\n    public func authenticated(accessToken: @escaping () async throws -> String) -> HTTPClient {\n        AuthenticatedHTTPClient(client: self, accessToken: accessToken)\n    }\n}\n```\n\nThen, an existing client is augmented by calling `.authenticated` with a closure providing the access token.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .authenticated(\n        accessToken: {\n            try await Task.sleep(nanoseconds: 1_000_000)\n            return \"Bearer <Token>\"\n        }\n    )\n```\n\nNote that the access token retrieval is asynchronous because the token may expire. If the token becomes invalid, the client can request a new token using the refresh token from the authentication server.\n\n### Error Handling\n\nLike `authentication`, we can introduce an additional decorator that handles errors for responses with status codes outside `200..<300` by default. However, this does not prevent us from handling the error on the call side. Rather, handlers can be chained to deal with the error suitably, thanks to their composable nature.\n\n```swift\n/// Error type encompassing errors that may occur during the execution of network requests.\npublic enum HTTPError: Error, Equatable {\n    /// Error for responses to network requests containing a StatusCode not within `200..<300`.\n    case httpCode(statusCode: HTTPStatusCode, data: Data)\n}\n```\n\nThe `ErrorHandlingHTTPClient` examines the response status code and throws an `HTTPError.httpCode(statusCode:data:)` error if it falls outside the expected range. This simplifies error handling for the client. Within the feature, where we have a better understanding of the error, we can provide more specific details on how to handle it.\n\n```swift\n/// A `HTTPClient` decorator implementing error handling for standard errors.\npublic class ErrorHandlingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n\n    /// Decorates a HTTPClient with standard error handling.\n    /// - Parameter client: The client to be decorated.\n    public init(client: HTTPClient) {\n        self.client = client\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        let (data, response) = try await client.load(request: request)\n\n        if !(200 ..< 300).contains(response.statusCode) {\n            throw HTTPError.httpCode(statusCode: response.statusCode, data: data)\n        } else {\n            return (data, response)\n        }\n    }\n}\n\nextension HTTPClient {\n    /// Decorates a `HTTPClient` with standard error handling.\n    /// - Returns: The `HTTPClient` extended with standard error handling.\n    public func handlingErrors() -> HTTPClient {\n        ErrorHandlingHTTPClient(client: self)\n    }\n}\n```\n\nSimilar to the previous extensions, default error handling is added by calling `handlingErrors()` on an existing client.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .handlingErrors()\n```\n\n### Header Injection\n\nNow, we will discuss the `HeadersInjectingHTTPClient`. This client enables the injection of custom headers into the request.\n\n```swift\n/// A `HTTPClient` decorator that extends requests with additional HTTP headers.\npublic class HeadersInjectingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n    private let headers: HTTPHeaders\n\n    /// Decorates requests to a HTTPClient with additional headers.\n    /// - Parameter client: The client to be decorated.\n    /// - Parameter headers: The additional headers to be added to requests to the client.\n    /// > Warning: Identically named headers that already exist will be overwritten.\n    public init(client: HTTPClient, headers: HTTPHeaders) {\n        self.client = client\n        self.headers = headers\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        var modifiedRequest = ModifiedRequest(request)\n        var headers = modifiedRequest.headers ?? [:]\n        self.headers.forEach { header in\n            headers[header.key] = header.value\n        }\n        modifiedRequest.headers = headers\n        return try await client.load(request: modifiedRequest)\n    }\n}\n\nextension HTTPClient {\n    /// Decorates requests to a `HTTPClient` with additional headers.\n    /// - Returns: The `HTTPClient` extended with the additional headers.\n    public func injecting(headers: HTTPHeaders) -> HTTPClient {\n        HeadersInjectingHTTPClient(client: self, headers: headers)\n    }\n}\n```\n\nCustom headers are frequently utilized to provide additional information about the client, such as its version or the operating system on which the application is running. Additionally, the client may need to specify the desired data format for the response. In both of these cases, the required information can be injected by calling the `injecting(headers:)` extension on an existing client.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .injecting(\n        headers: [\n            \"header1\": \"value1\",\n            \"header2\": \"value2\",\n            \"header3\": \"value3\"\n        ]\n    )\n```\n\n### Logging Request and Responses\n\nFinally, we will discuss how to handle logging with the `LoggingHTTPClient`. Similar to the previous decorators, this client follows the `HTTPClient` protocol and describes the request and response after the call. Please note that we utilized `print` statements for the sake of simplicity. In a production-level application, a dedicated logger with an appropriate queuing mechanism would be used to ensure that events are logged in the order in which they occur.\n\n```swift\n/// A `HTTPClient` decorator that logs requests.\npublic class LoggingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n\n    /// Logs requests to a HTTPClient\n    /// - Parameter client: The client to be decorated.\n    public init(client: HTTPClient) {\n        self.client = client\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -> (Data, HTTPResponse) {\n        print(describe(request: request))\n        let (data, response) = try await client.load(request: request)\n        print(describe(response: response, data: data))\n        return (data, response)\n    }\n}\n```\n\nBelow, you can find utility functions that prepare the request and response in a human-readable format. This allows developers to quickly verify whether the request was successful or if the server responded with the expected status code. To enhance the implementation, consider storing the log on disk or exporting it for further investigation.\n\n```swift\nextension LoggingHTTPClient {\n    private func describe(request: HTTPRequest) -> String {\n        [\n            \"Outgoing Network Request ‚¨ÜÔ∏è:\",\n            \"-------------------------------\",\n            \"Method: \\(request.method.name)\",\n            \"Path: \\(request.path)\",\n            \"Version: \\(request.version)\",\n            request.headers.map { \"Headers:\\n\\(describe(dict: $0))\" },\n            request.queryParameter.map { \"Query-Parameter: \\(String(describing: $0))\" },\n            request.body.map { \"Body:\\n\\(describe(data: $0))\" },\n        ]\n        .compactMap { $0 }\n        .joined(separator: \"\\n\")\n    }\n\n    private func describe(response: HTTPResponse, data: Data) -> String {\n        [\n            \"Incoming Network Response ‚¨áÔ∏è:\",\n            \"------------------------------------------\",\n            \"\\(describe(response: response))\",\n            \"Body:\",\n            \"\\(describe(data: data))\",\n        ]\n        .joined(separator: \"\\n\")\n    }\n\n    private func describe(response: HTTPResponse) -> String {\n        [\n            \"StatusCode: \\(response.statusCode)\",\n            response.headers.map { \"Headers:\\n\\(describe(dict: $0))\" },\n        ]\n        .compactMap { $0 }\n        .joined(separator: \"\\n\")\n    }\n\n    private func describe(data: Data) -> String {\n        guard\n            let object = try? JSONSerialization.jsonObject(with: data, options: []),\n            let data = try? JSONSerialization.data(withJSONObject: object, options: [.prettyPrinted]),\n            let value = NSString(data: data, encoding: String.Encoding.utf8.rawValue) \n        else {\n            return String(data: data, encoding: .utf8) ?? \"\"\n        }\n        \n        return String(value)\n    }\n\n    private func describe(dict: [String: String]) -> String {\n        \"\\(dict.reduce(\"\") { $0 + \"    - \\($1.key): \\($1.value)\\n\" })\"\n    }\n}\n```\n\nUsing the following extension, we can activate logging for all network requests:\n\n```swift\nextension HTTPClient {\n    /// Logs requests to a `HTTPClient`\n    /// - Returns: The `HTTPClient` extended with request logging.\n    public func loggingRequestAndResponse() -> HTTPClient {\n        LoggingHTTPClient(client: self)\n    }\n}\n\nURLSessionClient(baseURL: baseURL, session: session)\n    .loggingRequestAndResponse()\n```\n\nHere is an example of a human-readable printout of a request/response pair. The log clearly breaks down the outgoing request, including its `method`, `path`, `version`, and `headers`. The incoming response is also detailed, including its status code, headers, and body content.\n\n```\nOutgoing Network Request ‚¨ÜÔ∏è:\n-------------------------------\nMethod: GET\nPath: token\nVersion: v1\nHeaders:\n    - Authorization: Bearer <Token>\n    - header1: value1\n    - header2: value2\n    - header3: value3\n\nIncoming Network Response ‚¨áÔ∏è:\n------------------------------------------\nStatusCode: 200\nHeaders:\n    - Content-Type: application/json; charset=utf-8\n    - Connection: keep-alive\n    - Date: Sun, 11 Feb 2024 09:48:46 GMT\n    - Keep-Alive: timeout=5\n    - Content-Length: 5\n\nBody:\ntoken\n```\n\n### Usage Example: Token API\n\nThe `HTTPClient` protocol is a suitable abstraction for making features agnostic of infrastructure details. Decorators allow for the dynamic addition of functionality without having to adapt the underlying implementation. Let's examine a usage example to see how these components interact.\n\nConsider a simple REST API (`TokenAPI`) that enables users to retrieve and update a token. While the `token` endpoint does not require a request body, the `update` endpoint expects the new token to be stored on the server.\n\n```swift\nenum TokenAPI: HTTPRequest {\n    case token\n    case update(token: String)\n    \n    var method: HTTPMethod {\n        switch self {\n        case .token:\n            return .get\n        case .update:\n            return .post\n        }\n    }\n    \n    var path: HTTPPath {\n        return \"token\"\n    }\n    \n    var version: HTTPVersion {\n        return \"v1\"\n    }\n    \n    var body: Data? {\n        switch self {\n        case let .update(token):\n            return token.data(using: .utf8)\n        default:\n            return nil\n        }\n    }\n}\n```\n\nAdditionally, we define the `TokenMapper` to translate the received data and `HTTPResponse` into a token. Please note that the mapping may fail if invalid data is received.\n\n```swift\nenum TokenMapper {\n    enum Error: Swift.Error {\n        case invalidData\n    }\n\n    static func map(data: Data, response: HTTPResponse) throws -> String {\n        guard\n            response.isSuccess,\n            let token = String(data: data, encoding: .utf8)\n        else {\n            throw Error.invalidData\n        }\n        \n        return token\n    }\n}\n```\n\nNext, we instantiate a concrete `HTTPClient` to perform the request. In this case, we decided to use Apple's `URLSession` by using the `URLSessionClient` with an `ephemeral` session and a request timeout interval of 30 seconds.\n\n```swift\nenum HTTPClientFactory {\n    static func make(_ baseUrl: String) -> HTTPClient {\n        let baseURL: URL = URL(string: baseUrl)!\n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.timeoutIntervalForRequest = 30.0\n        let session: URLSession = URLSession(configuration: configuration)\n        return URLSessionClient(baseURL: baseURL, session: session)\n    }\n}\n```\n\nBy utilizing the extensions, we can include `logging` and `authentication`, as well as the necessary `headers` to execute the request. It is important to note that the order in which the extensions are applied is significant, as it determines the sequence in which the decorations are applied.\n\n```swift\nenum HTTPClientFactory {\n    static func make(_ baseUrl: String) -> HTTPClient {\n        let baseURL: URL = URL(string: baseUrl)!\n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.timeoutIntervalForRequest = 30.0\n        let session: URLSession = URLSession(configuration: configuration)\n        return URLSessionClient(baseURL: baseURL, session: session)\n            .loggingRequestAndResponse()\n            .injecting(\n                headers: [\n                    \"header1\": \"value1\",\n                    \"header2\": \"value2\",\n                    \"header3\": \"value3\"\n                ]\n            )\n            .authenticated(\n                accessToken: {\n                    try await Task.sleep(nanoseconds: 1_000_000)\n                    return \"Bearer <Token>\"\n                }\n            )\n    }\n}\n```\n\nThe `ContentView` requires a token to be retrieved through the `loadToken` closure provided in its initializer. This approach ensures that the UI is not dependent on the specific `HTTPClient` used to execute the request. By using SwiftUI's `task` modifier, the request is automatically made when the content is loaded on screen.\n\n```swift\nstruct ContentView: View {\n    @State private var token: String?\n    \n    private let loadToken: () async throws -> String\n    \n    init(loadToken: @escaping () async throws -> String) {\n        self.loadToken = loadToken\n    }\n\n    var body: some View {\n        NavigationStack {\n            Text(token ?? \"\")\n                .navigationTitle(\"Networking\")\n                .task { token = try? await loadToken() }\n        }\n    }\n}\n```\n\nThe UI and `httpClient` are connected in the `composition root`. This layer translates the view's request and passes it to the `httpClient`. The response is then mapped using the `TokenMapper` to match the signature of the `loadToken` method.\n\n```swift\n@main\nstruct NetworkingApp: App {\n    private let httpClient: HTTPClient = HTTPClientFactory.make(\"http://localhost:3000/\")\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView(loadToken: httpClient.loadToken)\n        }\n    }\n}\n\nprivate extension HTTPClient {\n    func loadToken() async throws -> String {\n        let (data, response) = try await self.load(request: TokenAPI.token)\n        return try TokenMapper.map(data: data, response: response)\n    }\n}\n```\n\n# Conclusion\n\nIn this article, we introduced a lightweight approach to dealing with cross-cutting concerns like networking in modular iOS applications. By following the principles outlined here, developers can keep features agnostic of infrastructure details and benefit from a faster development cycle and the scalability of their modular iOS applications.\n\n# References:\n\n- [The URL loading system](https://developer.apple.com/documentation/foundation/url_loading_system) - Apple\n- [Composition Root](https://blog.ploeh.dk/2011/07/28/CompositionRoot/) - Mark Seemann\n\nHappy Coding üöÄ","title":"Networking for Large-Scale iOS Applications","description":"Networking serves as the backbone of mobile applications, \n            facilitating seamless communication and enabling rich user experiences. \n            However, it also introduces complexity, especially when dealing with \n            modular applications that are built from independent features.\n            Modularity offers many benefits, such as a faster development cycle \n            and better scalability. But it also requires a robust approach to handle \n            cross-cutting concerns among features. Since networking is a \n            cross-cutting concern, it cannot be easily encapsulated in any of them.\n            In this article, we explore a lightweight approach for dealing with \n            networking in modular iOS applications."}},"__N_SSG":true}