{"pageProps":{"article":{"id":"2025-04-25","date":"Fri, 25 Apr 2025 00:00:00 +0000","markdown":"# Mono-Repo Migration: Boosting Developer Productivity While Keeping Git History Intact\n\nLarge software projects require modular codebases to ensure scalability and maintainability of the application. As a result, we can deal with an increased number of customer requests and deliver features on tight schedules.\n\nWhile modularization is a powerful tool, it may also have a negative impact on developer productivity. This is the case when the application is structured in packages managed in different repositories. Then the overhead caused by managing multiple pull requests becomes significant, when features require changes in the main project as well as other in-house dependencies.\n\nIn this article, we discuss how we can overcome these issues by transitioning to a Mono-Repo and demonstrate a python script to automate a Mono-Repo migration.\n\n## Advantages of a Monorepo for Projects with Multiple In-House Dependencies\n\nWhen changes often affect the project as well as its in-house dependencies, a Mono-Repo may be preferred. Developers can include changes in a single pull request and gain a better understanding of the changes required among packages, hence leading to better cross-team awareness.\n\nAs an example, consider the following approaches:\n\n![Scenarios](article_25_04_2025_scenario.png)\n\nWhile three pull requests are necessary to apply changes to the main project as well as its dependencies when using a *Multi-Repo*, the *Mono-Repo* only requires a single pull request.\n\nEven though git operations may become slower, using a Mono-Repo pays off when additional constraints like `Stale Approval dismissal` are in place.\n\nSince a Mono-Repo migration has a significant impact on the entire code base, the transition needs to be well thought through; ideally automated using a script. With the latter we can run the migration locally without affecting any remote repository. In addition, changes are reviewed via pull-requests before they are integrated into the `main` and `develop` branch.\n\nLet's briefly discuss the overall concept of how to approach a Mono-Repo migration.\n\n## Concept\n\nFor demonstration purposes, we consider a `Main` repository, which depends on two in-house repositories: `Dependency 1` and `Dependency 2`. All repositories follow  Git Flow, using `main` and `develop` as their primary branches. Feature branches are created from `develop` and merged back into it upon completion.\n\n![Context](article_25_04_2025_context.png)\n\nThe goal is to consolidate the Git history of all three repositories into the `Main` repository. This is made possible by Gitâ€™s ability to merge branches from unrelated hierarchies. By adding each dependency as a remote, we can directly merge their key branches (such as `main` and `develop`) into the corresponding branches of the `Main` repository.\n\nBefore merging, a *preparation step* is required to minimize potential conflicts. This involves:\n- Removing redundant or duplicate files common across repositories (e.g., `.gitignore`), keeping only those from the `Main` repository.\n- Restructuring the folder layout of each dependency to prevent file path collisions.\n- Migrating and renaming existing tags from the dependencies by prefixing them with the respective project names to retain traceability.\n\nAs soon as dependencies are prepared we merge their respective `main` branch into `develop` to avoid merge-conflicts after all repos have been merged to the `Main` repository. Otherwise, conflicts will arise after the integration when we try to merge `main` into `develop`.\n\n![Context](article_25_04_2025_preparation.png)\n\nNext, the *preparation branches* are merged into dedicated *integration branches*, from which pull requests are created to review the changes introduced during the mono-repo transition. Maintaining the full Git history of each dependency is essential for traceability. This is accomplished by using the `--allow-unrelated-histories` flag during the merge process. The migration concludes with the final merge of these pull requests into the `Main` repository.\n\n![Context](article_25_04_2025_integration.png)\n\nAfter outlining the migration concept, let's introduce the Python script designed to assist with the migration.\n\n## Migration Script\n\nThe migration script is crucial to ensure that all necessary steps are performed in the right order. While manual migration might be feasible for smaller projects, it becomes too error-prone and impractical for larger codebases. \n\nConsider the following repositories to demonstrate how the migration script is built:\n\n- Repositories:\n    - `Main`:\n        - MonoRepoMigration_Main\n        - URL: https://github.com/LinkAndreas/MonoRepoMigration_Main\n\n    - `Dependency 1`:\n        - MonoRepoMigration_Dependency1\n            - URL: https://github.com/LinkAndreas/MonoRepoMigration_Dependency1\n\n    - `Dependency 2`:\n        - MonoRepoMigration_Dependency2\n            - URL: https://github.com/LinkAndreas/MonoRepoMigration_Dependency2\n\nWe consider the `Main` repository as well as its in-house dependencies `Dependency1` and `Dependency2`. When the migration is done, we expect both dependencies to be integrated into the `Main` repository according to the following structure:\n\n- Structure:\n    - `./...`\n    - `./Sources/Dependency1/...`\n    - `./Sources/Dependency2/...`\n\nSince source code from `Dependency1` is placed in its root directory, the folder structure needs to be adjusted such that all top-level files and directories are moved into `./Sources/Dependency1`. Similar we proceed with `Dependency2`. This way, we avoid merge conflicts when integrating dependencies into the `Main` repository.\n\n## Steps\n\nLet's begin by defining an abstract Python class to represent a step within the migration:\n\n```py\nfrom abc import ABC, abstractmethod\n\nclass MigrationStep(ABC):\n    def __init__(self, title: str):\n        self.title = title\n\n    @abstractmethod\n    def execute(self) -> None:\n        \"\"\"Execute migration step.\"\"\"\n        pass\n```\n\nAny `MigrationStep` consists of a `title` as well es the `action` that should be done. Using this abstract class we can structure the migration into unique steps.\n\n### Cleanup\n\nFirst, the `CleanupStep` ensures that all artifacts from previous migrations are removed before the migration starts. Otherwise, artifacts of a previous run may interfere with the current run. To ensure a clean context, it suffices to remove all repository directories.\n\n```py\nfrom config import Repository\nfrom utils import remove_directory\nfrom steps.migration_step import MigrationStep\n\nclass CleanupStep(MigrationStep):\n    def __init__(self, title: str, repositories: list[Repository]):\n        self.repositories = repositories\n\n        super().__init__(title)\n\n    def execute(self) -> None:\n        for repo in self.repositories:\n            remove_directory(repo.path)\n            print(f'Removed {repo.name} repository.')\n```\n\n### Clone Repositories\n\nNext, the `CloneRepositoriesStep` clones all repositories passed via its initializer. In this case the `Main` , `Dependency1` and `Dependency2` Repositories are cloned into the same directory where the `migration_script.py` script is run.\n\n```py\nfrom typing import Dict, Any, List\nfrom config import REPOSITORIES\nfrom steps.migration_step import MigrationStep\nfrom utils import git_clone, process_items_with_breaks\n\nclass CloneRepositoriesStep(MigrationStep):\n    def __init__(self, title: str, repositories: List[Any] = REPOSITORIES):\n        super().__init__(title)\n        self.repositories = repositories\n\n    def execute(self) -> None:\n        \"\"\"Clone all repositories.\"\"\"\n        process_items_with_breaks(self.repositories, git_clone)\n```\n\n### Determine Submodule References\n\nBefore starting with package preparation, we need to determine commit hashes of the submodules that are referenced from the main repository. Otherwise, when taking the latest commit, the source code may mismatch leading to compilation issues.\n\n```py\nfrom config import MONO_REPO, PACKAGES, BRANCHES\nfrom utils import process_items_with_breaks, run_in_repo\nfrom steps.migration_step import MigrationStep\nfrom typing import Dict, Any, Callable\n\nclass DetermineSubmoduleReferencesStep(MigrationStep):\n    def __init__(self, title: str, completion: Callable[[Dict[str, Dict[str, str]]], None]):\n        self.completion = completion\n        super().__init__(title)\n\n    def execute(self):\n        references: Dict[str, Dict[str, str]] = {\n            'develop': {},\n            'main': {}\n        }\n\n        def process_branch(branch: str):\n            run_in_repo(MONO_REPO, f'git checkout {branch}')\n            for package in PACKAGES:\n                commit_hash = run_in_repo(\n                    MONO_REPO,\n                    f'git ls-tree {branch} {package.submodulePath} | grep commit | awk \\'{{print $3}}\\'',\n                    print_output=False\n                )\n                references[branch][package.name] = commit_hash\n                print(f'[{branch}] Found {package.name} Git-Submodule Reference: {commit_hash}')\n\n        process_items_with_breaks(BRANCHES, process_branch)\n        self.completion(references)\n```\n\nThe `git ls-tree` command returns the referenced commit hash given the branch as well as the submodule's name. All hashes are stored in the `references` dictionary to be later accessed by the preparation step.\n\n### Prepare Packages\n\nThe `PreparePackagesStep` is responsible to restructure dependencies to ensure seamless integration into the primary repository. This process involves relocating all files from the root directory to subdirectories to minimize merge conflicts during integration. Furthermore, tags are prefixed with the dependency's name to facilitate easy identification within the main repository. Notably, any redundant files such as `swift-lint/-format` configurations or `.gitignore` files are pruned to keep dependencies lean and organized.\n\n```py\nimport os\nimport uuid\nfrom config import PACKAGES, BRANCHES, BRANCH_NAMES\nfrom utils import process_items_with_breaks, run_in_repo, git_merge, git_commit_all, remove_directory\nfrom steps.migration_step import MigrationStep\nfrom typing import Dict, Any\n\nclass PreparePackagesStep(MigrationStep):\n    def __init__(self, title: str, submodule_references: Dict[str, Any]):\n        self.submodule_references = submodule_references\n\n        super().__init__(title)\n\n    def _cleanup_package_files(self, package):\n        \"\"\"Remove package-specific configuration files.\"\"\"\n        paths_to_remove = [\n            '.swiftformat',\n            '.swiftlint.yml',\n            '.gitignore'\n        ]\n\n        for path in paths_to_remove:\n            full_path = os.path.join(package.path, path)\n            if os.path.exists(full_path):\n                try:\n                    remove_directory(full_path)\n                    git_commit_all(package, f'Remove {path}')\n                    print(f'Removed {path}')\n                except Exception as e:\n                    print(f'Warning: Could not remove {path}: {e}')\n            else:\n                print(f'Skipping removal of{path} - file does not exist')\n\n    def execute(self) -> None:\n        def prepare_package(package):\n            print(f'Preparing {package.name}...')\n            run_in_repo(package, 'git fetch --all')\n            run_in_repo(package, f'''git tag -l | while read t; do n=\"{package.name}/$t\"; git tag $n $t; git tag -d $t; done''')\n\n            for branch in BRANCHES:\n                run_in_repo(package, 'git config advice.detachedHead false')\n                commit_hash = self.submodule_references[branch][package.name]\n                print(f'Checkout Commit {commit_hash} in {package.name}')\n                run_in_repo(package, f'git checkout {commit_hash}')\n\n                preparation_branch = BRANCH_NAMES.preparation(branch)\n                run_in_repo(package, f'git checkout -b {preparation_branch}')\n\n                def introduceSourcesSubDirectory():\n                    target_dir = str(uuid.uuid4())\n                    run_in_repo(package, f'mkdir {target_dir}')\n                    excluded = [target_dir, '.git', '.gitignore']\n                    for file_name in [file_name for file_name in os.listdir(package.path) if file_name not in excluded]:\n                        run_in_repo(package, f'git mv {file_name} {target_dir}/{file_name}')\n                    run_in_repo(package, f'git mv {target_dir} {package.name}')\n                    run_in_repo(package, f'mkdir Sources')\n                    run_in_repo(package, f'git mv {package.name} Sources/{package.name}')\n\n                introduceSourcesSubDirectory()\n                print(f'Introduced Sources/{package.name} Sub-Directory')\n                git_commit_all(package, message=f'Introduced subdirectory /Sources/{package.name}')\n\n                self._cleanup_package_files(package)\n\n            git_merge(package, BRANCH_NAMES.preparation('main'), BRANCH_NAMES.preparation('develop'))\n\n        process_items_with_breaks(PACKAGES, prepare_package)\n```\n\n### Add Remotes\n\nAs soon as all packages are prepared, we can add each in-house dependency as a remote of the main repository. By establishing this connection, it is possible to merge the `main` as well as `develop` branch in their respective counterparts in the `Main` repository. By fetching we ensure that we are up-to-date with the latest changes from the remote repository.\n\n```py\nfrom config import MONO_REPO, PACKAGES\nfrom utils import run_in_repo\nfrom steps.migration_step import MigrationStep\n\nclass AddPackageRemotesStep(MigrationStep):\n    def __init__(self, title: str):\n        super().__init__(title)\n\n    def execute(self) -> None:\n        for package in PACKAGES:\n            run_in_repo(MONO_REPO, f'git remote add {package.name} ../{package.path}')\n            run_in_repo(MONO_REPO, f'git fetch {package.name}')\n            print(f'Added remote and fetched branches: {package.name}')\n```\n\n### Merge Packages\n\nNext, integration branches are created in the `Main` repository, which are later merged into the repositoryâ€™s primary branches. These intermediate branches allow us to review all changes before finalizing the migration. Finally, we preserve each dependencyâ€™s commit history by merging with the `--allow-unrelated-histories` flag.\n\n```py\nfrom config import MONO_REPO, PACKAGES, BRANCHES, BRANCH_NAMES\nfrom utils import process_items_with_breaks, run_in_repo, git_commit_all\nfrom steps.migration_step import MigrationStep\n\nclass MergePackagesStep(MigrationStep):\n    def __init__(self, title: str):\n        super().__init__(title)\n\n    def _remove_submodules(self):\n        \"\"\"Remove all submodules from the mono repository for all branches.\"\"\"\n        print('Removing submodules from mono repository...')\n\n        for package in PACKAGES:\n            try:\n                submodule_exists = run_in_repo(\n                    MONO_REPO,\n                    f'git config --file .gitmodules --get submodule.{package.submodulePath}.url',\n                    print_output=False\n                )\n\n                if not submodule_exists:\n                    print(f'Submodule {package.name} does not exist, skipping...')\n                    continue\n\n                run_in_repo(MONO_REPO, f'git submodule deinit -f {package.submodulePath}')\n                run_in_repo(MONO_REPO, f'rm -rf .git/modules/{package.submodulePath}')\n                run_in_repo(MONO_REPO, f'git rm -f {package.submodulePath}')\n                git_commit_all(MONO_REPO, f'Remove submodule {package.name}')\n                print(f'Removed submodule: {package.name}')\n            except Exception as e:\n                print(f'Warning: Could not remove submodule {package.name}: {e}')\n                continue\n\n    def execute(self) -> None:\n        def merge_branch(branch: str):\n            print(f'Processing {branch} branch...')\n            integration_branch = BRANCH_NAMES.integration(branch)\n            run_in_repo(MONO_REPO, f'git checkout {branch}')\n            run_in_repo(MONO_REPO, f'git checkout -b {integration_branch}')\n\n            self._remove_submodules()\n\n            for package in PACKAGES:\n                run_in_repo(\n                    MONO_REPO,\n                    f'git merge {package.name}/{BRANCH_NAMES.preparation(branch)} --quiet --no-ff --allow-unrelated-histories'\n                )\n                print(f'Merged: {package.name}/{BRANCH_NAMES.preparation(branch)} -> {integration_branch}')\n\n        process_items_with_breaks(BRANCHES, merge_branch)\n```\n\n### Remove Remotes\n\nAs soon as submodules are integrated their remotes are removed from the main repository.\n\n```py\nfrom config import MONO_REPO, PACKAGES\nfrom utils import run_in_repo\nfrom steps.migration_step import MigrationStep\n\nclass RemovePackageRemotesStep(MigrationStep):\n    def __init__(self, title: str):\n        super().__init__(title)\n\n    def execute(self) -> None:\n        for package in PACKAGES:\n            run_in_repo(MONO_REPO, f'git remote remove {package.name}')\n            print(f'Removed remote: {package.name}')\n```\n\n# Migration\n\nHaving outlined all the steps required for a monorepo migration, we can now implement a dedicated `MonoRepoMigration` class responsible for executing them in sequence. While most steps operate solely on input, the `DetermineSubmoduleReferencesStep` includes a completion handler to communicate the discovered submodules. Itâ€™s important to note that the migration process does not push any changes to the remote repository. Instead, all operations are performed locally on device. Once everything has been verified and works as expected, the integration branches can be pushed to the remote to create pull requests and finalize the migration.\n\n```py\n#!/usr/bin/env python3\n\nfrom typing import Dict, List\nfrom config import REPOSITORIES, PACKAGES\nfrom utils import withExecutionTimeMeasurement, perform_action\nfrom steps.migration_step import MigrationStep\nfrom steps import (\n    CleanupStep,\n    CloneRepositoriesStep,\n    DetermineSubmoduleReferencesStep,\n    PreparePackagesStep,\n    AddPackageRemotesStep,\n    MergePackagesStep,\n    RemovePackageRemotesStep\n)\n\nclass MonoRepoMigration:\n    def __init__(self):\n        self.submodule_references: Dict[str, Dict[str, str]] = {}\n\n    def run(self):\n        \"\"\"Execute the complete migration process.\"\"\"\n        def execute_migration():\n            # Define steps\n            steps: List[MigrationStep] = [\n                CleanupStep(\n                    title='Pre-Migration Cleanup',\n                    repositories=REPOSITORIES\n                ),\n                CloneRepositoriesStep(\n                    title='Cloning Repositories',\n                    repositories=REPOSITORIES\n                ),\n                DetermineSubmoduleReferencesStep(\n                    title='Determining Submodule References',\n                    completion=lambda value: self.submodule_references.update(value)\n                ),\n                PreparePackagesStep(\n                    title='Preparing Packages',\n                    submodule_references=self.submodule_references\n                ),\n                AddPackageRemotesStep(\n                    title='Adding Package Remotes'\n                ),\n                MergePackagesStep(\n                    title='Merging Packages'\n                ),\n                RemovePackageRemotesStep(\n                    title='Removing Package Remotes'\n                ),\n                CleanupStep(\n                    title='Post-Migration Cleanup',\n                    repositories=PACKAGES\n                )\n            ]\n\n            # Perform each step\n            for step in steps:\n                perform_action(step.title, step.execute)\n\n        withExecutionTimeMeasurement(\n            action_name='Migration',\n            action=execute_migration\n        )\n\nif __name__ == \"__main__\":\n    migration = MonoRepoMigration()\n    migration.run()\n```\n\nBelow you can find all constants that are used by the migration script. This way, we can define the `Main` repository as well as its in-house dependencies and the primary branches involved in the migration.\n\n```py\n#!/usr/bin/env python3\n\nfrom dataclasses import dataclass\nfrom typing import Callable\n\n@dataclass\nclass BranchNames:\n    preparation: Callable[[str], str]\n    integration: Callable[[str], str]\n\n@dataclass\nclass Repository:\n    name: str\n    url: str\n    path: str\n    submoduleName: str | None\n    submodulePath: str | None\n\n# Branch naming configuration\nBRANCH_NAMES = BranchNames(\n    preparation=lambda branch: f'feature/Prepare-Repository-{branch}',\n    integration=lambda branch: f'feature/Integrate-Repository-{branch}'\n)\n\n# Repository configurations\nMONO_REPO = Repository(\n    name='Main',\n    url='git@github.com:LinkAndreas/MonoRepoMigration_Main.git',\n    path='MonoRepoMigration_Main',\n    submoduleName=None,\n    submodulePath=None\n)\n\nPACKAGES = [\n    Repository(\n        name='Dependency1',\n        url='git@github.com:LinkAndreas/MonoRepoMigration_Dependency1.git',\n        path='MonoRepoMigration_Dependency1',\n        submoduleName='Dependency1',\n        submodulePath='Sources/Dependency1'\n    ),\n    Repository(\n        name='Dependency2',\n        url='git@github.com:LinkAndreas/MonoRepoMigration_Dependency2.git',\n        path='MonoRepoMigration_Dependency2',\n        submoduleName='Dependency2',\n        submodulePath='Sources/Dependency2'\n    )\n]\n\n# Combined repositories list\nREPOSITORIES = [MONO_REPO] + PACKAGES\n\n# Branch configurations\nBRANCHES = [\"develop\", \"main\"]\n```\n\nFor the sake of completeness, the following table contains all utility methods used throughout the migration:\n\n| Method                           | Purpose                                         |\n|----------------------------------|-------------------------------------------------|\n| `run_command(...)`              | Runs a shell command and returns the output.   |\n| `run_in_repo(...)`             | Runs a command inside a given Git repo.        |\n| `process_items_with_breaks(...)`| Processes items, with optional line breaks.     |\n| `remove_directory(...)`        | Deletes a directory and its contents.           |\n| `perform_action(...)`          | Logs and runs a titled action.                  |\n| `git_clone(...)`               | Clones a Git repo with submodules.              |\n| `git_merge(...)`               | Merges one branch into another.                 |\n| `git_commit_all(...)`          | Stages and commits all repo changes.            |\n| `withExecutionTimeMeasurement(...)` | Times and logs how long an action takes.   |\n\n```py\nfrom datetime import datetime\nfrom subprocess import Popen, PIPE\nfrom typing import List, Callable, Any\nfrom config import Repository\n\ndef run_command(command: str, print_output: bool = True) -> str:\n    \"\"\"Execute a shell command and return its output.\"\"\"\n    command = f'set -Eeuo pipefail && {command}'\n    process = Popen(command, stdout=PIPE, shell=True, text=True)\n    lines = []\n\n    while True:\n        line = process.stdout.readline().rstrip()\n        if not line:\n            break\n        lines.append(line)\n        if print_output:\n            print(line)\n\n    output = \"\\n\".join(lines)\n    process.communicate()\n\n    if process.returncode != 0:\n        raise Exception(f\"Command failed with exit code {process.returncode}: {command}\")\n\n    return output\n\ndef run_in_repo(repo: Repository, command: str, print_output: bool = True) -> str:\n    \"\"\"Execute a command in the context of a repository.\"\"\"\n    return run_command(f'(cd {repo.path} && {command})', print_output)\n\ndef process_items_with_breaks(items: List, action: Callable, show_breaks: bool = True) -> None:\n    \"\"\"Process a list of items with optional line breaks between them.\"\"\"\n    for index, item in enumerate(items):\n        action(item)\n        if show_breaks and index < len(items) - 1:\n            print('')\n\ndef remove_directory(path: str) -> None:\n    \"\"\"Safely remove a directory and its contents.\"\"\"\n    run_command(f'rm -rf {path}')\n\ndef perform_action(title: str, action: Callable) -> Any:\n    \"\"\"Execute an action with formatted logging.\"\"\"\n    print(f\"\\n=============== {title} ===============\\n\")\n    result = action()\n    print(\"=\" * (len(title) + 32))\n    return result\n\ndef git_clone(repo: Repository) -> None:\n    \"\"\"Clone a git repository.\"\"\"\n    run_command(f'git clone {repo.url} --progress --recursive')\n\ndef git_merge(repo: Repository, source: str, destination: str) -> None:\n    \"\"\"Merge branches in a repository.\"\"\"\n    run_in_repo(repo, f'git checkout {destination}')\n    run_in_repo(repo, f'git merge {source} --strategy=ours --quiet --no-ff --no-edit')\n    print(f'Merged {source} -> {destination}')\n\ndef git_commit_all(repo: Repository, message: str) -> None:\n    \"\"\"Commit all changes in a repository.\"\"\"\n    run_in_repo(repo, f'git add -A')\n    run_in_repo(repo, f'git commit --quiet -m \"{message}\"')\n\ndef withExecutionTimeMeasurement(action_name: str, action: Callable) -> Any:\n    \"\"\"Measure and print execution time of an action\"\"\"\n    start_time = datetime.now()\n    print(f'Starting {action_name}...\\n')\n\n    result = action()\n\n    duration = (datetime.now() - start_time).total_seconds()\n    print(f'\\nFinished {action_name} in {duration:.2f} seconds.')\n    return result\n```\n\nBefore concluding this article, we present a structured approach for executing the mono-repo migration in a coordinated and controlled manner.\n\n## Procedure\n\nWhile the migration script enables local testing, completing the migration requires a coordinated effort among team members.\n\nBelow, youâ€™ll find the key steps to follow before, during, and after the migration. Although the exact procedure may vary depending on your specific context, this guide can serve as a blueprint to help you successfully initiate and manage your own migration process.\n\n### Pre-migration\n\n1. Identify a suitable time window for the migration  \n   - If youâ€™re working in sprints, the beginning of a sprint is often ideal, as thereâ€™s typically less delivery pressure compared to the end.\n2. Request all developers to merge their open pull requests by a fixed deadline  \n   - This ensures a clean state and minimizes merge conflicts during the migration.\n\n### Migration\n\n1. Notify the team that the migration is about to begin.\n2. Temporarily freeze all merges to `main` and `develop` during the migration process.\n3. Merge the latest changes from `main` into `develop`  \n   - This ensures that any hotfixes or bugfixes are synchronized with the ongoing development branch.\n4. Run the **migration script** on a developer machine with access to all required repositories  \n   - After execution, review the logs to ensure there were no errors.  \n   - Verify the migration result by checking the branch and commit history in your Git client.\n5. Create pull requests from the integration branches generated by the script.\n6. Have your team review the changes introduced during the migration.\n7. Merge the integration branches into `develop` and `main`.\n8. Push any migrated tags to the main repository.\n\n### Post-migration\n\n1. Announce to the team that the migration is complete.\n2. Archive or restrict access to the now-obsolete repositories.\n3. Re-enable merges into `main` and `develop`.\n\n## Conclusion\n\nIn this article, we examined the trade-offs between `Mono-` and `Multi-Repo` and introduced a structured approach to a `Mono-Repo` migration. Consolidating repositories can significantly enhance developer productivity by minimizing cross-repository coordination and reducing the number of required pull requests. The provided migration script automates key steps, enabling repeatable and locally testable migrations without impacting the remote repository. Once validated, changes are submitted through dedicated pull requests, ensuring all modifications remain transparent, reviewable, and easy to track.\n\n## References\n\n- [Move to Mono-Repo](https://alexharri.com/blog/move-to-monorepo) - Alex Harri\n- [Git Merge to Mono-Repo](https://choly.ca/post/git-merge-to-monorepo/) - Ilia Choly\n- [Merge Git Repos and keep Commit History](https://gfscott.com/blog/merge-git-repos-and-keep-commit-history/) - Graham F. Scott\n\nHappy Coding ðŸš€","title":"Mono-Repo Migration: Boosting Developer Productivity While Keeping Git History Intact","description":"Modularization is essential for scaling large software projects, enabling faster \n            development and better maintainability. However, when modules are split across multiple \n            repositories, developer productivity can suffer due to the overhead of coordinating changes \n            across projects. In this article, we explore how transitioning to a Mono-Repo can streamline \n            collaboration and demonstrate a Python script to automate the migration process."}},"__N_SSG":true}