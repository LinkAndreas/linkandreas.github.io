{"pageProps":{"article":{"id":"17_04_2023","date":"17th of April 2023","markdown":"# Automating your iOS App Development Workflow: Continuous Deployment with GitHub Actions\n\nIn agile software development, continuous deployment is key to collect user feedback leading to more reliable and successful iOS apps. Still, deploying to AppStore Connect is challenging due to managing signing certificates, provisioning profiles, and build numbers. In this article, we'll explore how to automate this process, allowing you to release your apps with a single button press.\n\n## Environment Variables\n\nFirst, we need to configure the following environment variables in your project's settings (`Project` > `Settings` > `Security` > `Secrets and Environment Variables` > `actions`):\n\n| Key                       | Value (Example)   |\n|---------------------------|-------------------|\n| APP_ID                    | 1234567           |\n| TEAM_ID                   | A123456789        |\n| BUNDLE_ID                 | com.example.app   |\n| PROVISIONING_PROFILE_NAME | Distribution      |\n| SIMULATOR_DEVICE_TYPE     | iPhone-14         |\n| SIMULATOR_RUNTIME         | iOS-16-2          |\n\nExplanation:\n- `APP_ID`: The identifier that uniquely identifies the application.\n  - Location: AppStore Connect > Apps > App > App Information > Apple ID\n- `TEAM_ID`: The identifier for the team enrolled in the Apple Developer Program.\n  - Location: AppStore Connect > Edit Profile > TeamID\n- `BUNDLE_ID`: The identifier used by Apple to uniquely identify the application.\n  - Location: AppStore Connect > Apps > App > App Information > Bundle Identifier\n- `PROVISIONING_PROFILE_NAME`: The name of the provisioning profile.\n- `SIMULATOR_DEVICE_TYPE`: The simulator device used to run tests in the workflow.\n- `SIMULATOR_RUNTIME`: The Runtime version of the iOS simulator.\n\n## Secrets\n\nNext, we create the following secrets in the project's settings:\n\n| Key                            | Value (Example)      |\n|--------------------------------|----------------------|\n| API_KEY_BASE64       \t         | XXXXXXXXXX           |\n| API_KEY_ID                     | XXXXXXXXXX           |\n| API_KEY_ISSUER_ID              | XXXXXXXXXX           |\n| KEYCHAIN_PASSWORD              | XXXXXXXXXX           |\n| SIGNING_CERTIFICATE_BASE64     | XXXXXXXXXX           |\n| SIGNING_CERTIFICATE_PASSWORD   | XXXXXXXXXX           |\n| PROVISIONING_PROFILE_BASE64    | XXXXXXXXXX           |\n\nGithub secrets store sensitive information in the project's repository and provide them as encrypted workflow configuration variables to the workflows, ensuring that their values are hidden from the web interface and can only be updated, not seen, once stored.\n\nExplanation:\n- `API_KEY_BASE64`: The private key to authorize against the AppStore Connect API encoded in base64 format.\n- `API_KEY_ID`: The key's Id.\n  - Location: App Store Connect > Users and Access > Keys\n- `API_KEY_ISSUER_ID`: The identifier of the issuer who created the authentication token.\n  - Location: App Store Connect > Users and Access > Keys > Issuer Id\n- `KEYCHAIN_PASSWORD`: The password used to unlock the keychain.\n- `SIGNING_CERTIFICATE_BASE64`: The signing certificate encoded in base64 format.\n- `SIGNING_CERTIFICATE_PASSWORD`: The password for your Apple signing certificate.\n- `PROVISIONING_PROFILE_BASE64`: The provisioning profile encoded in base64 format.\n\nYou can use the following commands to encode secrets in base64 format and copy it to the pasteboard:\n\n```sh\n# API_KEY_BASE64\nopenssl base64 -in AuthKey_{KEY_ID}.p8 | pbcopy\n\n# SIGNING_CERTIFICATE_BASE64\nopenssl base64 -in {SIGNING_CERTIFICATE_NAME}.p12 | pbcopy \n\n# PROVISIONING_PROFILE_BASE64\nopenssl base64 -in {PROVISIONING_PROFILE_NAME}.mobileprovision | pbcopy \n```\n\n## Deployment Workflow\n\nHaving specified all secrets and configuration variables, we can create a dedicated workflow that automates deployment to AppStore Connect. This way, we can distribute the application to TestFlight and get feedback from internal- and external testers.\n\nWe start with the following blueprint:\n\n```yml\nname: Deploy to App Store Connect\n\non:\n  workflow_dispatch:\n\njobs:\n  archive-and-deploy:\n    runs-on: macos-latest\n\n    steps:\n        ...\n```\n\nNote that only the manual trigger via the web interface is included to better control when deployment is made. Still, it is possible to enable automatic deployment whenever the `main` branch is updated:\n\n```yaml\non:\n  push:\n    branches:\n      - main\n```\n\n###  Step 1: Checkout Repository\n\nFirst, we use the checkout step to gain access to the source code:\n\n```yaml\n- name: Checkout repository\n  uses: actions/checkout@v3\n```\n\n### Step 2: Install App Store Connect API Key \n\nNext, we need to install the private key to the agent such that it can communicate with AppStore Connect:\n\n```sh\nmkdir ~/.private_keys\necho -n \"$API_KEY_BASE64\" | base64 --decode --output ~/.private_AuthKey_${{ secrets.API_KEY_ID }}.p8\necho \"After saving:\"\nls ~/.private_keys\n```\n\nThe API Key is decoded from the base64-encoded secret and stored in the current directory.\n\n### Step 3: Install Signing Certificate\n\nNext, the signing certificate is decoded and stored in the `app-signing` keychain. We unlock the keychain to have access to the signing certificate when archiving the application:\n\n```sh\nSIGNING_CERTIFICATE_PATH=$RUNNER_TEMP/signing_certificate.p12\nKEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n# Read Signing Certificate\necho -n \"$SIGNING_CERTIFICATE_BASE64\" | base64 --decode -o \"$SIGNING_CERTIFICATE_PATH\"\n\n# Create Keychain\nsecurity create-keychain -p \"$KEYCHAIN_PASSWORD\" \"$KEYCHAIN_PATH\"\nsecurity set-keychain-settings -lut 21600 \"$KEYCHAIN_PATH\"\nsecurity unlock-keychain -p \"$KEYCHAIN_PASSWORD\" \"$KEYCHAIN_PATH\"\n\n# Import Signing Certificate to Keychain\nsecurity import \"$SIGNING_CERTIFICATE_PATH\" -P \"$SIGNING_CERTIFICATE_PASSWORD\" -A -t cert -f pkcs12 -k \"$KEYCHAIN_PATH\"\nsecurity list-keychain -d user -s \"$KEYCHAIN_PATH\"\n```\n\n### Step 4: Install Provisioning Profile\n\nSimilarly, the provising profile is decoded and stored in the agent's library directory(`~/Library/MobileDevice/Provisioning\\ Profiles`):\n\n```sh\nPROVISIONING_PROFILE_PATH=$RUNNER_TEMP/provisioning_profile.mobileprovision\n\n# Read Provisioning Profile\necho -n \"$PROVISIONING_PROFILE_BASE64\" | base64 --decode -o \"$PROVISIONING_PROFILE_PATH\"\n\n# Import Provisioning Profile\nmkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\ncp $PROVISIONING_PROFILE_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n```\n\nThe provisioning profiles specify the devices the application is allowed to run. In addition, they ensure that the app is from a trusted source and has not been tampered with. \n\n### Step 5: Configure `exportOptions.plist`\n\nNext, we inject the provisioning profile's name, the Team- and Bundle-ID into the `exportOptions.plist` that is used by `xcodebuild` when distributing the archive. The injection is done using the `sed` command with which we can replace the placeholders `{{Placeholder}}` with their corresponding values:\n\n```sh\n- name: Configure exportOptions.plist\n  env: \n    TEAM_ID: ${{ vars.TEAM_ID }}\n    BUNDLE_ID: ${{ vars.BUNDLE_ID }}\n    PROVISIONING_PROFILE_NAME: ${{ vars.PROVISIONING_PROFILE_NAME }}\n  run: |\n    sed -i '' \"s/{{TEAM_ID}}/$TEAM_ID/g\" exportOptions.plist\n    sed -i '' \"s/{{BUNDLE_ID}}/$BUNDLE_ID/g\" exportOptions.plist\n    sed -i '' \"s/{{PROVISIONING_PROFILE_NAME}}/$PROVISIONING_PROFILE_NAME/g\" exportOptions.plist\n```\n\nThis way, we can customize the export process and specify the distribution method as well as the provisioning profile, used when code signing the app.\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>method</key>\n    <string>app-store</string>\n    <key>teamID</key>\n    <string>{{TEAM_ID}}</string>\n    <key>uploadSymbols</key>\n    <true/>\n    <key>signingStyle</key>\n    <string>manual</string>\n    <key>provisioningProfiles</key>\n    <dict>\n        <key>{{BUNDLE_ID}}</key>\n        <string>{{PROVISIONING_PROFILE_NAME}}</string>\n    </dict>\n</dict>\n</plist>\n```\n\n### Step 6: Inject Build Number\n\nNow that we have the signing certificate, provisioning profile and API Key in place, we need to determine the build number.\nEach buildnmber submitted to AppStore Connect is required to be strictly greater than the maximum known build number of all builds ever submitted. Since manually keeping track of build numbers is tedious, we utitlize the workflow's built-in counter, i.e., `github.run_number` that is incremented on every build. This way, we only need to specify the marketing version that is shown in the AppStore:  \n\n```sh\nbuildNumber=${{ github.run_number }}\necho \"Current build number: $buildNumber\"\nagvtool new-version -all $buildNumber\n```\n\n### Step 7: Build, Sign and Archive\n\nHaving setup the environment, we can archive the application as an `xcarchive`. Note that we use manual signing with the provising profile that we imported in an earlier step: \n\n```sh\nset -o pipefail && xcodebuild clean archive \\\n  -scheme \"App\" \\\n  -archivePath $RUNNER_TEMP/App.xcarchive \\\n  -sdk iphoneos \\\n  -configuration Release \\\n  -destination generic/platform=iOS \\\n  CODE_SIGN_STYLE=Manual \\\n  PROVISIONING_PROFILE_SPECIFIER=Distribution | xcpretty\n```\n\n### Step 8: Export Archive\n\nAs soon as the archive is built, we can export the iOS AppStore Package (`.ipa`) considering the `exportOptions`.\n\n```sh\nARTIFACT_FILEPATH=$RUNNER_TEMP/App.ipa\nset -o pipefail && xcodebuild -exportArchive \\\n  -archivePath $RUNNER_TEMP/App.xcarchive \\\n  -exportOptionsPlist exportOptions.plist \\\n  -exportPath $RUNNER_TEMP | xcpretty\n```\n\n### Step 9: Publish Archive\n\nAn iOS AppStore Package (`.ipa`) is technically identical to a `zip` file and can be extracted by renaming it's file extension. That's why it makes sence to publish it as a workflow artifact, such that we can access to the package and verify whether all ressources are properly bundled:\n\n```yaml\n- name: Publish App.ipa file\n  uses: actions/upload-artifact@v3\n  with:\n    name: App.ipa\n    path: ${{ runner.temp }}/App.ipa\n```\n\n### Step 10: Validate Build Artifact\n\nBefore uploading the application package to AppStore Connect, we use the `altool` command to validate it. In case the AppStore will not accept the package the validation will fail. E.g., we might have missed adding an App Icon which is required by the store:\n\n```sh\nxcrun altool --validate-app \\\n  -f ${{ runner.temp }}/App.ipa \\\n  -t ios \\\n  --apiKey ${{ secrets.API_KEY_ID }} \\\n  --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n```\n\n### Step 11: Upload Build Artifact to AppStore Connect\n\nIn case the validation succeeded, we can upload the package via the AppStore Connect API.\n\n```sh\nxcrun altool --upload-app \\\n  -f ${{ runner.temp }}/App.ipa \\\n  -t ios \\\n  --apiKey ${{ secrets.API_KEY_ID }} \\\n  --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n```\n\n### Step 12: Cleanup keychain and provisioning profile\n\nEven though Github's own runners always ensure that we start with a clean environment it is best practive to clean up certificates that are no longer needed. In case we would use a self hosted runner, these artifacts could otherwiese remain and cause unintended side-effects on subsequent builds.\n\n```sh\nsecurity delete-keychain $RUNNER_TEMP/app-signing.keychain-db\nrm ~/Library/MobileDevice/Provisioning\\ Profiles/provisioning_profile.mobileprovision\n```\n\n### Deploy to AppStore Connect Workflow\n\nFinally, we obtain the following worklow that is stored as `deploy.yml` in the `.github/workflows` directory:\n\n```yml\nname: Deploy to AppStore Connect\n\non:\n  workflow_dispatch:\n\njobs:\n  archive-and-deploy:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Install App Store Connect Api Key\n        env:\n          API_KEY_BASE64: ${{ secrets.API_KEY_BASE64 }}\n        run: |\n          mkdir ~/.private_keys\n          echo -n \"$API_KEY_BASE64\" | base64 --decode --output ~/.private_keys/AuthKey_${{ secrets.API_KEY_ID }}.p8\n          echo \"After saving:\"\n          ls ~/.private_keys\n\n      - name: Install Signing Certificate\n        env:\n          SIGNING_CERTIFICATE_BASE64: ${{ secrets.SIGNING_CERTIFICATE_BASE64 }}\n          SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}\n          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}\n        run: |\n          SIGNING_CERTIFICATE_PATH=$RUNNER_TEMP/signing_certificate.p12\n          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n          # Read Signing Certificate\n          echo -n \"$SIGNING_CERTIFICATE_BASE64\" | base64 --decode -o \"$SIGNING_CERTIFICATE_PATH\"\n\n          # Create Keychain\n          security create-keychain -p \"$KEYCHAIN_PASSWORD\" \"$KEYCHAIN_PATH\"\n          security set-keychain-settings -lut 21600 \"$KEYCHAIN_PATH\"\n          security unlock-keychain -p \"$KEYCHAIN_PASSWORD\" \"$KEYCHAIN_PATH\"\n\n          # Import Signing Certificate to Keychain\n          security import \"$SIGNING_CERTIFICATE_PATH\" -P \"$SIGNING_CERTIFICATE_PASSWORD\" -A -t cert -f pkcs12 -k \"$KEYCHAIN_PATH\"\n          security list-keychain -d user -s \"$KEYCHAIN_PATH\"\n\n      - name: Install Provisioning Profile\n        env:\n          PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}\n        run: |\n          PROVISIONING_PROFILE_PATH=$RUNNER_TEMP/provisioning_profile.mobileprovision\n\n          # Read Provisioning Profile\n          echo -n \"$PROVISIONING_PROFILE_BASE64\" | base64 --decode -o \"$PROVISIONING_PROFILE_PATH\"\n\n          # Import Provisioning Profile\n          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\n          cp $PROVISIONING_PROFILE_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n\n      - name: Inject Build Number\n        run: |\n          buildNumber=${{ github.run_number }}\n          echo \"Current build number: $buildNumber\"\n          agvtool new-version -all $buildNumber\n          sed -i \"\" \"s/CFBundleVersion/$buildNumber/\" exportOptions.plist\n\n      - name: Configure exportOptions.plist\n        env: \n          TEAM_ID: ${{ vars.TEAM_ID }}\n          BUNDLE_ID: ${{ vars.BUNDLE_ID }}\n          PROVISIONING_PROFILE_NAME: ${{ vars.PROVISIONING_PROFILE_NAME }}\n        run: |\n          sed -i '' \"s/{{TEAM_ID}}/$TEAM_ID/g\" exportOptions.plist\n          sed -i '' \"s/{{BUNDLE_ID}}/$BUNDLE_ID/g\" exportOptions.plist\n          sed -i '' \"s/{{PROVISIONING_PROFILE_NAME}}/$PROVISIONING_PROFILE_NAME/g\" exportOptions.plist\n\n      - name: Build, Sign and Archive\n        run: |\n          set -o pipefail && xcodebuild clean archive \\\n            -scheme \"App\" \\\n            -archivePath $RUNNER_TEMP/App.xcarchive \\\n            -sdk iphoneos \\\n            -configuration Release \\\n            -destination generic/platform=iOS \\\n            CODE_SIGN_STYLE=Manual \\\n            PROVISIONING_PROFILE_SPECIFIER=Distribution | xcpretty\n\n      - name: Export archive\n        run: |\n          ARTIFACT_FILEPATH=$RUNNER_TEMP/App.ipa\n          set -o pipefail && xcodebuild -exportArchive \\\n            -archivePath $RUNNER_TEMP/App.xcarchive \\\n            -exportOptionsPlist exportOptions.plist \\\n            -exportPath $RUNNER_TEMP | xcpretty\n\n      - name: Publish App.ipa file\n        uses: actions/upload-artifact@v3\n        with:\n          name: App.ipa\n          path: ${{ runner.temp }}/App.ipa\n      \n      - name: Validate Build Artifact\n        run: |\n          xcrun altool --validate-app \\\n            -f ${{ runner.temp }}/App.ipa \\\n            -t ios \\\n            --apiKey ${{ secrets.API_KEY_ID }} \\\n            --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n\n      - name: Upload Build Artifact to TestFlight\n        run: |\n          xcrun altool --upload-app \\\n            -f ${{ runner.temp }}/App.ipa \\\n            -t ios \\\n            --apiKey ${{ secrets.API_KEY_ID }} \\\n            --apiIssuer ${{ secrets.API_KEY_ISSUER_ID }}\n\n      - name: Clean up keychain and provisioning profile\n        if: ${{ always() }}\n        run: |\n          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db\n          rm ~/Library/MobileDevice/Provisioning\\ Profiles/provisioning_profile.mobileprovision\n```\n\n# Conclusion\n\nIn this article, we went through the necessary steps to automate deployment of an iOS application via Github Actions. Having setup the dedicated workflow, we can release the app upon the press of a button and rather focus on building features while getting valuable feedback from testers and users. \n\n# References:\n\n- [Sign Xcode Applications](https://docs.github.com/en/actions/deployment/deploying-xcode-applications/installing-an-apple-certificate-on-macos-runners-for-xcode-development) - Github\n- [iOS CI/CD Worklfow using Github Actions](https://www.cobeisfresh.com/blog/how-to-implement-a-ci-cd-workflow-for-ios-using-github-actions) - cobeisfresh\n\nHappy Coding ðŸš€","title":"Automating your iOS App Development Workflow: Continuous Deployment with GitHub Actions","description":"In agile software development, continuous deployment is key to collect \n            user feedback leading to more reliable and successful iOS apps. Still, deploying to \n            AppStore Connect is challenging due to managing signing certificates, provisioning profiles, \n            and build numbers. In this article, we'll explore how to automate this process, allowing \n            you to release your apps with a single button press.","images":[]}},"__N_SSG":true}