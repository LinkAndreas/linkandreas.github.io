{"pageProps":{"article":{"id":"10_04_2023","date":"10th of April 2023","markdown":"# Automating your iOS App Development Workflow: Continuous Testing with GitHub Actions\n\nAre you striving to iterate quickly to deliver new features, all while ensuring the reliability and performance of your iOS application? Efficient workflows are key to achiving this goal. In this article, we'll explore how we can leverage the power of Github Actions to automate testing and continuous deployment of iOS applications.\n\nLet's focus on the required steps to automate test execution when a pull-request is created:\n\n## Test Execution Workflow\n\nUnit tests are crucial in software development as they identify errors early in the process and enable safe code refactoring without regression. Running them often is particularly important in large-scale projects with multiple developers involved to obtain valuable feedback and maintain high code quality standards.\n\nWe initiate the \"Unit Tests\" workflow by establishing a blueprint that runs on agents featuring the latest macOS version. The workflow is either triggered manually via the Web interface or automatically upon branch activity after pull request creation:\n\n```yml\nname: Unit Tests\non:\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  execute-unit-tests:\n    runs-on: macos-latest\n\n    steps:\n      ...\n```\n\nNext, we specify the steps that are required to execute unit tests on the agent:\n\n### Step 1: Checkout Repository\n\nFirst, we need to checkout the repository to gain access to the source code. Github Actions offers the `checkout@v3` step that checks-out your repository under `GITHUB_WORKSPACE`:\n\n```yaml\n- name: Checkout repository\n  uses: actions/checkout@v3\n```\n\n### Step 2: Create and Boot 'iPhoneForTesting' Simulator\n\nNext, we create and boot the iOS Simulator, that is utilized to execute the tests. By default, `xcodebuild` selects any of the existing simulators on the agent, which may result in issues, particularly when using snapshot testing, due to potential variations in device dimensions and properties. \n\n`SIMULATOR_DEVICE_TYPE` and `SIMULATOR_RUNTIME` are environment variables that specify the exact device type and runtime. This way, all tests are executed on the same simulator accross agents. After the simulator is booted, we store its identifier in an environment variable (`SIMULATOR_IDENTIFIER`) to reference it as destination during test execution: \n\n```sh\nidentifier=$(\n  xcrun simctl create iPhoneForTesting \\\n  com.apple.CoreSimulator.SimDeviceType.$SIMULATOR_DEVICE_TYPE \\\n  com.apple.CoreSimulator.SimRuntime.$SIMULATOR_RUNTIME\n)\necho \"Created iPhoneForTesting with identifier: $identifier\"\nxcrun simctl boot $identifier\necho \"Booted iPhoneForTesting with identifier: $identifier\"\necho \"SIMULATOR_IDENTIFIER=$identifier\" >> $GITHUB_ENV\n```\n\n### Step 3: Execute Tests\n\nAs soon as the simulator is configured, we set it as destination and execute the tests after cleaning the project (`xcodebuild clean test`). Note that we set a custom `derivedDataPath` as well as `resultBundlePath` and also enable Code Covergae to access code coverage reports. In addition, we pipe the output generated from `xcodebuild`, store it in a local `xcodebuild.log` file and also pass it on to `xcpretty` that prints the output in a human readable format to the console.\n\n```sh\nset -o pipefail && xcodebuild clean test \\\n  -scheme \"App\" \\\n  -derivedDataPath $RUNNER_TEMP/build \\\n  -configuration 'Debug' \\\n  -destination \"platform=iOS Simulator,id=${SIMULATOR_IDENTIFIER}\" \\\n  -resultBundlePath $RUNNER_TEMP/App.xcresult \\\n  -enableCodeCoverage YES | tee $RUNNER_TEMP/xcodebuild.log | xcpretty\n```\n\nWithout specifying `set -o pipefail` the command will only consider the exit status of the rightmost command, i.e., of `xcpretty`. By specifying `set -o pipefail` we ensure that output of `xcodebuild` is considered for the exit status of the whole command.\n\n### Step 4: Publish xcodebuild.log\n\nThe `xcodebuild.log` file contains the raw output of `xcodebuild` and is useful to investigate why the command has failed. Sometimes the error is hard to find and may be hidden by `xcpretty`. Publising the raw output as build artifact allows us to better understand what went wrong:\n\n```yaml\n- name: Publish xcodebuild.log\n  uses: actions/upload-artifact@v3\n  with:\n    name: xcodebuild.log\n    path: ${{ runner.temp }}/xcodebuild.log\n```\n\n### Step 5: Remove 'iPhoneForTesting' Simulator\n\nFinally, after test execution is done, we can remove the simulator from the agent. Note that instead of only removing the simulator thet was created in the second step, we search for the identifiers of all simulators named `iPhoneForTesting` to cleanup the agent even when a previous removal has failed:\n\n```sh\nkillall Simulator 2>&1 || true\nxcrun simctl list devices | \\\n  grep \"iPhoneForTesting\" | \\\n  grep -E -o -i \"([0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12})\" | \\\n  while read -r identifier; do \\\n    xcrun simctl delete \"$identifier\"; \\\n    \"Removed simulator with identifier: $identifier\"; \\\n  done\n```\n\n### Unit Test Workflow\n\nAfter combining all steps, we obtain the following worklow that is stored as `test.yml` in the `.github/workflows` directory:\n\n```yml\nname: Unit Tests\non:\n  workflow_dispatch:\n\njobs:\n  execute-unit-tests:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Create and Boot 'iPhoneForTesting' Simulator\n        env: \n          SIMULATOR_DEVICE_TYPE: ${{ vars.SIMULATOR_DEVICE_TYPE }}\n          SIMULATOR_RUNTIME: ${{ vars.SIMULATOR_RUNTIME }}\n        run: |\n          identifier=$(xcrun simctl create iPhoneForTesting com.apple.CoreSimulator.SimDeviceType.$SIMULATOR_DEVICE_TYPE com.apple.CoreSimulator.SimRuntime.$SIMULATOR_RUNTIME)\n          echo \"Created iPhoneForTesting with identifier: $identifier\"\n          xcrun simctl boot $identifier\n          echo \"Booted iPhoneForTesting with identifier: $identifier\"\n          echo \"SIMULATOR_IDENTIFIER=$identifier\" >> $GITHUB_ENV\n\n      - name: Test\n        env:\n          SIMULATOR_IDENTIFIER: ${{ env.SIMULATOR_IDENTIFIER }}\n        run: |\n          set -o pipefail && xcodebuild clean test \\\n            -scheme \"App\" \\\n            -derivedDataPath $RUNNER_TEMP/build\\\n            -configuration 'Debug' \\\n            -destination \"platform=iOS Simulator,id=${SIMULATOR_IDENTIFIER}\" \\\n            -resultBundlePath $RUNNER_TEMP/App.xcresult \\\n            -enableCodeCoverage YES | tee $RUNNER_TEMP/xcodebuild.log | xcpretty\n\n      - name: Publish xcodebuild.log\n        uses: actions/upload-artifact@v3\n        with:\n          name: xcodebuild.log\n          path: ${{ runner.temp }}/xcodebuild.log\n\n      - name: Remove 'iPhoneForTesting' Simulator\n        if: ${{ always() }}\n        run: |\n          killall Simulator 2>&1 || true\n          xcrun simctl list devices | \\\n            grep \"iPhoneForTesting\" | \\\n            grep -E -o -i \"([0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12})\" | \\\n            while read -r identifier; do xcrun simctl delete \"$identifier\"; echo \"Removed simulator with identifier: $identifier\"; done\n```\n\n# Conclusion\n\nIn this article, we explored how we can leverage the power of github actions to automate test execution whenever a pull-request is created. This is particularly useful in larger teams, as it effectively minimizes the occurrence of bugs and ensures continuous enhancement of the codebase.\n\n# References:\n\n- [Quickstart for Github Actions](https://docs.github.com/en/actions/quickstart) - Github\n- [Building from the Command Line with Xcode](https://developer.apple.com/library/archive/technotes/tn2339/_index.html) - Apple\n\nHappy Coding ðŸš€","title":"Automating your iOS App Development Workflow: Continuous Testing with GitHub Actions","description":"Are you striving to iterate quickly to deliver new features,\n            all while ensuring the reliability and performance of your iOS application? \n            Efficient workflows are key to achiving this goal. In this article, we'll \n            explore how we can leverage the power of Github Actions to automate testing \n            of iOS applications.","images":[]}},"__N_SSG":true}