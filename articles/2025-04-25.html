<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1.0" data-next-head=""/><meta property="og:type" content="website" data-next-head=""/><meta property="og:locale" content="en_US" data-next-head=""/><title data-next-head="">Mono-Repo Migration: Boosting Developer Productivity While Keeping Git History Intact</title><meta name="robots" content="index,follow" data-next-head=""/><meta name="description" content="Modularization is essential for scaling large software projects, enabling faster 
            development and better maintainability. However, when modules are split across multiple 
            repositories, developer productivity can suffer due to the overhead of coordinating changes 
            across projects. In this article, we explore how transitioning to a Mono-Repo can streamline 
            collaboration and demonstrate a Python script to automate the migration process." data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:site" content="@site" data-next-head=""/><meta name="twitter:creator" content="@handle" data-next-head=""/><meta property="og:title" content="Mono-Repo Migration: Boosting Developer Productivity While Keeping Git History Intact" data-next-head=""/><meta property="og:description" content="Modularization is essential for scaling large software projects, enabling faster 
            development and better maintainability. However, when modules are split across multiple 
            repositories, developer productivity can suffer due to the overhead of coordinating changes 
            across projects. In this article, we explore how transitioning to a Mono-Repo can streamline 
            collaboration and demonstrate a Python script to automate the migration process." data-next-head=""/><meta property="og:url" content="https://www.linkandreas.de/articles/2025-04-25" data-next-head=""/><meta property="og:image" content="https://www.linkandreas.de/images/previews/2025-04-25.jpeg" data-next-head=""/><meta property="og:image:alt" content="Link Preview Image" data-next-head=""/><meta property="og:image:width" content="1200" data-next-head=""/><meta property="og:image:height" content="630" data-next-head=""/><meta property="og:site_name" content="Andreas Link" data-next-head=""/><link rel="canonical" href="https://www.linkandreas.de/articles/2025-04-25" data-next-head=""/><link rel="alternate" type="application/rss+xml" title="linkandreas.de" href="https://linkandreas.de/rss"/><script id="show-banner" data-nscript="beforeInteractive">(function (w,d) {var loader = function () {var s = d.createElement("script"), tag = d.getElementsByTagName("script")[0]; s.src="https://cdn.iubenda.com/iubenda.js"; tag.parentNode.insertBefore(s,tag);}; if(w.addEventListener){w.addEventListener("load", loader, false);}else if(w.attachEvent){w.attachEvent("onload", loader);}else{w.onload = loader;}})(window, document);</script><link rel="preload" href="/_next/static/css/44be9a558f814fbc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/44be9a558f814fbc.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c7e751a366bdd662.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c7e751a366bdd662.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-055d654813485002.js" defer=""></script><script src="/_next/static/chunks/framework-5757d75364ce2279.js" defer=""></script><script src="/_next/static/chunks/main-26ea3299654e380a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a3ee1b13dc5bba02.js" defer=""></script><script src="/_next/static/chunks/587-5f9d9739613bfa25.js" defer=""></script><script src="/_next/static/chunks/881-256a47b766c2830f.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bid%5D-08b52d6dea500653.js" defer=""></script><script src="/_next/static/yuTCw0a2ewunNGYLxVodA/_buildManifest.js" defer=""></script><script src="/_next/static/yuTCw0a2ewunNGYLxVodA/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App_appContainer__O9sO8"><div class="container-fluid"><nav class="navbar navbar-expand-md navbar-dark bg-transparent"><a class="navbar-brand" href="/articles">Andreas Link</a><button aria-controls="responsive-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="responsive-navbar-nav"><div class="ml-auto navbar-nav"><a data-rr-ui-event-key="/articles" class="nav-link" href="/articles">Articles</a><a data-rr-ui-event-key="/licenses" class="nav-link" href="/licenses">Licenses</a><a data-rr-ui-event-key="/timity" class="nav-link" href="/timity">Timity</a><a data-rr-ui-event-key="/publications" class="nav-link" href="/publications">Publications</a><a data-rr-ui-event-key="/about" class="nav-link" href="/about">About</a></div></div></nav></div><div class="App_content__e_Cib"><div class="_id__articleContainer__MKOgu"><h1>Mono-Repo Migration: Boosting Developer Productivity While Keeping Git History Intact</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Large software projects require modular codebases to ensure scalability and maintainability of the application. As a result, we can deal with an increased number of customer requests and deliver features on tight schedules.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">While modularization is a powerful tool, it may also have a negative impact on developer productivity. This is the case when the application is structured in packages managed in different repositories. Then the overhead caused by managing multiple pull requests becomes significant, when features require changes in the main project as well as other in-house dependencies.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">In this article, we discuss how we can overcome these issues by transitioning to a Mono-Repo and demonstrate a python script to automate a Mono-Repo migration.</p>
<h2>Advantages of a Monorepo for Projects with Multiple In-House Dependencies</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">When changes often affect the project as well as its in-house dependencies, a Mono-Repo may be preferred. Developers can include changes in a single pull request and gain a better understanding of the changes required among packages, hence leading to better cross-team awareness.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">As an example, consider the following approaches:</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_25_04_2025_scenario.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">While three pull requests are necessary to apply changes to the main project as well as its dependencies when using a <em>Multi-Repo</em>, the <em>Mono-Repo</em> only requires a single pull request.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Even though git operations may become slower, using a Mono-Repo pays off when additional constraints like <code node="[object Object]">Stale Approval dismissal</code> are in place.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Since a Mono-Repo migration has a significant impact on the entire code base, the transition needs to be well thought through; ideally automated using a script. With the latter we can run the migration locally without affecting any remote repository. In addition, changes are reviewed via pull-requests before they are integrated into the <code node="[object Object]">main</code> and <code node="[object Object]">develop</code> branch.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Let&#x27;s briefly discuss the overall concept of how to approach a Mono-Repo migration.</p>
<h2>Concept</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">For demonstration purposes, we consider a <code node="[object Object]">Main</code> repository, which depends on two in-house repositories: <code node="[object Object]">Dependency 1</code> and <code node="[object Object]">Dependency 2</code>. All repositories follow  Git Flow, using <code node="[object Object]">main</code> and <code node="[object Object]">develop</code> as their primary branches. Feature branches are created from <code node="[object Object]">develop</code> and merged back into it upon completion.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_25_04_2025_context.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The goal is to consolidate the Git history of all three repositories into the <code node="[object Object]">Main</code> repository. This is made possible by Gitâ€™s ability to merge branches from unrelated hierarchies. By adding each dependency as a remote, we can directly merge their key branches (such as <code node="[object Object]">main</code> and <code node="[object Object]">develop</code>) into the corresponding branches of the <code node="[object Object]">Main</code> repository.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Before merging, a <em>preparation step</em> is required to minimize potential conflicts. This involves:</p>
<ul>
<li>Removing redundant or duplicate files common across repositories (e.g., <code node="[object Object]">.gitignore</code>), keeping only those from the <code node="[object Object]">Main</code> repository.</li>
<li>Restructuring the folder layout of each dependency to prevent file path collisions.</li>
<li>Migrating and renaming existing tags from the dependencies by prefixing them with the respective project names to retain traceability.</li>
</ul>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">As soon as dependencies are prepared we merge their respective <code node="[object Object]">main</code> branch into <code node="[object Object]">develop</code> to avoid merge-conflicts after all repos have been merged to the <code node="[object Object]">Main</code> repository. Otherwise, conflicts will arise after the integration when we try to merge <code node="[object Object]">main</code> into <code node="[object Object]">develop</code>.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_25_04_2025_preparation.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Next, the <em>preparation branches</em> are merged into dedicated <em>integration branches</em>, from which pull requests are created to review the changes introduced during the mono-repo transition. Maintaining the full Git history of each dependency is essential for traceability. This is accomplished by using the <code node="[object Object]">--allow-unrelated-histories</code> flag during the merge process. The migration concludes with the final merge of these pull requests into the <code node="[object Object]">Main</code> repository.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_25_04_2025_integration.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">After outlining the migration concept, let&#x27;s introduce the Python script designed to assist with the migration.</p>
<h2>Migration Script</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The migration script is crucial to ensure that all necessary steps are performed in the right order. While manual migration might be feasible for smaller projects, it becomes too error-prone and impractical for larger codebases.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Consider the following repositories to demonstrate how the migration script is built:</p>
<ul>
<li>Repositories:<!-- -->
<ul>
<li>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><code node="[object Object]">Main</code>:</p>
<ul>
<li>MonoRepoMigration_Main</li>
<li>URL: <a href="https://github.com/LinkAndreas/MonoRepoMigration_Main">https://github.com/LinkAndreas/MonoRepoMigration_Main</a></li>
</ul>
</li>
<li>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><code node="[object Object]">Dependency 1</code>:</p>
<ul>
<li>MonoRepoMigration_Dependency1<!-- -->
<ul>
<li>URL: <a href="https://github.com/LinkAndreas/MonoRepoMigration_Dependency1">https://github.com/LinkAndreas/MonoRepoMigration_Dependency1</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><code node="[object Object]">Dependency 2</code>:</p>
<ul>
<li>MonoRepoMigration_Dependency2<!-- -->
<ul>
<li>URL: <a href="https://github.com/LinkAndreas/MonoRepoMigration_Dependency2">https://github.com/LinkAndreas/MonoRepoMigration_Dependency2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">We consider the <code node="[object Object]">Main</code> repository as well as its in-house dependencies <code node="[object Object]">Dependency1</code> and <code node="[object Object]">Dependency2</code>. When the migration is done, we expect both dependencies to be integrated into the <code node="[object Object]">Main</code> repository according to the following structure:</p>
<ul>
<li>Structure:<!-- -->
<ul>
<li><code node="[object Object]">./...</code></li>
<li><code node="[object Object]">./Sources/Dependency1/...</code></li>
<li><code node="[object Object]">./Sources/Dependency2/...</code></li>
</ul>
</li>
</ul>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Since source code from <code node="[object Object]">Dependency1</code> is placed in its root directory, the folder structure needs to be adjusted such that all top-level files and directories are moved into <code node="[object Object]">./Sources/Dependency1</code>. Similar we proceed with <code node="[object Object]">Dependency2</code>. This way, we avoid merge conflicts when integrating dependencies into the <code node="[object Object]">Main</code> repository.</p>
<h2>Steps</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Let&#x27;s begin by defining an abstract Python class to represent a step within the migration:</p>
<pre><code class="language-py" node="[object Object]">from abc import ABC, abstractmethod

class MigrationStep(ABC):
    def __init__(self, title: str):
        self.title = title

    @abstractmethod
    def execute(self) -&gt; None:
        &quot;&quot;&quot;Execute migration step.&quot;&quot;&quot;
        pass
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Any <code node="[object Object]">MigrationStep</code> consists of a <code node="[object Object]">title</code> as well es the <code node="[object Object]">action</code> that should be done. Using this abstract class we can structure the migration into unique steps.</p>
<h3>Cleanup</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">First, the <code node="[object Object]">CleanupStep</code> ensures that all artifacts from previous migrations are removed before the migration starts. Otherwise, artifacts of a previous run may interfere with the current run. To ensure a clean context, it suffices to remove all repository directories.</p>
<pre><code class="language-py" node="[object Object]">from config import Repository
from utils import remove_directory
from steps.migration_step import MigrationStep

class CleanupStep(MigrationStep):
    def __init__(self, title: str, repositories: list[Repository]):
        self.repositories = repositories

        super().__init__(title)

    def execute(self) -&gt; None:
        for repo in self.repositories:
            remove_directory(repo.path)
            print(f&#x27;Removed {repo.name} repository.&#x27;)
</code></pre>
<h3>Clone Repositories</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Next, the <code node="[object Object]">CloneRepositoriesStep</code> clones all repositories passed via its initializer. In this case the <code node="[object Object]">Main</code> , <code node="[object Object]">Dependency1</code> and <code node="[object Object]">Dependency2</code> Repositories are cloned into the same directory where the <code node="[object Object]">migration_script.py</code> script is run.</p>
<pre><code class="language-py" node="[object Object]">from typing import Dict, Any, List
from config import REPOSITORIES
from steps.migration_step import MigrationStep
from utils import git_clone, process_items_with_breaks

class CloneRepositoriesStep(MigrationStep):
    def __init__(self, title: str, repositories: List[Any] = REPOSITORIES):
        super().__init__(title)
        self.repositories = repositories

    def execute(self) -&gt; None:
        &quot;&quot;&quot;Clone all repositories.&quot;&quot;&quot;
        process_items_with_breaks(self.repositories, git_clone)
</code></pre>
<h3>Determine Submodule References</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Before starting with package preparation, we need to determine commit hashes of the submodules that are referenced from the main repository. Otherwise, when taking the latest commit, the source code may mismatch leading to compilation issues.</p>
<pre><code class="language-py" node="[object Object]">from config import MONO_REPO, PACKAGES, BRANCHES
from utils import process_items_with_breaks, run_in_repo
from steps.migration_step import MigrationStep
from typing import Dict, Any, Callable

class DetermineSubmoduleReferencesStep(MigrationStep):
    def __init__(self, title: str, completion: Callable[[Dict[str, Dict[str, str]]], None]):
        self.completion = completion
        super().__init__(title)

    def execute(self):
        references: Dict[str, Dict[str, str]] = {
            &#x27;develop&#x27;: {},
            &#x27;main&#x27;: {}
        }

        def process_branch(branch: str):
            run_in_repo(MONO_REPO, f&#x27;git checkout {branch}&#x27;)
            for package in PACKAGES:
                commit_hash = run_in_repo(
                    MONO_REPO,
                    f&#x27;git ls-tree {branch} {package.submodulePath} | grep commit | awk \&#x27;{{print $3}}\&#x27;&#x27;,
                    print_output=False
                )
                references[branch][package.name] = commit_hash
                print(f&#x27;[{branch}] Found {package.name} Git-Submodule Reference: {commit_hash}&#x27;)

        process_items_with_breaks(BRANCHES, process_branch)
        self.completion(references)
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The <code node="[object Object]">git ls-tree</code> command returns the referenced commit hash given the branch as well as the submodule&#x27;s name. All hashes are stored in the <code node="[object Object]">references</code> dictionary to be later accessed by the preparation step.</p>
<h3>Prepare Packages</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The <code node="[object Object]">PreparePackagesStep</code> is responsible to restructure dependencies to ensure seamless integration into the primary repository. This process involves relocating all files from the root directory to subdirectories to minimize merge conflicts during integration. Furthermore, tags are prefixed with the dependency&#x27;s name to facilitate easy identification within the main repository. Notably, any redundant files such as <code node="[object Object]">swift-lint/-format</code> configurations or <code node="[object Object]">.gitignore</code> files are pruned to keep dependencies lean and organized.</p>
<pre><code class="language-py" node="[object Object]">import os
import uuid
from config import PACKAGES, BRANCHES, BRANCH_NAMES
from utils import process_items_with_breaks, run_in_repo, git_merge, git_commit_all, remove_directory
from steps.migration_step import MigrationStep
from typing import Dict, Any

class PreparePackagesStep(MigrationStep):
    def __init__(self, title: str, submodule_references: Dict[str, Any]):
        self.submodule_references = submodule_references

        super().__init__(title)

    def _cleanup_package_files(self, package):
        &quot;&quot;&quot;Remove package-specific configuration files.&quot;&quot;&quot;
        paths_to_remove = [
            &#x27;.swiftformat&#x27;,
            &#x27;.swiftlint.yml&#x27;,
            &#x27;.gitignore&#x27;
        ]

        for path in paths_to_remove:
            full_path = os.path.join(package.path, path)
            if os.path.exists(full_path):
                try:
                    remove_directory(full_path)
                    git_commit_all(package, f&#x27;Remove {path}&#x27;)
                    print(f&#x27;Removed {path}&#x27;)
                except Exception as e:
                    print(f&#x27;Warning: Could not remove {path}: {e}&#x27;)
            else:
                print(f&#x27;Skipping removal of{path} - file does not exist&#x27;)

    def execute(self) -&gt; None:
        def prepare_package(package):
            print(f&#x27;Preparing {package.name}...&#x27;)
            run_in_repo(package, &#x27;git fetch --all&#x27;)
            run_in_repo(package, f&#x27;&#x27;&#x27;git tag -l | while read t; do n=&quot;{package.name}/$t&quot;; git tag $n $t; git tag -d $t; done&#x27;&#x27;&#x27;)

            for branch in BRANCHES:
                run_in_repo(package, &#x27;git config advice.detachedHead false&#x27;)
                commit_hash = self.submodule_references[branch][package.name]
                print(f&#x27;Checkout Commit {commit_hash} in {package.name}&#x27;)
                run_in_repo(package, f&#x27;git checkout {commit_hash}&#x27;)

                preparation_branch = BRANCH_NAMES.preparation(branch)
                run_in_repo(package, f&#x27;git checkout -b {preparation_branch}&#x27;)

                def introduceSourcesSubDirectory():
                    target_dir = str(uuid.uuid4())
                    run_in_repo(package, f&#x27;mkdir {target_dir}&#x27;)
                    excluded = [target_dir, &#x27;.git&#x27;, &#x27;.gitignore&#x27;]
                    for file_name in [file_name for file_name in os.listdir(package.path) if file_name not in excluded]:
                        run_in_repo(package, f&#x27;git mv {file_name} {target_dir}/{file_name}&#x27;)
                    run_in_repo(package, f&#x27;git mv {target_dir} {package.name}&#x27;)
                    run_in_repo(package, f&#x27;mkdir Sources&#x27;)
                    run_in_repo(package, f&#x27;git mv {package.name} Sources/{package.name}&#x27;)

                introduceSourcesSubDirectory()
                print(f&#x27;Introduced Sources/{package.name} Sub-Directory&#x27;)
                git_commit_all(package, message=f&#x27;Introduced subdirectory /Sources/{package.name}&#x27;)

                self._cleanup_package_files(package)

            git_merge(package, BRANCH_NAMES.preparation(&#x27;main&#x27;), BRANCH_NAMES.preparation(&#x27;develop&#x27;))

        process_items_with_breaks(PACKAGES, prepare_package)
</code></pre>
<h3>Add Remotes</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">As soon as all packages are prepared, we can add each in-house dependency as a remote of the main repository. By establishing this connection, it is possible to merge the <code node="[object Object]">main</code> as well as <code node="[object Object]">develop</code> branch in their respective counterparts in the <code node="[object Object]">Main</code> repository. By fetching we ensure that we are up-to-date with the latest changes from the remote repository.</p>
<pre><code class="language-py" node="[object Object]">from config import MONO_REPO, PACKAGES
from utils import run_in_repo
from steps.migration_step import MigrationStep

class AddPackageRemotesStep(MigrationStep):
    def __init__(self, title: str):
        super().__init__(title)

    def execute(self) -&gt; None:
        for package in PACKAGES:
            run_in_repo(MONO_REPO, f&#x27;git remote add {package.name} ../{package.path}&#x27;)
            run_in_repo(MONO_REPO, f&#x27;git fetch {package.name}&#x27;)
            print(f&#x27;Added remote and fetched branches: {package.name}&#x27;)
</code></pre>
<h3>Merge Packages</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Next, integration branches are created in the <code node="[object Object]">Main</code> repository, which are later merged into the repositoryâ€™s primary branches. These intermediate branches allow us to review all changes before finalizing the migration. Finally, we preserve each dependencyâ€™s commit history by merging with the <code node="[object Object]">--allow-unrelated-histories</code> flag.</p>
<pre><code class="language-py" node="[object Object]">from config import MONO_REPO, PACKAGES, BRANCHES, BRANCH_NAMES
from utils import process_items_with_breaks, run_in_repo, git_commit_all
from steps.migration_step import MigrationStep

class MergePackagesStep(MigrationStep):
    def __init__(self, title: str):
        super().__init__(title)

    def _remove_submodules(self):
        &quot;&quot;&quot;Remove all submodules from the mono repository for all branches.&quot;&quot;&quot;
        print(&#x27;Removing submodules from mono repository...&#x27;)

        for package in PACKAGES:
            try:
                submodule_exists = run_in_repo(
                    MONO_REPO,
                    f&#x27;git config --file .gitmodules --get submodule.{package.submodulePath}.url&#x27;,
                    print_output=False
                )

                if not submodule_exists:
                    print(f&#x27;Submodule {package.name} does not exist, skipping...&#x27;)
                    continue

                run_in_repo(MONO_REPO, f&#x27;git submodule deinit -f {package.submodulePath}&#x27;)
                run_in_repo(MONO_REPO, f&#x27;rm -rf .git/modules/{package.submodulePath}&#x27;)
                run_in_repo(MONO_REPO, f&#x27;git rm -f {package.submodulePath}&#x27;)
                git_commit_all(MONO_REPO, f&#x27;Remove submodule {package.name}&#x27;)
                print(f&#x27;Removed submodule: {package.name}&#x27;)
            except Exception as e:
                print(f&#x27;Warning: Could not remove submodule {package.name}: {e}&#x27;)
                continue

    def execute(self) -&gt; None:
        def merge_branch(branch: str):
            print(f&#x27;Processing {branch} branch...&#x27;)
            integration_branch = BRANCH_NAMES.integration(branch)
            run_in_repo(MONO_REPO, f&#x27;git checkout {branch}&#x27;)
            run_in_repo(MONO_REPO, f&#x27;git checkout -b {integration_branch}&#x27;)

            self._remove_submodules()

            for package in PACKAGES:
                run_in_repo(
                    MONO_REPO,
                    f&#x27;git merge {package.name}/{BRANCH_NAMES.preparation(branch)} --quiet --no-ff --allow-unrelated-histories&#x27;
                )
                print(f&#x27;Merged: {package.name}/{BRANCH_NAMES.preparation(branch)} -&gt; {integration_branch}&#x27;)

        process_items_with_breaks(BRANCHES, merge_branch)
</code></pre>
<h3>Remove Remotes</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">As soon as submodules are integrated their remotes are removed from the main repository.</p>
<pre><code class="language-py" node="[object Object]">from config import MONO_REPO, PACKAGES
from utils import run_in_repo
from steps.migration_step import MigrationStep

class RemovePackageRemotesStep(MigrationStep):
    def __init__(self, title: str):
        super().__init__(title)

    def execute(self) -&gt; None:
        for package in PACKAGES:
            run_in_repo(MONO_REPO, f&#x27;git remote remove {package.name}&#x27;)
            print(f&#x27;Removed remote: {package.name}&#x27;)
</code></pre>
<h1>Migration</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Having outlined all the steps required for a monorepo migration, we can now implement a dedicated <code node="[object Object]">MonoRepoMigration</code> class responsible for executing them in sequence. While most steps operate solely on input, the <code node="[object Object]">DetermineSubmoduleReferencesStep</code> includes a completion handler to communicate the discovered submodules. Itâ€™s important to note that the migration process does not push any changes to the remote repository. Instead, all operations are performed locally on device. Once everything has been verified and works as expected, the integration branches can be pushed to the remote to create pull requests and finalize the migration.</p>
<pre><code class="language-py" node="[object Object]">#!/usr/bin/env python3

from typing import Dict, List
from config import REPOSITORIES, PACKAGES
from utils import withExecutionTimeMeasurement, perform_action
from steps.migration_step import MigrationStep
from steps import (
    CleanupStep,
    CloneRepositoriesStep,
    DetermineSubmoduleReferencesStep,
    PreparePackagesStep,
    AddPackageRemotesStep,
    MergePackagesStep,
    RemovePackageRemotesStep
)

class MonoRepoMigration:
    def __init__(self):
        self.submodule_references: Dict[str, Dict[str, str]] = {}

    def run(self):
        &quot;&quot;&quot;Execute the complete migration process.&quot;&quot;&quot;
        def execute_migration():
            # Define steps
            steps: List[MigrationStep] = [
                CleanupStep(
                    title=&#x27;Pre-Migration Cleanup&#x27;,
                    repositories=REPOSITORIES
                ),
                CloneRepositoriesStep(
                    title=&#x27;Cloning Repositories&#x27;,
                    repositories=REPOSITORIES
                ),
                DetermineSubmoduleReferencesStep(
                    title=&#x27;Determining Submodule References&#x27;,
                    completion=lambda value: self.submodule_references.update(value)
                ),
                PreparePackagesStep(
                    title=&#x27;Preparing Packages&#x27;,
                    submodule_references=self.submodule_references
                ),
                AddPackageRemotesStep(
                    title=&#x27;Adding Package Remotes&#x27;
                ),
                MergePackagesStep(
                    title=&#x27;Merging Packages&#x27;
                ),
                RemovePackageRemotesStep(
                    title=&#x27;Removing Package Remotes&#x27;
                ),
                CleanupStep(
                    title=&#x27;Post-Migration Cleanup&#x27;,
                    repositories=PACKAGES
                )
            ]

            # Perform each step
            for step in steps:
                perform_action(step.title, step.execute)

        withExecutionTimeMeasurement(
            action_name=&#x27;Migration&#x27;,
            action=execute_migration
        )

if __name__ == &quot;__main__&quot;:
    migration = MonoRepoMigration()
    migration.run()
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Below you can find all constants that are used by the migration script. This way, we can define the <code node="[object Object]">Main</code> repository as well as its in-house dependencies and the primary branches involved in the migration.</p>
<pre><code class="language-py" node="[object Object]">#!/usr/bin/env python3

from dataclasses import dataclass
from typing import Callable

@dataclass
class BranchNames:
    preparation: Callable[[str], str]
    integration: Callable[[str], str]

@dataclass
class Repository:
    name: str
    url: str
    path: str
    submoduleName: str | None
    submodulePath: str | None

# Branch naming configuration
BRANCH_NAMES = BranchNames(
    preparation=lambda branch: f&#x27;feature/Prepare-Repository-{branch}&#x27;,
    integration=lambda branch: f&#x27;feature/Integrate-Repository-{branch}&#x27;
)

# Repository configurations
MONO_REPO = Repository(
    name=&#x27;Main&#x27;,
    url=&#x27;git@github.com:LinkAndreas/MonoRepoMigration_Main.git&#x27;,
    path=&#x27;MonoRepoMigration_Main&#x27;,
    submoduleName=None,
    submodulePath=None
)

PACKAGES = [
    Repository(
        name=&#x27;Dependency1&#x27;,
        url=&#x27;git@github.com:LinkAndreas/MonoRepoMigration_Dependency1.git&#x27;,
        path=&#x27;MonoRepoMigration_Dependency1&#x27;,
        submoduleName=&#x27;Dependency1&#x27;,
        submodulePath=&#x27;Sources/Dependency1&#x27;
    ),
    Repository(
        name=&#x27;Dependency2&#x27;,
        url=&#x27;git@github.com:LinkAndreas/MonoRepoMigration_Dependency2.git&#x27;,
        path=&#x27;MonoRepoMigration_Dependency2&#x27;,
        submoduleName=&#x27;Dependency2&#x27;,
        submodulePath=&#x27;Sources/Dependency2&#x27;
    )
]

# Combined repositories list
REPOSITORIES = [MONO_REPO] + PACKAGES

# Branch configurations
BRANCHES = [&quot;develop&quot;, &quot;main&quot;]
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">For the sake of completeness, the following table contains all utility methods used throughout the migration:</p>
<table node="[object Object]" class="TableRenderer_tableBlock__g214N"><thead><tr><th>Method</th><th>Purpose</th></tr></thead><tbody><tr><td><code node="[object Object]">run_command(...)</code></td><td>Runs a shell command and returns the output.</td></tr><tr><td><code node="[object Object]">run_in_repo(...)</code></td><td>Runs a command inside a given Git repo.</td></tr><tr><td><code node="[object Object]">process_items_with_breaks(...)</code></td><td>Processes items, with optional line breaks.</td></tr><tr><td><code node="[object Object]">remove_directory(...)</code></td><td>Deletes a directory and its contents.</td></tr><tr><td><code node="[object Object]">perform_action(...)</code></td><td>Logs and runs a titled action.</td></tr><tr><td><code node="[object Object]">git_clone(...)</code></td><td>Clones a Git repo with submodules.</td></tr><tr><td><code node="[object Object]">git_merge(...)</code></td><td>Merges one branch into another.</td></tr><tr><td><code node="[object Object]">git_commit_all(...)</code></td><td>Stages and commits all repo changes.</td></tr><tr><td><code node="[object Object]">withExecutionTimeMeasurement(...)</code></td><td>Times and logs how long an action takes.</td></tr></tbody></table>
<pre><code class="language-py" node="[object Object]">from datetime import datetime
from subprocess import Popen, PIPE
from typing import List, Callable, Any
from config import Repository

def run_command(command: str, print_output: bool = True) -&gt; str:
    &quot;&quot;&quot;Execute a shell command and return its output.&quot;&quot;&quot;
    command = f&#x27;set -Eeuo pipefail &amp;&amp; {command}&#x27;
    process = Popen(command, stdout=PIPE, shell=True, text=True)
    lines = []

    while True:
        line = process.stdout.readline().rstrip()
        if not line:
            break
        lines.append(line)
        if print_output:
            print(line)

    output = &quot;\n&quot;.join(lines)
    process.communicate()

    if process.returncode != 0:
        raise Exception(f&quot;Command failed with exit code {process.returncode}: {command}&quot;)

    return output

def run_in_repo(repo: Repository, command: str, print_output: bool = True) -&gt; str:
    &quot;&quot;&quot;Execute a command in the context of a repository.&quot;&quot;&quot;
    return run_command(f&#x27;(cd {repo.path} &amp;&amp; {command})&#x27;, print_output)

def process_items_with_breaks(items: List, action: Callable, show_breaks: bool = True) -&gt; None:
    &quot;&quot;&quot;Process a list of items with optional line breaks between them.&quot;&quot;&quot;
    for index, item in enumerate(items):
        action(item)
        if show_breaks and index &lt; len(items) - 1:
            print(&#x27;&#x27;)

def remove_directory(path: str) -&gt; None:
    &quot;&quot;&quot;Safely remove a directory and its contents.&quot;&quot;&quot;
    run_command(f&#x27;rm -rf {path}&#x27;)

def perform_action(title: str, action: Callable) -&gt; Any:
    &quot;&quot;&quot;Execute an action with formatted logging.&quot;&quot;&quot;
    print(f&quot;\n=============== {title} ===============\n&quot;)
    result = action()
    print(&quot;=&quot; * (len(title) + 32))
    return result

def git_clone(repo: Repository) -&gt; None:
    &quot;&quot;&quot;Clone a git repository.&quot;&quot;&quot;
    run_command(f&#x27;git clone {repo.url} --progress --recursive&#x27;)

def git_merge(repo: Repository, source: str, destination: str) -&gt; None:
    &quot;&quot;&quot;Merge branches in a repository.&quot;&quot;&quot;
    run_in_repo(repo, f&#x27;git checkout {destination}&#x27;)
    run_in_repo(repo, f&#x27;git merge {source} --strategy=ours --quiet --no-ff --no-edit&#x27;)
    print(f&#x27;Merged {source} -&gt; {destination}&#x27;)

def git_commit_all(repo: Repository, message: str) -&gt; None:
    &quot;&quot;&quot;Commit all changes in a repository.&quot;&quot;&quot;
    run_in_repo(repo, f&#x27;git add -A&#x27;)
    run_in_repo(repo, f&#x27;git commit --quiet -m &quot;{message}&quot;&#x27;)

def withExecutionTimeMeasurement(action_name: str, action: Callable) -&gt; Any:
    &quot;&quot;&quot;Measure and print execution time of an action&quot;&quot;&quot;
    start_time = datetime.now()
    print(f&#x27;Starting {action_name}...\n&#x27;)

    result = action()

    duration = (datetime.now() - start_time).total_seconds()
    print(f&#x27;\nFinished {action_name} in {duration:.2f} seconds.&#x27;)
    return result
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Before concluding this article, we present a structured approach for executing the mono-repo migration in a coordinated and controlled manner.</p>
<h2>Procedure</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">While the migration script enables local testing, completing the migration requires a coordinated effort among team members.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Below, youâ€™ll find the key steps to follow before, during, and after the migration. Although the exact procedure may vary depending on your specific context, this guide can serve as a blueprint to help you successfully initiate and manage your own migration process.</p>
<h3>Pre-migration</h3>
<ol>
<li>Identify a suitable time window for the migration<!-- -->
<ul>
<li>If youâ€™re working in sprints, the beginning of a sprint is often ideal, as thereâ€™s typically less delivery pressure compared to the end.</li>
</ul>
</li>
<li>Request all developers to merge their open pull requests by a fixed deadline<!-- -->
<ul>
<li>This ensures a clean state and minimizes merge conflicts during the migration.</li>
</ul>
</li>
</ol>
<h3>Migration</h3>
<ol>
<li>Notify the team that the migration is about to begin.</li>
<li>Temporarily freeze all merges to <code node="[object Object]">main</code> and <code node="[object Object]">develop</code> during the migration process.</li>
<li>Merge the latest changes from <code node="[object Object]">main</code> into <code node="[object Object]">develop</code>
<ul>
<li>This ensures that any hotfixes or bugfixes are synchronized with the ongoing development branch.</li>
</ul>
</li>
<li>Run the <strong>migration script</strong> on a developer machine with access to all required repositories<!-- -->
<ul>
<li>After execution, review the logs to ensure there were no errors.</li>
<li>Verify the migration result by checking the branch and commit history in your Git client.</li>
</ul>
</li>
<li>Create pull requests from the integration branches generated by the script.</li>
<li>Have your team review the changes introduced during the migration.</li>
<li>Merge the integration branches into <code node="[object Object]">develop</code> and <code node="[object Object]">main</code>.</li>
<li>Push any migrated tags to the main repository.</li>
</ol>
<h3>Post-migration</h3>
<ol>
<li>Announce to the team that the migration is complete.</li>
<li>Archive or restrict access to the now-obsolete repositories.</li>
<li>Re-enable merges into <code node="[object Object]">main</code> and <code node="[object Object]">develop</code>.</li>
</ol>
<h2>Conclusion</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">In this article, we examined the trade-offs between <code node="[object Object]">Mono-</code> and <code node="[object Object]">Multi-Repo</code> and introduced a structured approach to a <code node="[object Object]">Mono-Repo</code> migration. Consolidating repositories can significantly enhance developer productivity by minimizing cross-repository coordination and reducing the number of required pull requests. The provided migration script automates key steps, enabling repeatable and locally testable migrations without impacting the remote repository. Once validated, changes are submitted through dedicated pull requests, ensuring all modifications remain transparent, reviewable, and easy to track.</p>
<h2>References</h2>
<ul>
<li><a href="https://alexharri.com/blog/move-to-monorepo">Move to Mono-Repo</a> - Alex Harri</li>
<li><a href="https://choly.ca/post/git-merge-to-monorepo/">Git Merge to Mono-Repo</a> - Ilia Choly</li>
<li><a href="https://gfscott.com/blog/merge-git-repos-and-keep-commit-history/">Merge Git Repos and keep Commit History</a> - Graham F. Scott</li>
</ul>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Happy Coding ðŸš€</p></div></div><footer class="Footer_footer__JrJN9"><p>Made by<!-- --> <a class="inline" href="/about">Andreas Link</a> <!-- -->in Karlsruhe</p><div><div><a href="https://www.iubenda.com/privacy-policy/86928215" class="iubenda-black no-brand iubenda-noiframe iubenda-embed iubenda-noiframe ">Privacy Policy</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"2025-04-25","date":"Fri, 25 Apr 2025 00:00:00 +0000","markdown":"# Mono-Repo Migration: Boosting Developer Productivity While Keeping Git History Intact\n\nLarge software projects require modular codebases to ensure scalability and maintainability of the application. As a result, we can deal with an increased number of customer requests and deliver features on tight schedules.\n\nWhile modularization is a powerful tool, it may also have a negative impact on developer productivity. This is the case when the application is structured in packages managed in different repositories. Then the overhead caused by managing multiple pull requests becomes significant, when features require changes in the main project as well as other in-house dependencies.\n\nIn this article, we discuss how we can overcome these issues by transitioning to a Mono-Repo and demonstrate a python script to automate a Mono-Repo migration.\n\n## Advantages of a Monorepo for Projects with Multiple In-House Dependencies\n\nWhen changes often affect the project as well as its in-house dependencies, a Mono-Repo may be preferred. Developers can include changes in a single pull request and gain a better understanding of the changes required among packages, hence leading to better cross-team awareness.\n\nAs an example, consider the following approaches:\n\n![Scenarios](article_25_04_2025_scenario.png)\n\nWhile three pull requests are necessary to apply changes to the main project as well as its dependencies when using a *Multi-Repo*, the *Mono-Repo* only requires a single pull request.\n\nEven though git operations may become slower, using a Mono-Repo pays off when additional constraints like `Stale Approval dismissal` are in place.\n\nSince a Mono-Repo migration has a significant impact on the entire code base, the transition needs to be well thought through; ideally automated using a script. With the latter we can run the migration locally without affecting any remote repository. In addition, changes are reviewed via pull-requests before they are integrated into the `main` and `develop` branch.\n\nLet's briefly discuss the overall concept of how to approach a Mono-Repo migration.\n\n## Concept\n\nFor demonstration purposes, we consider a `Main` repository, which depends on two in-house repositories: `Dependency 1` and `Dependency 2`. All repositories follow  Git Flow, using `main` and `develop` as their primary branches. Feature branches are created from `develop` and merged back into it upon completion.\n\n![Context](article_25_04_2025_context.png)\n\nThe goal is to consolidate the Git history of all three repositories into the `Main` repository. This is made possible by Gitâ€™s ability to merge branches from unrelated hierarchies. By adding each dependency as a remote, we can directly merge their key branches (such as `main` and `develop`) into the corresponding branches of the `Main` repository.\n\nBefore merging, a *preparation step* is required to minimize potential conflicts. This involves:\n- Removing redundant or duplicate files common across repositories (e.g., `.gitignore`), keeping only those from the `Main` repository.\n- Restructuring the folder layout of each dependency to prevent file path collisions.\n- Migrating and renaming existing tags from the dependencies by prefixing them with the respective project names to retain traceability.\n\nAs soon as dependencies are prepared we merge their respective `main` branch into `develop` to avoid merge-conflicts after all repos have been merged to the `Main` repository. Otherwise, conflicts will arise after the integration when we try to merge `main` into `develop`.\n\n![Context](article_25_04_2025_preparation.png)\n\nNext, the *preparation branches* are merged into dedicated *integration branches*, from which pull requests are created to review the changes introduced during the mono-repo transition. Maintaining the full Git history of each dependency is essential for traceability. This is accomplished by using the `--allow-unrelated-histories` flag during the merge process. The migration concludes with the final merge of these pull requests into the `Main` repository.\n\n![Context](article_25_04_2025_integration.png)\n\nAfter outlining the migration concept, let's introduce the Python script designed to assist with the migration.\n\n## Migration Script\n\nThe migration script is crucial to ensure that all necessary steps are performed in the right order. While manual migration might be feasible for smaller projects, it becomes too error-prone and impractical for larger codebases. \n\nConsider the following repositories to demonstrate how the migration script is built:\n\n- Repositories:\n    - `Main`:\n        - MonoRepoMigration_Main\n        - URL: https://github.com/LinkAndreas/MonoRepoMigration_Main\n\n    - `Dependency 1`:\n        - MonoRepoMigration_Dependency1\n            - URL: https://github.com/LinkAndreas/MonoRepoMigration_Dependency1\n\n    - `Dependency 2`:\n        - MonoRepoMigration_Dependency2\n            - URL: https://github.com/LinkAndreas/MonoRepoMigration_Dependency2\n\nWe consider the `Main` repository as well as its in-house dependencies `Dependency1` and `Dependency2`. When the migration is done, we expect both dependencies to be integrated into the `Main` repository according to the following structure:\n\n- Structure:\n    - `./...`\n    - `./Sources/Dependency1/...`\n    - `./Sources/Dependency2/...`\n\nSince source code from `Dependency1` is placed in its root directory, the folder structure needs to be adjusted such that all top-level files and directories are moved into `./Sources/Dependency1`. Similar we proceed with `Dependency2`. This way, we avoid merge conflicts when integrating dependencies into the `Main` repository.\n\n## Steps\n\nLet's begin by defining an abstract Python class to represent a step within the migration:\n\n```py\nfrom abc import ABC, abstractmethod\n\nclass MigrationStep(ABC):\n    def __init__(self, title: str):\n        self.title = title\n\n    @abstractmethod\n    def execute(self) -\u003e None:\n        \"\"\"Execute migration step.\"\"\"\n        pass\n```\n\nAny `MigrationStep` consists of a `title` as well es the `action` that should be done. Using this abstract class we can structure the migration into unique steps.\n\n### Cleanup\n\nFirst, the `CleanupStep` ensures that all artifacts from previous migrations are removed before the migration starts. Otherwise, artifacts of a previous run may interfere with the current run. To ensure a clean context, it suffices to remove all repository directories.\n\n```py\nfrom config import Repository\nfrom utils import remove_directory\nfrom steps.migration_step import MigrationStep\n\nclass CleanupStep(MigrationStep):\n    def __init__(self, title: str, repositories: list[Repository]):\n        self.repositories = repositories\n\n        super().__init__(title)\n\n    def execute(self) -\u003e None:\n        for repo in self.repositories:\n            remove_directory(repo.path)\n            print(f'Removed {repo.name} repository.')\n```\n\n### Clone Repositories\n\nNext, the `CloneRepositoriesStep` clones all repositories passed via its initializer. In this case the `Main` , `Dependency1` and `Dependency2` Repositories are cloned into the same directory where the `migration_script.py` script is run.\n\n```py\nfrom typing import Dict, Any, List\nfrom config import REPOSITORIES\nfrom steps.migration_step import MigrationStep\nfrom utils import git_clone, process_items_with_breaks\n\nclass CloneRepositoriesStep(MigrationStep):\n    def __init__(self, title: str, repositories: List[Any] = REPOSITORIES):\n        super().__init__(title)\n        self.repositories = repositories\n\n    def execute(self) -\u003e None:\n        \"\"\"Clone all repositories.\"\"\"\n        process_items_with_breaks(self.repositories, git_clone)\n```\n\n### Determine Submodule References\n\nBefore starting with package preparation, we need to determine commit hashes of the submodules that are referenced from the main repository. Otherwise, when taking the latest commit, the source code may mismatch leading to compilation issues.\n\n```py\nfrom config import MONO_REPO, PACKAGES, BRANCHES\nfrom utils import process_items_with_breaks, run_in_repo\nfrom steps.migration_step import MigrationStep\nfrom typing import Dict, Any, Callable\n\nclass DetermineSubmoduleReferencesStep(MigrationStep):\n    def __init__(self, title: str, completion: Callable[[Dict[str, Dict[str, str]]], None]):\n        self.completion = completion\n        super().__init__(title)\n\n    def execute(self):\n        references: Dict[str, Dict[str, str]] = {\n            'develop': {},\n            'main': {}\n        }\n\n        def process_branch(branch: str):\n            run_in_repo(MONO_REPO, f'git checkout {branch}')\n            for package in PACKAGES:\n                commit_hash = run_in_repo(\n                    MONO_REPO,\n                    f'git ls-tree {branch} {package.submodulePath} | grep commit | awk \\'{{print $3}}\\'',\n                    print_output=False\n                )\n                references[branch][package.name] = commit_hash\n                print(f'[{branch}] Found {package.name} Git-Submodule Reference: {commit_hash}')\n\n        process_items_with_breaks(BRANCHES, process_branch)\n        self.completion(references)\n```\n\nThe `git ls-tree` command returns the referenced commit hash given the branch as well as the submodule's name. All hashes are stored in the `references` dictionary to be later accessed by the preparation step.\n\n### Prepare Packages\n\nThe `PreparePackagesStep` is responsible to restructure dependencies to ensure seamless integration into the primary repository. This process involves relocating all files from the root directory to subdirectories to minimize merge conflicts during integration. Furthermore, tags are prefixed with the dependency's name to facilitate easy identification within the main repository. Notably, any redundant files such as `swift-lint/-format` configurations or `.gitignore` files are pruned to keep dependencies lean and organized.\n\n```py\nimport os\nimport uuid\nfrom config import PACKAGES, BRANCHES, BRANCH_NAMES\nfrom utils import process_items_with_breaks, run_in_repo, git_merge, git_commit_all, remove_directory\nfrom steps.migration_step import MigrationStep\nfrom typing import Dict, Any\n\nclass PreparePackagesStep(MigrationStep):\n    def __init__(self, title: str, submodule_references: Dict[str, Any]):\n        self.submodule_references = submodule_references\n\n        super().__init__(title)\n\n    def _cleanup_package_files(self, package):\n        \"\"\"Remove package-specific configuration files.\"\"\"\n        paths_to_remove = [\n            '.swiftformat',\n            '.swiftlint.yml',\n            '.gitignore'\n        ]\n\n        for path in paths_to_remove:\n            full_path = os.path.join(package.path, path)\n            if os.path.exists(full_path):\n                try:\n                    remove_directory(full_path)\n                    git_commit_all(package, f'Remove {path}')\n                    print(f'Removed {path}')\n                except Exception as e:\n                    print(f'Warning: Could not remove {path}: {e}')\n            else:\n                print(f'Skipping removal of{path} - file does not exist')\n\n    def execute(self) -\u003e None:\n        def prepare_package(package):\n            print(f'Preparing {package.name}...')\n            run_in_repo(package, 'git fetch --all')\n            run_in_repo(package, f'''git tag -l | while read t; do n=\"{package.name}/$t\"; git tag $n $t; git tag -d $t; done''')\n\n            for branch in BRANCHES:\n                run_in_repo(package, 'git config advice.detachedHead false')\n                commit_hash = self.submodule_references[branch][package.name]\n                print(f'Checkout Commit {commit_hash} in {package.name}')\n                run_in_repo(package, f'git checkout {commit_hash}')\n\n                preparation_branch = BRANCH_NAMES.preparation(branch)\n                run_in_repo(package, f'git checkout -b {preparation_branch}')\n\n                def introduceSourcesSubDirectory():\n                    target_dir = str(uuid.uuid4())\n                    run_in_repo(package, f'mkdir {target_dir}')\n                    excluded = [target_dir, '.git', '.gitignore']\n                    for file_name in [file_name for file_name in os.listdir(package.path) if file_name not in excluded]:\n                        run_in_repo(package, f'git mv {file_name} {target_dir}/{file_name}')\n                    run_in_repo(package, f'git mv {target_dir} {package.name}')\n                    run_in_repo(package, f'mkdir Sources')\n                    run_in_repo(package, f'git mv {package.name} Sources/{package.name}')\n\n                introduceSourcesSubDirectory()\n                print(f'Introduced Sources/{package.name} Sub-Directory')\n                git_commit_all(package, message=f'Introduced subdirectory /Sources/{package.name}')\n\n                self._cleanup_package_files(package)\n\n            git_merge(package, BRANCH_NAMES.preparation('main'), BRANCH_NAMES.preparation('develop'))\n\n        process_items_with_breaks(PACKAGES, prepare_package)\n```\n\n### Add Remotes\n\nAs soon as all packages are prepared, we can add each in-house dependency as a remote of the main repository. By establishing this connection, it is possible to merge the `main` as well as `develop` branch in their respective counterparts in the `Main` repository. By fetching we ensure that we are up-to-date with the latest changes from the remote repository.\n\n```py\nfrom config import MONO_REPO, PACKAGES\nfrom utils import run_in_repo\nfrom steps.migration_step import MigrationStep\n\nclass AddPackageRemotesStep(MigrationStep):\n    def __init__(self, title: str):\n        super().__init__(title)\n\n    def execute(self) -\u003e None:\n        for package in PACKAGES:\n            run_in_repo(MONO_REPO, f'git remote add {package.name} ../{package.path}')\n            run_in_repo(MONO_REPO, f'git fetch {package.name}')\n            print(f'Added remote and fetched branches: {package.name}')\n```\n\n### Merge Packages\n\nNext, integration branches are created in the `Main` repository, which are later merged into the repositoryâ€™s primary branches. These intermediate branches allow us to review all changes before finalizing the migration. Finally, we preserve each dependencyâ€™s commit history by merging with the `--allow-unrelated-histories` flag.\n\n```py\nfrom config import MONO_REPO, PACKAGES, BRANCHES, BRANCH_NAMES\nfrom utils import process_items_with_breaks, run_in_repo, git_commit_all\nfrom steps.migration_step import MigrationStep\n\nclass MergePackagesStep(MigrationStep):\n    def __init__(self, title: str):\n        super().__init__(title)\n\n    def _remove_submodules(self):\n        \"\"\"Remove all submodules from the mono repository for all branches.\"\"\"\n        print('Removing submodules from mono repository...')\n\n        for package in PACKAGES:\n            try:\n                submodule_exists = run_in_repo(\n                    MONO_REPO,\n                    f'git config --file .gitmodules --get submodule.{package.submodulePath}.url',\n                    print_output=False\n                )\n\n                if not submodule_exists:\n                    print(f'Submodule {package.name} does not exist, skipping...')\n                    continue\n\n                run_in_repo(MONO_REPO, f'git submodule deinit -f {package.submodulePath}')\n                run_in_repo(MONO_REPO, f'rm -rf .git/modules/{package.submodulePath}')\n                run_in_repo(MONO_REPO, f'git rm -f {package.submodulePath}')\n                git_commit_all(MONO_REPO, f'Remove submodule {package.name}')\n                print(f'Removed submodule: {package.name}')\n            except Exception as e:\n                print(f'Warning: Could not remove submodule {package.name}: {e}')\n                continue\n\n    def execute(self) -\u003e None:\n        def merge_branch(branch: str):\n            print(f'Processing {branch} branch...')\n            integration_branch = BRANCH_NAMES.integration(branch)\n            run_in_repo(MONO_REPO, f'git checkout {branch}')\n            run_in_repo(MONO_REPO, f'git checkout -b {integration_branch}')\n\n            self._remove_submodules()\n\n            for package in PACKAGES:\n                run_in_repo(\n                    MONO_REPO,\n                    f'git merge {package.name}/{BRANCH_NAMES.preparation(branch)} --quiet --no-ff --allow-unrelated-histories'\n                )\n                print(f'Merged: {package.name}/{BRANCH_NAMES.preparation(branch)} -\u003e {integration_branch}')\n\n        process_items_with_breaks(BRANCHES, merge_branch)\n```\n\n### Remove Remotes\n\nAs soon as submodules are integrated their remotes are removed from the main repository.\n\n```py\nfrom config import MONO_REPO, PACKAGES\nfrom utils import run_in_repo\nfrom steps.migration_step import MigrationStep\n\nclass RemovePackageRemotesStep(MigrationStep):\n    def __init__(self, title: str):\n        super().__init__(title)\n\n    def execute(self) -\u003e None:\n        for package in PACKAGES:\n            run_in_repo(MONO_REPO, f'git remote remove {package.name}')\n            print(f'Removed remote: {package.name}')\n```\n\n# Migration\n\nHaving outlined all the steps required for a monorepo migration, we can now implement a dedicated `MonoRepoMigration` class responsible for executing them in sequence. While most steps operate solely on input, the `DetermineSubmoduleReferencesStep` includes a completion handler to communicate the discovered submodules. Itâ€™s important to note that the migration process does not push any changes to the remote repository. Instead, all operations are performed locally on device. Once everything has been verified and works as expected, the integration branches can be pushed to the remote to create pull requests and finalize the migration.\n\n```py\n#!/usr/bin/env python3\n\nfrom typing import Dict, List\nfrom config import REPOSITORIES, PACKAGES\nfrom utils import withExecutionTimeMeasurement, perform_action\nfrom steps.migration_step import MigrationStep\nfrom steps import (\n    CleanupStep,\n    CloneRepositoriesStep,\n    DetermineSubmoduleReferencesStep,\n    PreparePackagesStep,\n    AddPackageRemotesStep,\n    MergePackagesStep,\n    RemovePackageRemotesStep\n)\n\nclass MonoRepoMigration:\n    def __init__(self):\n        self.submodule_references: Dict[str, Dict[str, str]] = {}\n\n    def run(self):\n        \"\"\"Execute the complete migration process.\"\"\"\n        def execute_migration():\n            # Define steps\n            steps: List[MigrationStep] = [\n                CleanupStep(\n                    title='Pre-Migration Cleanup',\n                    repositories=REPOSITORIES\n                ),\n                CloneRepositoriesStep(\n                    title='Cloning Repositories',\n                    repositories=REPOSITORIES\n                ),\n                DetermineSubmoduleReferencesStep(\n                    title='Determining Submodule References',\n                    completion=lambda value: self.submodule_references.update(value)\n                ),\n                PreparePackagesStep(\n                    title='Preparing Packages',\n                    submodule_references=self.submodule_references\n                ),\n                AddPackageRemotesStep(\n                    title='Adding Package Remotes'\n                ),\n                MergePackagesStep(\n                    title='Merging Packages'\n                ),\n                RemovePackageRemotesStep(\n                    title='Removing Package Remotes'\n                ),\n                CleanupStep(\n                    title='Post-Migration Cleanup',\n                    repositories=PACKAGES\n                )\n            ]\n\n            # Perform each step\n            for step in steps:\n                perform_action(step.title, step.execute)\n\n        withExecutionTimeMeasurement(\n            action_name='Migration',\n            action=execute_migration\n        )\n\nif __name__ == \"__main__\":\n    migration = MonoRepoMigration()\n    migration.run()\n```\n\nBelow you can find all constants that are used by the migration script. This way, we can define the `Main` repository as well as its in-house dependencies and the primary branches involved in the migration.\n\n```py\n#!/usr/bin/env python3\n\nfrom dataclasses import dataclass\nfrom typing import Callable\n\n@dataclass\nclass BranchNames:\n    preparation: Callable[[str], str]\n    integration: Callable[[str], str]\n\n@dataclass\nclass Repository:\n    name: str\n    url: str\n    path: str\n    submoduleName: str | None\n    submodulePath: str | None\n\n# Branch naming configuration\nBRANCH_NAMES = BranchNames(\n    preparation=lambda branch: f'feature/Prepare-Repository-{branch}',\n    integration=lambda branch: f'feature/Integrate-Repository-{branch}'\n)\n\n# Repository configurations\nMONO_REPO = Repository(\n    name='Main',\n    url='git@github.com:LinkAndreas/MonoRepoMigration_Main.git',\n    path='MonoRepoMigration_Main',\n    submoduleName=None,\n    submodulePath=None\n)\n\nPACKAGES = [\n    Repository(\n        name='Dependency1',\n        url='git@github.com:LinkAndreas/MonoRepoMigration_Dependency1.git',\n        path='MonoRepoMigration_Dependency1',\n        submoduleName='Dependency1',\n        submodulePath='Sources/Dependency1'\n    ),\n    Repository(\n        name='Dependency2',\n        url='git@github.com:LinkAndreas/MonoRepoMigration_Dependency2.git',\n        path='MonoRepoMigration_Dependency2',\n        submoduleName='Dependency2',\n        submodulePath='Sources/Dependency2'\n    )\n]\n\n# Combined repositories list\nREPOSITORIES = [MONO_REPO] + PACKAGES\n\n# Branch configurations\nBRANCHES = [\"develop\", \"main\"]\n```\n\nFor the sake of completeness, the following table contains all utility methods used throughout the migration:\n\n| Method                           | Purpose                                         |\n|----------------------------------|-------------------------------------------------|\n| `run_command(...)`              | Runs a shell command and returns the output.   |\n| `run_in_repo(...)`             | Runs a command inside a given Git repo.        |\n| `process_items_with_breaks(...)`| Processes items, with optional line breaks.     |\n| `remove_directory(...)`        | Deletes a directory and its contents.           |\n| `perform_action(...)`          | Logs and runs a titled action.                  |\n| `git_clone(...)`               | Clones a Git repo with submodules.              |\n| `git_merge(...)`               | Merges one branch into another.                 |\n| `git_commit_all(...)`          | Stages and commits all repo changes.            |\n| `withExecutionTimeMeasurement(...)` | Times and logs how long an action takes.   |\n\n```py\nfrom datetime import datetime\nfrom subprocess import Popen, PIPE\nfrom typing import List, Callable, Any\nfrom config import Repository\n\ndef run_command(command: str, print_output: bool = True) -\u003e str:\n    \"\"\"Execute a shell command and return its output.\"\"\"\n    command = f'set -Eeuo pipefail \u0026\u0026 {command}'\n    process = Popen(command, stdout=PIPE, shell=True, text=True)\n    lines = []\n\n    while True:\n        line = process.stdout.readline().rstrip()\n        if not line:\n            break\n        lines.append(line)\n        if print_output:\n            print(line)\n\n    output = \"\\n\".join(lines)\n    process.communicate()\n\n    if process.returncode != 0:\n        raise Exception(f\"Command failed with exit code {process.returncode}: {command}\")\n\n    return output\n\ndef run_in_repo(repo: Repository, command: str, print_output: bool = True) -\u003e str:\n    \"\"\"Execute a command in the context of a repository.\"\"\"\n    return run_command(f'(cd {repo.path} \u0026\u0026 {command})', print_output)\n\ndef process_items_with_breaks(items: List, action: Callable, show_breaks: bool = True) -\u003e None:\n    \"\"\"Process a list of items with optional line breaks between them.\"\"\"\n    for index, item in enumerate(items):\n        action(item)\n        if show_breaks and index \u003c len(items) - 1:\n            print('')\n\ndef remove_directory(path: str) -\u003e None:\n    \"\"\"Safely remove a directory and its contents.\"\"\"\n    run_command(f'rm -rf {path}')\n\ndef perform_action(title: str, action: Callable) -\u003e Any:\n    \"\"\"Execute an action with formatted logging.\"\"\"\n    print(f\"\\n=============== {title} ===============\\n\")\n    result = action()\n    print(\"=\" * (len(title) + 32))\n    return result\n\ndef git_clone(repo: Repository) -\u003e None:\n    \"\"\"Clone a git repository.\"\"\"\n    run_command(f'git clone {repo.url} --progress --recursive')\n\ndef git_merge(repo: Repository, source: str, destination: str) -\u003e None:\n    \"\"\"Merge branches in a repository.\"\"\"\n    run_in_repo(repo, f'git checkout {destination}')\n    run_in_repo(repo, f'git merge {source} --strategy=ours --quiet --no-ff --no-edit')\n    print(f'Merged {source} -\u003e {destination}')\n\ndef git_commit_all(repo: Repository, message: str) -\u003e None:\n    \"\"\"Commit all changes in a repository.\"\"\"\n    run_in_repo(repo, f'git add -A')\n    run_in_repo(repo, f'git commit --quiet -m \"{message}\"')\n\ndef withExecutionTimeMeasurement(action_name: str, action: Callable) -\u003e Any:\n    \"\"\"Measure and print execution time of an action\"\"\"\n    start_time = datetime.now()\n    print(f'Starting {action_name}...\\n')\n\n    result = action()\n\n    duration = (datetime.now() - start_time).total_seconds()\n    print(f'\\nFinished {action_name} in {duration:.2f} seconds.')\n    return result\n```\n\nBefore concluding this article, we present a structured approach for executing the mono-repo migration in a coordinated and controlled manner.\n\n## Procedure\n\nWhile the migration script enables local testing, completing the migration requires a coordinated effort among team members.\n\nBelow, youâ€™ll find the key steps to follow before, during, and after the migration. Although the exact procedure may vary depending on your specific context, this guide can serve as a blueprint to help you successfully initiate and manage your own migration process.\n\n### Pre-migration\n\n1. Identify a suitable time window for the migration  \n   - If youâ€™re working in sprints, the beginning of a sprint is often ideal, as thereâ€™s typically less delivery pressure compared to the end.\n2. Request all developers to merge their open pull requests by a fixed deadline  \n   - This ensures a clean state and minimizes merge conflicts during the migration.\n\n### Migration\n\n1. Notify the team that the migration is about to begin.\n2. Temporarily freeze all merges to `main` and `develop` during the migration process.\n3. Merge the latest changes from `main` into `develop`  \n   - This ensures that any hotfixes or bugfixes are synchronized with the ongoing development branch.\n4. Run the **migration script** on a developer machine with access to all required repositories  \n   - After execution, review the logs to ensure there were no errors.  \n   - Verify the migration result by checking the branch and commit history in your Git client.\n5. Create pull requests from the integration branches generated by the script.\n6. Have your team review the changes introduced during the migration.\n7. Merge the integration branches into `develop` and `main`.\n8. Push any migrated tags to the main repository.\n\n### Post-migration\n\n1. Announce to the team that the migration is complete.\n2. Archive or restrict access to the now-obsolete repositories.\n3. Re-enable merges into `main` and `develop`.\n\n## Conclusion\n\nIn this article, we examined the trade-offs between `Mono-` and `Multi-Repo` and introduced a structured approach to a `Mono-Repo` migration. Consolidating repositories can significantly enhance developer productivity by minimizing cross-repository coordination and reducing the number of required pull requests. The provided migration script automates key steps, enabling repeatable and locally testable migrations without impacting the remote repository. Once validated, changes are submitted through dedicated pull requests, ensuring all modifications remain transparent, reviewable, and easy to track.\n\n## References\n\n- [Move to Mono-Repo](https://alexharri.com/blog/move-to-monorepo) - Alex Harri\n- [Git Merge to Mono-Repo](https://choly.ca/post/git-merge-to-monorepo/) - Ilia Choly\n- [Merge Git Repos and keep Commit History](https://gfscott.com/blog/merge-git-repos-and-keep-commit-history/) - Graham F. Scott\n\nHappy Coding ðŸš€","title":"Mono-Repo Migration: Boosting Developer Productivity While Keeping Git History Intact","description":"Modularization is essential for scaling large software projects, enabling faster \n            development and better maintainability. However, when modules are split across multiple \n            repositories, developer productivity can suffer due to the overhead of coordinating changes \n            across projects. In this article, we explore how transitioning to a Mono-Repo can streamline \n            collaboration and demonstrate a Python script to automate the migration process."}},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"2025-04-25"},"buildId":"yuTCw0a2ewunNGYLxVodA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>