<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><title>AsyncResourceView: Simplified Resource Loading</title><meta name="robots" content="index,follow"/><meta name="description" content="Modern apps heavily rely on resources that are received
            over the network, and hence may be affected by connectivity issues
            or data loss. If, for example, you travel by train within Germany,
            you may be surprised how often you will experience radio gaps or
            interruptions due to weak cellular reception. Hence, we as developers
            have to design our apps to include feedback when an action takes longer
            than expected and offer the ability to retry the action in case that
            it failed. This way, we can make our apps stand out, since they can
            cope with conditions that are far from optimal.
    
            AsyncResourceView offers a consistent way to deal with loading as well as
            error states in SwiftUI applications. This way, developers can focus on
            features rather than writing repetitive error-prone code."/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@site"/><meta name="twitter:creator" content="@handle"/><meta property="og:title" content="AsyncResourceView: Simplified Resource Loading"/><meta property="og:description" content="Modern apps heavily rely on resources that are received
            over the network, and hence may be affected by connectivity issues
            or data loss. If, for example, you travel by train within Germany,
            you may be surprised how often you will experience radio gaps or
            interruptions due to weak cellular reception. Hence, we as developers
            have to design our apps to include feedback when an action takes longer
            than expected and offer the ability to retry the action in case that
            it failed. This way, we can make our apps stand out, since they can
            cope with conditions that are far from optimal.
    
            AsyncResourceView offers a consistent way to deal with loading as well as
            error states in SwiftUI applications. This way, developers can focus on
            features rather than writing repetitive error-prone code."/><meta property="og:url" content="https://www.linkandreas.de/articles/2022-03-16"/><meta property="og:image" content="https://www.linkandreas.de/images/previews/2022-03-16.jpeg"/><meta property="og:image:alt" content="Link Preview Image"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:site_name" content="Andreas Link"/><link rel="canonical" href="https://www.linkandreas.de/articles/2022-03-16"/><meta name="next-head-count" content="19"/><link rel="alternate" type="application/rss+xml" title="linkandreas.de" href="https://linkandreas.de/rss"/><script id="show-banner" data-nscript="beforeInteractive">(function (w,d) {var loader = function () {var s = d.createElement("script"), tag = d.getElementsByTagName("script")[0]; s.src="https://cdn.iubenda.com/iubenda.js"; tag.parentNode.insertBefore(s,tag);}; if(w.addEventListener){w.addEventListener("load", loader, false);}else if(w.attachEvent){w.attachEvent("onload", loader);}else{w.onload = loader;}})(window, document);</script><link rel="preload" href="/_next/static/css/5d1a40d87bdc9ae6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5d1a40d87bdc9ae6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/88dd2e2cc48225a2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/88dd2e2cc48225a2.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-631d87836c08b1b9.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-deafda337c616f20.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d88e0ac7b041052.js" defer=""></script><script src="/_next/static/chunks/675-1303c59f4dea6577.js" defer=""></script><script src="/_next/static/chunks/252-0372aac53a566808.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bid%5D-27a1256810491fa2.js" defer=""></script><script src="/_next/static/kmqapEHE3C1u42TzNOvN0/_buildManifest.js" defer=""></script><script src="/_next/static/kmqapEHE3C1u42TzNOvN0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App_appContainer___ZcR0"><div class="container-fluid"><nav class="navbar navbar-expand-md navbar-dark bg-transparent"><a class="navbar-brand" href="/articles">Andreas Link</a><button aria-controls="responsive-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="responsive-navbar-nav"><div class="ml-auto navbar-nav"><a data-rr-ui-event-key="/articles" class="nav-link" href="/articles">Articles</a><a data-rr-ui-event-key="/licenses" class="nav-link" href="/licenses">Licenses</a><a data-rr-ui-event-key="/timity" class="nav-link" href="/timity">Timity</a><a data-rr-ui-event-key="/publications" class="nav-link" href="/publications">Publications</a><a data-rr-ui-event-key="/about" class="nav-link" href="/about">About</a></div></div></nav></div><div class="App_content__2tPe8"><div class="_id__articleContainer__XAN2P"><p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_16_03_2022_logo_dark.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Today we are going to take a look at how we can deal with asynchronous data in SwiftUI applications. Modern apps heavily rely on resources that are received over the network, and hence may be affected by connectivity issues or data loss. If, for example, you travel by train within Germany, you may be surprised how often you will experience radio gaps or interruptions due to weak cellular reception. Hence, we as developers have to design our apps to include feedback when an action takes longer than expected and offer the ability to retry the action in case that it failed. This way, we can make our apps stand out, since they can cope with conditions that are far from optimal.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">This article introduces the reusable component <code node="[object Object]">AsyncResourceView</code> that abstracts loading as well as failure states when fetching asynchronous data, such that we can focus on features rather than writing repetitive error-prone code.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_16_03_2022_simple_example_tiny_dark.gif"/></p>
<h2>View Store</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">First, let&#x27;s implement the <code node="[object Object]">AsyncResourceViewStore&lt;Resource&gt;</code> that is responsible for driving the UI. Given the loader, the store initially remains in the <code node="[object Object]">notRequested</code> state until <code node="[object Object]">loadResource</code> is called and the <code node="[object Object]">loading</code> state is entered. Finally, depending on the result of the operation, either the <code node="[object Object]">success</code> or <code node="[object Object]">failure</code> state is entered.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that the store is independent of SwiftUI and may be used with an alternative UI framework in the future. In addition, we ensure that state changes only occur on the main thread using the <code node="[object Object]">@MainActor</code> annotation:</p>
<pre><code class="language-swift" node="[object Object]">public final class AsyncResourceViewStore&lt;Resource&gt;: ObservableObject {
    public typealias Loader = () async throws -&gt; Resource

    public enum State {
        case notRequested
        case loading
        case success(Resource)
        case failure(Error)
    }

    @Published public var state: State

    private var loader: Loader?

    public init(state: State = .notRequested, loader: Loader? = nil) {
        self.state = state
        self.loader = loader
    }

    @MainActor
    public func loadResource() async {
        guard let loader = loader else { return }

        state = .loading

        do {
            let resource = try await loader()
            state = .success(resource)
        } catch {
            state = .failure(error)
        }
    }
}
</code></pre>
<h2>Testing</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Even though its implementation looks simple, let&#x27;s include unit tests to ensure that we are free to refactor the store in the future without changing its behavior.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">First, the store should be in the <code node="[object Object]">notRequested</code> state. The <code node="[object Object]">makeSUT</code> helper instantiates the <code node="[object Object]">AsyncResourceViewStore</code> with a loader stub, such that we have control over its outcome when making assertions about the expected behavior.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Second, we expect the store to enter the <code node="[object Object]">success</code> state when the resource loading succeeded. Similarly, we expect the store to enter the <code node="[object Object]">failure</code> state in case that the resource loading failed.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Finally, we also expect the store to enter the <code node="[object Object]">success</code> state after the resource loading initially failed but later succeeded. This way, we ensure that the user will have the option to retry the action in case that it failed.</p>
<pre><code class="language-swift" node="[object Object]">final class AsyncResourceViewStoreTests: XCTestCase {
    func test_store_entersNotRequestedStateOnInit() {
        let (sut, _) = makeSUT()

        expectState(of: sut, toEqual: .notRequested)
    }

    func test_store_entersSuccessStateWhenResourceLoadingSucceeded() async throws {
        let anyText = &quot;any Text&quot;
        let (sut, loaderStub) = makeSUT()

        loaderStub.loadResult = .success(anyText)
        await sut.loadResource()

        expectState(of: sut, toEqual: .success(anyText))
    }

    func test_store_entersFailureStateWhenResourceLoadingFailed() async throws {
        let error = anyNSError()
        let (sut, loaderStub) = makeSUT()

        loaderStub.loadResult = .failure(error)
        await sut.loadResource()

        expectState(of: sut, toEqual: .failure(error))
    }

    func test_store_entersSuccessStateAfterResourceLoadingInitiallyFailed() async throws {
        let anyText = &quot;any Text&quot;
        let error = anyNSError()
        let (sut, loaderStub) = makeSUT()

        loaderStub.loadResult = .failure(error)
        await sut.loadResource()

        expectState(of: sut, toEqual: .failure(error))

        loaderStub.loadResult = .success(anyText)
        await sut.loadResource()

        expectState(of: sut, toEqual: .success(anyText))
    }
}

extension AsyncResourceViewStoreTests {
    typealias SUT = AsyncResourceViewStore&lt;String&gt;

    private func makeSUT(expectedResult: Result&lt;String, Error&gt; = .success(&quot;&quot;)) -&gt; (SUT, LoaderStub) {
        let stub = LoaderStub()
        let sut = SUT(loader: stub.load)
        return (sut, stub)
    }

    private func anyNSError() -&gt; NSError {
        return NSError(domain: &quot;any domain&quot;, code: 42, userInfo: nil)
    }

    private func expectState(
        of sut: SUT,
        toEqual expectedState: SUT.State,
        file: StaticString = #filePath,
        line: UInt = #line
    ) {
        switch (sut.state, expectedState) {
        case (.notRequested, .notRequested), (.loading, .loading), (.success, .success):
            break

        case let (.failure(receivedError as NSError), .failure(expectedError as NSError)):
            XCTAssertEqual(receivedError, expectedError, file: file, line: line)

        default:
            XCTFail(&quot;State \(sut.state), does not match \(expectedState)&quot;, file: file, line: line)
        }
    }

    private class LoaderStub {
        var loadResult: Result&lt;String, Error&gt;!

        func load() async throws -&gt; String {
            switch loadResult! {
            case let .success(text):
                return text

            case let .failure(error):
                throw error
            }
        }
    }
}
</code></pre>
<h2>View</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">As we completed the store, let&#x27;s continue with the <code node="[object Object]">AsyncResourceView</code> that renders its children using the state-specific closures. While the <code node="[object Object]">notRequested-</code>, <code node="[object Object]">failure-</code> and <code node="[object Object]">loading-</code> views are optional, we are required to specify the <code node="[object Object]">success</code> view given the resource. This way, we can break down complexity and only have to deal with a single instead of multiple states at once.</p>
<pre><code class="language-swift" node="[object Object]">public struct AsyncResourceView&lt;Resource&gt;: View {
    public typealias ViewStore = AsyncResourceViewStore&lt;Resource&gt;
    public typealias NotRequestedView = (@escaping () -&gt; Void) -&gt; AnyView
    public typealias LoadingView = () -&gt; AnyView
    public typealias FailureView = (Error, @escaping () -&gt; Void) -&gt; AnyView
    public typealias SuccessView = (Resource) -&gt; AnyView

    @ObservedObject private var store: ViewStore

    private var notRequestedView: NotRequestedView
    private var loadingView: LoadingView
    private var failureView: FailureView
    private var successView: SuccessView

    public init(
        store: ViewStore,
        notRequestedView: @escaping NotRequestedView = { AnyView(AsyncResourceDefaultNotRequestedView(load: $0)) },
        loadingView: @escaping LoadingView = { AnyView(AsyncResourceDefaultLoadingView()) },
        failureView: @escaping FailureView = { AnyView(AsyncResourceDefaultFailureView(error: $0, retry: $1)) },
        successView: @escaping SuccessView
    ) {
        self.store = store
        self.notRequestedView = notRequestedView
        self.loadingView = loadingView
        self.failureView = failureView
        self.successView = successView
    }

    public var body: some View {
        switch store.state {
        case .notRequested:
            return notRequestedView(loadResource)

        case .loading:
            return loadingView()

        case let .success(resource):
            return successView(resource)

        case let .failure(error):
            return failureView(error, loadResource)
        }
    }

    private func loadResource() {
        Task { await store.loadResource() }
    }
}
</code></pre>
<h3>Default Views</h3>
<h4>AsyncResourceDefaultNotRequestedView</h4>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">For example, using the <code node="[object Object]">notRequested</code> view, we can specify how the UI should look like until the resource is requested. Note that the default representation is not visible and is only used to trigger the callback as soon as it appeared. Instead, one can also think of a visual representation that features a button to let the user decide when the action is run.</p>
<pre><code class="language-swift" node="[object Object]">public struct AsyncResourceDefaultNotRequestedView: View {
    private let load: () -&gt; Void

    public init(load: @escaping () -&gt; Void) {
        self.load = load
    }

    public var body: some View {
        Color.clear
            .onAppear(perform: load)
    }
}
</code></pre>
<h4>AsyncResourceDefaultLoadingView</h4>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">In contrast, the default <code node="[object Object]">loading</code> view is visible and will indicate progress until either the <em>success</em> or <em>failure-</em> state is entered.</p>
<pre><code class="language-swift" node="[object Object]">public struct AsyncResourceDefaultLoadingView: View {
    private let title: String

    public init(title: String = &quot;Loading&quot;) {
        self.title = title
    }

    public var body: some View {
        ProgressView(title)
    }
}
</code></pre>
<h4>AsyncResourceDefaultFailureView</h4>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Finally, in case no <code node="[object Object]">failure</code> closure exists, the <code node="[object Object]">AsyncResourceDefaultFailureView</code> renders a counterclockwise arrow to retry the action in case that it failed. Note that custom views may also consider the error to provide additional information about why the action did not work as intended.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_16_03_2022_default_failure_view.png"/></p>
<pre><code class="language-swift" node="[object Object]">public struct AsyncResourceDefaultFailureView: View {
    private let error: Error
    private let retry: () -&gt; Void

    public init(error: Error, retry: @escaping () -&gt; Void) {
        self.error = error
        self.retry = retry
    }

    public var body: some View {
        VStack(spacing: 16) {
            Button(action: retry) {
                Image(systemName: &quot;arrow.counterclockwise&quot;)
                    .font(.system(size: 25))
                    .tint(.accentColor)
            }
        }
    }
}
</code></pre>
<h2>Previews</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Undoubtedly, one of the great advantages of SwiftUI over UI Kit is that we can get real-time feedback about how the rendering is composed. This is especially true when dealing with interactive previews that offer great insights into the look and feel of a component. Subsequently, you can find examples for a static as well as interactive preview:</p>
<pre><code class="language-swift" node="[object Object]">struct AsyncResourceView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            AsyncResourceView(
                store: AsyncResourceViewStore(state: .success(&quot;Hello World&quot;)),
                successView: { text in
                    AnyView(Text(text))
                }
            )
            .navigationTitle(&quot;Static Preview&quot;)
        }

        NavigationView {
            AsyncResourceView(
                store: AsyncResourceViewStore(loader: loader),
                notRequestedView: { load in
                    AnyView(
                        Button(&quot;Load Resource&quot;, action: load)
                            .buttonStyle(.borderedProminent)
                    )
                },
                successView: { text in
                    AnyView(Text(text))
                }
            )
            .navigationTitle(&quot;Interactive Preview&quot;)
        }
    }
}

private let loader: () async throws -&gt; String = {
    try await Task.sleep(nanoseconds: 2_000_000_000)

    if Bool.random() {
        return &quot;Hello World&quot;
    } else {
        throw NSError(domain: &quot;any domain&quot;, code: 42, userInfo: nil)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">While the static preview renders itself based on the predefined state of the store, the interactive preview explicitly communicates with the loader and waits until the result is made. Since, the loader may fail, we throw a dice and either return the resource (i.e., “Hello World”) or an error. The latter will result in the failure state, where we can retry the action without leaving the preview.</p>
<h2>Use Case Example: &quot;Color Gallery&quot;</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_16_03_2022_gallery_example_dark_optimized.gif"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">To visualize how the component is used, let&#x27;s implement a color gallery where items are arranged in a three-column grid. Each item features the <code node="[object Object]">AsyncResourceView</code> to request its color from the loader that will either return a random color or fail after [0.3, 3.0] seconds. As stated above, a retry button is shown in case the action failed.</p>
<pre><code class="language-swift" node="[object Object]">@main
struct AsyncResourceGalleryApp: App {
    @StateObject
    private var store: GalleryStore = .init()

    var body: some Scene {
        WindowGroup {
            GalleryView(
                store: store,
                itemView: { item -&gt; AnyView in
                    let store = AsyncResourceViewStore&lt;Color&gt;(loader: loader(item))
                    return AnyView(GalleryItemView(store: store))
                }
            )
            .onAppear(perform: store.onAppear)
        }
    }
}

extension AsyncResourceGalleryApp {
    private func loader(_ item: GalleryItem) -&gt; (() async throws -&gt; Color) {
        return {
            let duration = UInt64.random(in: 300_000_000 ... 3_000_000_000)
            try await Task.sleep(nanoseconds: duration)
            if Int.random(in: 0...5) == 4 {
                throw NSError(domain: &quot;&quot;, code: 42, userInfo: nil)
            } else {
                return item.color
            }
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Since we do not specify a custom <code node="[object Object]">notRequested</code> view, the default view is used that requests the resource as soon as it appeared. By wrapping the items in SwiftUI&#x27;s <code node="[object Object]">LazyVGrid</code> they are only created when needed.</p>
<pre><code class="language-swift" node="[object Object]">struct GalleryView: View {
    private var store: GalleryStore
    private let columns: [GridItem] = [
        GridItem(.flexible(minimum: 50), spacing: 50),
        GridItem(.flexible(minimum: 50), spacing: 50),
        GridItem(.flexible(minimum: 50), spacing: 50)
    ]
    private let itemView: (GalleryItem) -&gt; AnyView

    init(store: GalleryStore, itemView: @escaping (GalleryItem) -&gt; AnyView) {
        self.store = store
        self.itemView = itemView
    }

    var body: some View {
        ScrollView {
            LazyVGrid(columns: columns, spacing: 50) {
                ForEach(store.items, id: \.self) { item in
                    itemView(item)
                        .frame(width: 100, height: 100)
                }
            }
            .padding()
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Each of the items is driven by its own store, i.e., <code node="[object Object]">AsyncResourceViewStore</code> that transitions between states depending on how long the action takes.</p>
<pre><code class="language-swift" node="[object Object]">struct GalleryItemView: View {
    private let store: AsyncResourceViewStore&lt;Color&gt;

    init(store: AsyncResourceViewStore&lt;Color&gt;) {
        self.store = store
    }

    var body: some View {
        AsyncResourceView(store: store) { color in
            AnyView(color)
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Finally, we create a <code node="[object Object]">GalleryStore</code> that drives the composition and provides a color for each individual loader.</p>
<pre><code class="language-swift" node="[object Object]">final class GalleryStore: ObservableObject {
    @Published var items: [GalleryItem] = []

    func onAppear() {
        items = (0 ..&lt; 100)
            .map { _ in Color.random }
            .map { GalleryItem(color: $0 )}
    }
}

struct GalleryItem: Hashable {
    let id: UUID
    let color: Color

    init(id: UUID = .init(), color: Color) {
        self.id = id
        self.color = color
    }
}
</code></pre>
<h1>Conclusion</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">In this article, I presented the <code node="[object Object]">AsyncResourceView</code>, a consistent way to deal with asynchronous resources in SwiftUI applications. Using the component, we can avoid repetitive code and spend more time on implementing features rather than writing the same loading- or error handling code throughout the App. You can checkout the project on GitHub (<a href="https://github.com/LinkAndreas/AsyncResourceView">Link</a>).</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Happy Coding 🚀</p></div></div><footer class="Footer_footer__pJUho"><p>Made by<!-- --> <a class="inline" href="/about">Andreas Link</a> <!-- -->in Karlsruhe</p><div><div><a href="https://www.iubenda.com/privacy-policy/86928215" class="iubenda-black no-brand iubenda-noiframe iubenda-embed iubenda-noiframe ">Privacy Policy</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"2022-03-16","date":"Wed, 16 Mar 2022 00:00:00 +0000","markdown":"![Logo](article_16_03_2022_logo_dark.png)\n\nToday we are going to take a look at how we can deal with asynchronous data in SwiftUI applications. Modern apps heavily rely on resources that are received over the network, and hence may be affected by connectivity issues or data loss. If, for example, you travel by train within Germany, you may be surprised how often you will experience radio gaps or interruptions due to weak cellular reception. Hence, we as developers have to design our apps to include feedback when an action takes longer than expected and offer the ability to retry the action in case that it failed. This way, we can make our apps stand out, since they can cope with conditions that are far from optimal.\n\nThis article introduces the reusable component `AsyncResourceView` that abstracts loading as well as failure states when fetching asynchronous data, such that we can focus on features rather than writing repetitive error-prone code.\n\n![Simple Example](article_16_03_2022_simple_example_tiny_dark.gif)\n\n## View Store\n\nFirst, let's implement the `AsyncResourceViewStore\u003cResource\u003e` that is responsible for driving the UI. Given the loader, the store initially remains in the `notRequested` state until `loadResource` is called and the `loading` state is entered. Finally, depending on the result of the operation, either the `success` or `failure` state is entered.\n\nNote that the store is independent of SwiftUI and may be used with an alternative UI framework in the future. In addition, we ensure that state changes only occur on the main thread using the `@MainActor` annotation:\n\n```swift\npublic final class AsyncResourceViewStore\u003cResource\u003e: ObservableObject {\n    public typealias Loader = () async throws -\u003e Resource\n\n    public enum State {\n        case notRequested\n        case loading\n        case success(Resource)\n        case failure(Error)\n    }\n\n    @Published public var state: State\n\n    private var loader: Loader?\n\n    public init(state: State = .notRequested, loader: Loader? = nil) {\n        self.state = state\n        self.loader = loader\n    }\n\n    @MainActor\n    public func loadResource() async {\n        guard let loader = loader else { return }\n\n        state = .loading\n\n        do {\n            let resource = try await loader()\n            state = .success(resource)\n        } catch {\n            state = .failure(error)\n        }\n    }\n}\n```\n\n## Testing\n\nEven though its implementation looks simple, let's include unit tests to ensure that we are free to refactor the store in the future without changing its behavior. \n\nFirst, the store should be in the `notRequested` state. The `makeSUT` helper instantiates the `AsyncResourceViewStore` with a loader stub, such that we have control over its outcome when making assertions about the expected behavior.\n\nSecond, we expect the store to enter the `success` state when the resource loading succeeded. Similarly, we expect the store to enter the `failure` state in case that the resource loading failed.\n\nFinally, we also expect the store to enter the `success` state after the resource loading initially failed but later succeeded. This way, we ensure that the user will have the option to retry the action in case that it failed.\n\n```swift\nfinal class AsyncResourceViewStoreTests: XCTestCase {\n    func test_store_entersNotRequestedStateOnInit() {\n        let (sut, _) = makeSUT()\n\n        expectState(of: sut, toEqual: .notRequested)\n    }\n\n    func test_store_entersSuccessStateWhenResourceLoadingSucceeded() async throws {\n        let anyText = \"any Text\"\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .success(anyText)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .success(anyText))\n    }\n\n    func test_store_entersFailureStateWhenResourceLoadingFailed() async throws {\n        let error = anyNSError()\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .failure(error)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .failure(error))\n    }\n\n    func test_store_entersSuccessStateAfterResourceLoadingInitiallyFailed() async throws {\n        let anyText = \"any Text\"\n        let error = anyNSError()\n        let (sut, loaderStub) = makeSUT()\n\n        loaderStub.loadResult = .failure(error)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .failure(error))\n\n        loaderStub.loadResult = .success(anyText)\n        await sut.loadResource()\n\n        expectState(of: sut, toEqual: .success(anyText))\n    }\n}\n\nextension AsyncResourceViewStoreTests {\n    typealias SUT = AsyncResourceViewStore\u003cString\u003e\n\n    private func makeSUT(expectedResult: Result\u003cString, Error\u003e = .success(\"\")) -\u003e (SUT, LoaderStub) {\n        let stub = LoaderStub()\n        let sut = SUT(loader: stub.load)\n        return (sut, stub)\n    }\n\n    private func anyNSError() -\u003e NSError {\n        return NSError(domain: \"any domain\", code: 42, userInfo: nil)\n    }\n\n    private func expectState(\n        of sut: SUT,\n        toEqual expectedState: SUT.State,\n        file: StaticString = #filePath,\n        line: UInt = #line\n    ) {\n        switch (sut.state, expectedState) {\n        case (.notRequested, .notRequested), (.loading, .loading), (.success, .success):\n            break\n\n        case let (.failure(receivedError as NSError), .failure(expectedError as NSError)):\n            XCTAssertEqual(receivedError, expectedError, file: file, line: line)\n\n        default:\n            XCTFail(\"State \\(sut.state), does not match \\(expectedState)\", file: file, line: line)\n        }\n    }\n\n    private class LoaderStub {\n        var loadResult: Result\u003cString, Error\u003e!\n\n        func load() async throws -\u003e String {\n            switch loadResult! {\n            case let .success(text):\n                return text\n\n            case let .failure(error):\n                throw error\n            }\n        }\n    }\n}\n```\n\n## View\n\nAs we completed the store, let's continue with the `AsyncResourceView` that renders its children using the state-specific closures. While the `notRequested-`, `failure-` and `loading-` views are optional, we are required to specify the `success` view given the resource. This way, we can break down complexity and only have to deal with a single instead of multiple states at once.\n\n```swift\npublic struct AsyncResourceView\u003cResource\u003e: View {\n    public typealias ViewStore = AsyncResourceViewStore\u003cResource\u003e\n    public typealias NotRequestedView = (@escaping () -\u003e Void) -\u003e AnyView\n    public typealias LoadingView = () -\u003e AnyView\n    public typealias FailureView = (Error, @escaping () -\u003e Void) -\u003e AnyView\n    public typealias SuccessView = (Resource) -\u003e AnyView\n\n    @ObservedObject private var store: ViewStore\n\n    private var notRequestedView: NotRequestedView\n    private var loadingView: LoadingView\n    private var failureView: FailureView\n    private var successView: SuccessView\n\n    public init(\n        store: ViewStore,\n        notRequestedView: @escaping NotRequestedView = { AnyView(AsyncResourceDefaultNotRequestedView(load: $0)) },\n        loadingView: @escaping LoadingView = { AnyView(AsyncResourceDefaultLoadingView()) },\n        failureView: @escaping FailureView = { AnyView(AsyncResourceDefaultFailureView(error: $0, retry: $1)) },\n        successView: @escaping SuccessView\n    ) {\n        self.store = store\n        self.notRequestedView = notRequestedView\n        self.loadingView = loadingView\n        self.failureView = failureView\n        self.successView = successView\n    }\n\n    public var body: some View {\n        switch store.state {\n        case .notRequested:\n            return notRequestedView(loadResource)\n\n        case .loading:\n            return loadingView()\n\n        case let .success(resource):\n            return successView(resource)\n\n        case let .failure(error):\n            return failureView(error, loadResource)\n        }\n    }\n\n    private func loadResource() {\n        Task { await store.loadResource() }\n    }\n}\n```\n\n### Default Views\n\n#### AsyncResourceDefaultNotRequestedView\n\nFor example, using the `notRequested` view, we can specify how the UI should look like until the resource is requested. Note that the default representation is not visible and is only used to trigger the callback as soon as it appeared. Instead, one can also think of a visual representation that features a button to let the user decide when the action is run.\n\n```swift\npublic struct AsyncResourceDefaultNotRequestedView: View {\n    private let load: () -\u003e Void\n\n    public init(load: @escaping () -\u003e Void) {\n        self.load = load\n    }\n\n    public var body: some View {\n        Color.clear\n            .onAppear(perform: load)\n    }\n}\n```\n\n#### AsyncResourceDefaultLoadingView\n\nIn contrast, the default `loading` view is visible and will indicate progress until either the *success* or *failure-* state is entered.\n\n```swift\npublic struct AsyncResourceDefaultLoadingView: View {\n    private let title: String\n\n    public init(title: String = \"Loading\") {\n        self.title = title\n    }\n\n    public var body: some View {\n        ProgressView(title)\n    }\n}\n```\n\n#### AsyncResourceDefaultFailureView\n\nFinally, in case no `failure` closure exists, the `AsyncResourceDefaultFailureView` renders a counterclockwise arrow to retry the action in case that it failed. Note that custom views may also consider the error to provide additional information about why the action did not work as intended.\n\n![Default Failure View](article_16_03_2022_default_failure_view.png)\n\n```swift\npublic struct AsyncResourceDefaultFailureView: View {\n    private let error: Error\n    private let retry: () -\u003e Void\n\n    public init(error: Error, retry: @escaping () -\u003e Void) {\n        self.error = error\n        self.retry = retry\n    }\n\n    public var body: some View {\n        VStack(spacing: 16) {\n            Button(action: retry) {\n                Image(systemName: \"arrow.counterclockwise\")\n                    .font(.system(size: 25))\n                    .tint(.accentColor)\n            }\n        }\n    }\n}\n```\n\n## Previews\n\nUndoubtedly, one of the great advantages of SwiftUI over UI Kit is that we can get real-time feedback about how the rendering is composed. This is especially true when dealing with interactive previews that offer great insights into the look and feel of a component. Subsequently, you can find examples for a static as well as interactive preview:\n\n```swift\nstruct AsyncResourceView_Previews: PreviewProvider {\n    static var previews: some View {\n        NavigationView {\n            AsyncResourceView(\n                store: AsyncResourceViewStore(state: .success(\"Hello World\")),\n                successView: { text in\n                    AnyView(Text(text))\n                }\n            )\n            .navigationTitle(\"Static Preview\")\n        }\n\n        NavigationView {\n            AsyncResourceView(\n                store: AsyncResourceViewStore(loader: loader),\n                notRequestedView: { load in\n                    AnyView(\n                        Button(\"Load Resource\", action: load)\n                            .buttonStyle(.borderedProminent)\n                    )\n                },\n                successView: { text in\n                    AnyView(Text(text))\n                }\n            )\n            .navigationTitle(\"Interactive Preview\")\n        }\n    }\n}\n\nprivate let loader: () async throws -\u003e String = {\n    try await Task.sleep(nanoseconds: 2_000_000_000)\n\n    if Bool.random() {\n        return \"Hello World\"\n    } else {\n        throw NSError(domain: \"any domain\", code: 42, userInfo: nil)\n    }\n}\n```\n\nWhile the static preview renders itself based on the predefined state of the store, the interactive preview explicitly communicates with the loader and waits until the result is made. Since, the loader may fail, we throw a dice and either return the resource (i.e., “Hello World”) or an error. The latter will result in the failure state, where we can retry the action without leaving the preview.\n\n## Use Case Example: \"Color Gallery\"\n\n![Gallery Example](article_16_03_2022_gallery_example_dark_optimized.gif)\n\nTo visualize how the component is used, let's implement a color gallery where items are arranged in a three-column grid. Each item features the `AsyncResourceView` to request its color from the loader that will either return a random color or fail after [0.3, 3.0] seconds. As stated above, a retry button is shown in case the action failed. \n\n```swift\n@main\nstruct AsyncResourceGalleryApp: App {\n    @StateObject\n    private var store: GalleryStore = .init()\n\n    var body: some Scene {\n        WindowGroup {\n            GalleryView(\n                store: store,\n                itemView: { item -\u003e AnyView in\n                    let store = AsyncResourceViewStore\u003cColor\u003e(loader: loader(item))\n                    return AnyView(GalleryItemView(store: store))\n                }\n            )\n            .onAppear(perform: store.onAppear)\n        }\n    }\n}\n\nextension AsyncResourceGalleryApp {\n    private func loader(_ item: GalleryItem) -\u003e (() async throws -\u003e Color) {\n        return {\n            let duration = UInt64.random(in: 300_000_000 ... 3_000_000_000)\n            try await Task.sleep(nanoseconds: duration)\n            if Int.random(in: 0...5) == 4 {\n                throw NSError(domain: \"\", code: 42, userInfo: nil)\n            } else {\n                return item.color\n            }\n        }\n    }\n}\n```\n\nSince we do not specify a custom `notRequested` view, the default view is used that requests the resource as soon as it appeared. By wrapping the items in SwiftUI's `LazyVGrid` they are only created when needed.\n\n```swift\nstruct GalleryView: View {\n    private var store: GalleryStore\n    private let columns: [GridItem] = [\n        GridItem(.flexible(minimum: 50), spacing: 50),\n        GridItem(.flexible(minimum: 50), spacing: 50),\n        GridItem(.flexible(minimum: 50), spacing: 50)\n    ]\n    private let itemView: (GalleryItem) -\u003e AnyView\n\n    init(store: GalleryStore, itemView: @escaping (GalleryItem) -\u003e AnyView) {\n        self.store = store\n        self.itemView = itemView\n    }\n\n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: columns, spacing: 50) {\n                ForEach(store.items, id: \\.self) { item in\n                    itemView(item)\n                        .frame(width: 100, height: 100)\n                }\n            }\n            .padding()\n        }\n    }\n}\n```\n\nEach of the items is driven by its own store, i.e., `AsyncResourceViewStore` that transitions between states depending on how long the action takes.\n\n```swift\nstruct GalleryItemView: View {\n    private let store: AsyncResourceViewStore\u003cColor\u003e\n\n    init(store: AsyncResourceViewStore\u003cColor\u003e) {\n        self.store = store\n    }\n\n    var body: some View {\n        AsyncResourceView(store: store) { color in\n            AnyView(color)\n        }\n    }\n}\n```\n\nFinally, we create a `GalleryStore` that drives the composition and provides a color for each individual loader.\n\n```swift\nfinal class GalleryStore: ObservableObject {\n    @Published var items: [GalleryItem] = []\n\n    func onAppear() {\n        items = (0 ..\u003c 100)\n            .map { _ in Color.random }\n            .map { GalleryItem(color: $0 )}\n    }\n}\n\nstruct GalleryItem: Hashable {\n    let id: UUID\n    let color: Color\n\n    init(id: UUID = .init(), color: Color) {\n        self.id = id\n        self.color = color\n    }\n}\n```\n\n# Conclusion\n\nIn this article, I presented the `AsyncResourceView`, a consistent way to deal with asynchronous resources in SwiftUI applications. Using the component, we can avoid repetitive code and spend more time on implementing features rather than writing the same loading- or error handling code throughout the App. You can checkout the project on GitHub ([Link](https://github.com/LinkAndreas/AsyncResourceView)). \n\nHappy Coding 🚀\n\n\n\n\n","title":"AsyncResourceView: Simplified Resource Loading","description":"Modern apps heavily rely on resources that are received\n            over the network, and hence may be affected by connectivity issues\n            or data loss. If, for example, you travel by train within Germany,\n            you may be surprised how often you will experience radio gaps or\n            interruptions due to weak cellular reception. Hence, we as developers\n            have to design our apps to include feedback when an action takes longer\n            than expected and offer the ability to retry the action in case that\n            it failed. This way, we can make our apps stand out, since they can\n            cope with conditions that are far from optimal.\n    \n            AsyncResourceView offers a consistent way to deal with loading as well as\n            error states in SwiftUI applications. This way, developers can focus on\n            features rather than writing repetitive error-prone code."}},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"2022-03-16"},"buildId":"kmqapEHE3C1u42TzNOvN0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>