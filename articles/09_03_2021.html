<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><title>Building a native macOS app using SwiftUI and Combine</title><meta name="robots" content="index,follow"/><meta name="description" content="Have you ever been asked to put together the list of licenses 
            of all frameworks that are used within your iOS, iPad OS, or
            macOS app? Manually completing this task quickly becomes
            tedious but may be required due to legal- or customer
            requests.
    
            To mitigate this issue, I developed Licenses, a native macOS
            app that automates this procedure by collecting and exporting
            your licenses into a single spreadsheet (CSV) file."/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@site"/><meta name="twitter:creator" content="@handle"/><meta property="og:title" content="Building a native macOS app using SwiftUI and Combine"/><meta property="og:description" content="Have you ever been asked to put together the list of licenses 
            of all frameworks that are used within your iOS, iPad OS, or
            macOS app? Manually completing this task quickly becomes
            tedious but may be required due to legal- or customer
            requests.
    
            To mitigate this issue, I developed Licenses, a native macOS
            app that automates this procedure by collecting and exporting
            your licenses into a single spreadsheet (CSV) file."/><meta property="og:url" content="https://www.linkandreas.de/articles/09_03_2021"/><meta property="og:image" content="https://www.linkandreas.de/images/link_previews/09_03_2021.png"/><meta property="og:image:alt" content="Link Preview Image"/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:site_name" content="Andreas Link"/><link rel="canonical" href="https://www.linkandreas.de/articles/09_03_2021"/><meta name="next-head-count" content="19"/><script id="show-banner" data-nscript="beforeInteractive">(function (w,d) {var loader = function () {var s = d.createElement("script"), tag = d.getElementsByTagName("script")[0]; s.src="https://cdn.iubenda.com/iubenda.js"; tag.parentNode.insertBefore(s,tag);}; if(w.addEventListener){w.addEventListener("load", loader, false);}else if(w.attachEvent){w.attachEvent("onload", loader);}else{w.onload = loader;}})(window, document);</script><link rel="preload" href="/_next/static/css/5d1a40d87bdc9ae6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5d1a40d87bdc9ae6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/88dd2e2cc48225a2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/88dd2e2cc48225a2.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-631d87836c08b1b9.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-deafda337c616f20.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2d88e0ac7b041052.js" defer=""></script><script src="/_next/static/chunks/675-1303c59f4dea6577.js" defer=""></script><script src="/_next/static/chunks/252-0372aac53a566808.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bid%5D-4dd3cd0a885f687a.js" defer=""></script><script src="/_next/static/wGHrzav0idxTY_Smbjgd9/_buildManifest.js" defer=""></script><script src="/_next/static/wGHrzav0idxTY_Smbjgd9/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App_appContainer___ZcR0"><div class="container-fluid"><nav class="navbar navbar-expand-md navbar-dark bg-transparent"><a class="navbar-brand" href="/articles">Andreas Link</a><button aria-controls="responsive-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="responsive-navbar-nav"><div class="ml-auto navbar-nav"><a data-rr-ui-event-key="/articles" class="nav-link" href="/articles">Articles</a><a data-rr-ui-event-key="/licenses" class="nav-link" href="/licenses">Licenses</a><a data-rr-ui-event-key="/timity" class="nav-link" href="/timity">Timity</a><a data-rr-ui-event-key="/publications" class="nav-link" href="/publications">Publications</a><a data-rr-ui-event-key="/about" class="nav-link" href="/about">About</a></div></div></nav></div><div class="App_content__2tPe8"><div class="_id__articleContainer__XAN2P"><p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_app.png"/></p>
<h1>Building a native macOS app using SwiftUI and Combine</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Have you ever been asked to put together the list of licenses of all frameworks that are used within your iOS, iPad OS, or macOS app? Manually completing this task quickly becomes tedious but may be required due to legal- or customer requests.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">To mitigate this issue, I developed <strong>Licenses</strong>, a native macOS app that automates this procedure by collecting and exporting your licenses into a single spreadsheet (CSV) file.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">In this article, I want to share my experience as well as the challenges that I faced when developing the app using <em>SwiftUI 2.0</em> and <em>Combine</em>. This way, I hope to provide additional documentation on how declarative macOS apps can be built and to encourage others to also bring their ideas to the Mac.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">You can get the latest version of Licenses in the Mac AppStore (<a href="https://apps.apple.com/us/app/licenses/id1545822966">Link</a>) or check out the project on GitHub (<a href="https://github.com/LinkAndreas/Licenses">Link</a>).</p>
<h1>Architecture</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><em>Licenses</em>, uses a redux-inspired architecture, as illustrated in figure 1, consisting of Data-, Bloc-, ViewStore- and UI-related components. This way, state changes only occur within the bloc&#x27;s reducer function, transforming incoming actions as well as the current state to an updated state that is ultimately consumed by the UI.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_architecture.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Also, side effects are performed by returning publishers from the reducer resulting in additional actions that are sent to the bloc. Hence, asynchronous work is treated similarly to synchronous work in the way that it only affects the state from within the reducer. Thus, the correctness of the reducer and as such the correctness of all state changes becomes testable through unit tests.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that blocs are not directly connected to the UI, but rather via view stores that act as the main communication gateway of the view. As a result, domain-specific knowledge is not exposed, but rather gets translated into view-specific models that only include the formatted data that is ready to be shown in the UI. As an example, instead of passing repositories, i.e., <code node="[object Object]">[GitHubRepository]</code>, to the view directly, we can rather pass a list of items, i.e., <code node="[object Object]">[ListItem]</code>, where each item only consists of UI-related data (e.g., <code node="[object Object]">title</code> or <code node="[object Object]">subtitle</code>) and omits any internal data that is repository-specific. Similarly, view actions are translated into domain-specific actions that are forwarded by the view store to the bloc. Excluding business- and domain-specific knowledge out of the view keeps them lean and facilitates simplified previews using mock data in Xcode.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Having established an architectural overview of the app, let&#x27;s focus on the business logic in terms of the processing pipeline and CSV export.</p>
<h1>Business Logic:</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Users can select manifests in <em>Licenses</em> by either dragging them on top of the application&#x27;s window or choosing them manually from disk. In this regard, it does not matter whether a single or multiple files are selected or whether they are kept in an enclosing folder. Either way, <em>Licenses</em> searches for manifests at the specified location and forwards their <code node="[object Object]">filePaths: [URL]</code> to the processing pipeline. As soon as licenses could be derived, the user can export them into a single spreadsheet file (CSV).</p>
<h2>The Manifest Processing Pipeline:</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">As illustrated in figure 2, decoding and extracting licenses involves three consecutive steps:</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_flow.png"/></p>
<h3>Step 1: Manifest Publisher:</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">First, <em>Licenses</em> searches for files named &quot;Package.resolved&quot; (SwiftPm), &quot;Cartfile.resolved&quot; (Carthage) or &quot;Podfile.lock&quot; (CocoaPods) and instantiates a <code node="[object Object]">Manifest</code> for each occurence respectively.</p>
<pre><code class="language-swift" node="[object Object]">import Combine
import Foundation

struct ManifestPublisher: Publisher {
    typealias Output = Manifest
    typealias Failure = Never

    private let subject: PassthroughSubject&lt;Manifest, Never&gt; = .init()
    private let dispatchGroup: DispatchGroup = .init()
    private let dispatchQueue: DispatchQueue = .global(qos: .userInitiated)
    private let filePaths: [URL]

    init(filePaths: [URL] = []) {
        self.filePaths = filePaths
    }

    func receive&lt;S&gt;(subscriber: S) where S: Subscriber, Self.Failure == S.Failure, Self.Output == S.Input {
        subject.subscribe(subscriber)

        search(at: filePaths)
    }

    private func search(at filePaths: [URL] = []) {
        filePaths.forEach { filePath in
            dispatchGroup.enter()
            dispatchQueue.async(group: dispatchGroup) {
                defer { self.dispatchGroup.leave() }

                var isDirectory: ObjCBool = false
                let fileManager: FileManager = .init()

                guard fileManager.fileExists(atPath: filePath.path, isDirectory: &amp;isDirectory) else { return }

                if isDirectory.boolValue {
                    let enumerator = fileManager.enumerator(at: filePath, includingPropertiesForKeys: nil)
                    while let nextFilePath: URL = enumerator?.nextObject() as? URL {
                        guard let manifest = Manifest(fromFilePath: nextFilePath) else { continue }

                        self.subject.send(manifest)
                    }
                } else {
                    guard let manifest = Manifest(fromFilePath: filePath) else { return }

                    self.subject.send(manifest)
                }
            }
        }

        dispatchGroup.notify(queue: .main) {
            self.subject.send(completion: .finished)
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">The initializer matches the last component of the given file path against a predefined set of identifiers. As soon as a match is made, the package manager associated with the file name is assigned to the manifest. Note that the latter is required to determine the decoding strategy that is used to derive packages from the manifest.</p>
<pre><code class="language-swift" node="[object Object]">struct Manifest: Equatable {
    var packageManager: PackageManager
    var content: String
    var filePath: URL

    init(
        packageManager: PackageManager,
        content: String,
        filePath: URL
    ) {
        self.packageManager = packageManager
        self.content = content
        self.filePath = filePath
    }

    init?(fromFilePath filePath: URL) {
        switch filePath.lastPathComponent {
        case &quot;Cartfile.resolved&quot;:
            self.packageManager = .carthage

        case &quot;Podfile.lock&quot;:
            self.packageManager = .cocoaPods

        case &quot;Package.resolved&quot;:
            self.packageManager = .swiftPm

        default:
            return nil
        }

        guard let content = try? String(contentsOf: filePath, encoding: .utf8) else { return nil }

        self.content = content
        self.filePath = filePath
    }
}

</code></pre>
<h3>Step 2: ManifestDecodingStrategy</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Second, <em>Licenses</em> tries to retrieve the minimum set of data, like the name, author, and version of the package by applying the decoding strategy that is associated with its type. Since the decoding may fail due to syntax errors or missing information, <em>Licenses</em> tries to handle these cases gracefully by continuing decoding the remaining set of manifests.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that the algorithm makes use of the strategy pattern to be easily extensible in the future if new package managers come along. This way, we can define additional strategies by conforming to the <code node="[object Object]">ManifestDecodingStrategy</code> protocol:</p>
<pre><code class="language-swift" node="[object Object]">protocol ManifestDecodingStrategy {
    func decode(content: String) -&gt; AnyPublisher&lt;GithubRepository, Never&gt;
}

</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">As an example, please consider the implementation of the <code node="[object Object]">SwiftPmManifestDecodingStrategy</code> as stated below. If the strategy could decode the given content as <code node="[object Object]">ResolvedPackagesEntity</code> it publishes an instance of <code node="[object Object]">GithubRepository</code> for each package respectively.</p>
<pre><code class="language-swift" node="[object Object]">import Combine
import Foundation

struct SwiftPmManifestDecodingStrategy: ManifestDecodingStrategy {
    func decode(content: String) -&gt; AnyPublisher&lt;GithubRepository, Never&gt; {
        guard
            let data = content.data(using: .utf8),
            let resolvedPackages = try? JSONDecoder().decode(ResolvedPackagesEntity.self, from: data)
        else {
            return Empty&lt;GithubRepository, Never&gt;().eraseToAnyPublisher()
        }

        return resolvedPackages
            .object
            .pins
            .publisher
            .compactMap { (package: PinEntity) -&gt; GithubRepository? in
                guard
                    let (name, author) = GithubRepositoryUrlDecoder.decode(repositoryUrlString: package.repositoryUrl)
                else { return nil }

                let url: URL = GithubRepositoryUrlEncoder.encode(name: name, author: author)

                return .init(
                    packageManager: .swiftPm,
                    name: name,
                    version: package.state.version,
                    author: author,
                    url: url
                )
            }
            .eraseToAnyPublisher()
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">It is important to note that packages derived from CocoaPod manifests do not include their author and hence require additional processing before licenses are fetched using the GitHub API.
The <code node="[object Object]">CocoaPodsRepositoryProcessor</code> takes care of this requirement and uses the package manager&#x27;s centralized registry named &quot;CocoaPodsTrunk&quot; to retrieve the missing information of the package.</p>
<h3>Step 3: LicenseProcessor - Retrieving Licenses from GitHub:</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Finally, given the name and author of a package we have collected sufficient information to retrieve its licenses using the Github API:</p>
<pre><code class="language-swift" node="[object Object]">struct LicenseRepositoryProcessor: RepositoryProcessor {
    func process(repository: GithubRepository) -&gt; AnyPublisher&lt;GithubRepository, Never&gt; {
        guard
            repository.license == nil,
            let (name, author) = GithubRepositoryUrlDecoder.decode(repositoryURL: repository.url)
        else {
            return Just&lt;GithubRepository&gt;(repository)
                .eraseToAnyPublisher()
        }

        return API.requestMappedModel(
            Github.license(name: name, author: author),
            mapper: GithubLicenseModelMapper.map
        )
        .receive(on: RunLoop.main)
        .map { license in
            let modifiedRepository: GithubRepository = repository
            modifiedRepository.license = license
            return modifiedRepository
        }
        .catch { _ in Just&lt;GithubRepository&gt;(repository) }
        .eraseToAnyPublisher()
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that network requests in <em>Licenses</em> are made using <em>Aphrodite</em> (<a href="https://github.com/LinkAndreas/Aphrodite">Link</a>), a lightweight, generic, and reactive network layer that is built on top of Combine and <code node="[object Object]">NSURLSession</code>. This way, the <code node="[object Object]">LicenseRepositoryProcessor</code> does not need to deal with the raw data that is returned from the Github API but rather uses a simplified model that results from the clear entity- and domain model separation offered by Aphrodite.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Consequently, all the above-mentioned steps are executed by the reducer directly or returned as side effects resulting in additional actions that are fed back into the bloc. Thus, state changes can only happen at a predefined location. Subsequently, please find the handling of the <code node="[object Object]">.fetchLicenses</code> action that corresponds to the third step of the processing pipeline:</p>
<pre><code class="language-swift" node="[object Object]">import Combine
import Foundation

struct AppReducer: BlocReducer {
    func reduce(
        state: inout AppState,
        action: AppAction,
        environment: AppEnvironment
    ) -&gt; Effect&lt;AppAction, Never&gt; {
        switch action {
        case .fetchLicenses:
            return state.repositories
                .filter { $0.license == nil }
                .publisher
                .flatMap(maxPublishers: .max(3)) { repository in
                    Just(repository)
                        .flatMap { (repository: GithubRepository) -&gt; AnyPublisher&lt;GithubRepository, Never&gt; in
                            environment.cocoaPodsProcessor.process(repository: repository)
                                .eraseToAnyPublisher()
                        }
                        .flatMap { repository in
                            environment.licenseProcessor.process(repository: repository)
                                .eraseToAnyPublisher()
                        }
                }
                .receive(on: RunLoop.main)
                .map(AppAction.didProcess(repository:))
                .prepend(AppAction.didStartFetchingLicenses)
                .append(AppAction.didStopFetchingLicenses)
                .eraseToEffect()

            ...
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">As a result, we obtain the enriched list of repositories (<code node="[object Object]">[GithubRepository]</code>), ready to be exported or shown in the UI.</p>
<h2>CSV Export</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">To export licenses into a machine-readable format, <em>Licenses</em> uses the <code node="[object Object]">CSVRowFactory</code> to generate the header as well as the body including the <code node="[object Object]">name</code>, <code node="[object Object]">version</code>, <code node="[object Object]">author</code>, and <code node="[object Object]">license</code> of the given repositories. Note that the content of each row gets normalized to avoid malformed data:</p>
<pre><code class="language-swift" node="[object Object]">struct CSVRowFactory {
    func makeRows(from repositories: [GithubRepository]) -&gt; [[String]] {
        [makeHeaderRow()] + repositories.map(makeRow(from:))
    }
}

extension CSVRowFactory {
    private func makeHeaderRow() -&gt; [String] {
        [
            L10n.Csv.Header.Name.title,
            L10n.Csv.Header.Version.title,
            L10n.Csv.Header.PackageManager.title,
            L10n.Csv.Header.Author.title,
            L10n.Csv.Header.LicenseUrl.title,
            L10n.Csv.Header.LicenseName.title,
            L10n.Csv.Header.LicenseContent.title
        ]
    }

    private func makeRow(from repository: GithubRepository) -&gt; [String] {
        normalize(
            row: [
                repository.name,
                repository.version,
                repository.packageManager.rawValue,
                repository.author ?? &quot;&quot;,
                repository.license?.downloadURL ?? &quot;&quot;,
                repository.license?.license?.name ?? &quot;&quot;,
                repository.license?.decodedContent ?? &quot;&quot;
            ]
        )
    }

    private func normalize(row: [String]) -&gt; [String] {
        row.map { string in
            guard string.contains(&quot;\&quot;&quot;) || string.contains(&quot;,&quot;) else { return string }

            let doubleQuotesEscapedString: String = string.replacingOccurrences(of: &quot;\&quot;&quot;, with: &quot;\&quot;\&quot;&quot;)
            return &quot;\(&quot;\&quot;&quot;)\(doubleQuotesEscapedString)\(&quot;\&quot;&quot;)&quot;
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Finally, each generated row is written to the specified destination:</p>
<pre><code class="language-swift" node="[object Object]">import Foundation

enum CSVExporterError: Error {
    case columnMismatch
}

protocol CSVExporter {
    func exportCSV(fromRows rows: [[String]], toDestination destination: URL)
}

struct DefaultCSVExporter: CSVExporter {
    func exportCSV(fromRows rows: [[String]], toDestination destination: URL) {
        do {
            let csvString: String = try makeCSV(fromRows: rows)
            try csvString.write(to: destination, atomically: true, encoding: .utf8)
        } catch {
            print(error.localizedDescription)
        }
    }

    private func makeCSV(fromRows rows: [[String]]) throws -&gt; String {
        var numberOfColumnsInHeader: Int?
        return try (0 ... (rows.count - 1)).reduce(&quot;&quot;) { csv, index in
            let nextRow: [String] = rows[index]

            if index == 0 {
                numberOfColumnsInHeader = nextRow.count
            } else {
                guard
                    let numberOfColumnsInHeader = numberOfColumnsInHeader,
                    nextRow.count == numberOfColumnsInHeader
                else {
                    throw CSVExporterError.columnMismatch
                }
            }

            return csv + (index &gt; 0 ? &quot;\n&quot; : &quot;&quot;) + &quot;\(nextRow.joined(separator: &quot;,&quot;))&quot;
        }
    }
}

</code></pre>
<h1>User Interface</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Having referred to the <em>processing pipeline</em> and CSV export as the main driver of the app, let&#x27;s focus on the UI as well as the challenges that I faced when bringing <em>Licenses</em> to the Mac.</p>
<h2>App Lifecycle</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">With the introduction of the SwiftUI lifecycle at WWDC 2020, Apple removed the need for an <code node="[object Object]">App-/SceneDelegate</code> and offered a declarative API to specify the entry point of the app. <em>Licenses</em> uses a <code node="[object Object]">WindowGroup</code> as well as a preferences pane that is accessible via the menu as its building blocks. Additional entries like the app&#x27;s privacy policy are realized using the <code node="[object Object]">.commands()</code> modifier:</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_menuCommand.png"/></p>
<pre><code class="language-swift" node="[object Object]">import SwiftUI

@main
struct LicensesApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var delegate: AppDelegate

    var body: some Scene {
        WindowGroup {
            WindowContentContainerView()
                .frame(
                    minWidth: 1_000,
                    idealWidth: 1_200,
                    minHeight: 650,
                    idealHeight: 800,
                    alignment: .center
                )
        }.commands {
            CommandGroup(after: .help) {
                Button(L10n.PrivacyPolicy.title) {
                    guard let url = URL(string: L10n.PrivacyPolicy.url) else { return }

                    NSWorkspace.shared.open(url)
                }
            }
        }

        Settings {
            SettingsContainerView()
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">When adopting the SwiftUI lifecycle, it was difficult at first to come up with a solution to specify that the application should terminate as soon as the last window was closed. Luckily, Apple provides the <code node="[object Object]">@NSApplicationDelegateAdaptor</code> property wrapper that supports functionality that is not covered by the declarative approach yet. This way, the intended behavior is specified in an additional <code node="[object Object]">AppDelegate</code> class:</p>
<pre><code class="language-swift" node="[object Object]">final class AppDelegate: NSObject, NSApplicationDelegate {
    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -&gt; Bool {
        return true
    }
}
</code></pre>
<h2>Bloc- and ViewStoreProvider</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Within the window group, container views are used to provide the bloc as well as the view store for the window&#x27;s content view. Note that the <code node="[object Object]">BlocProvider</code> uses the <code node="[object Object]">@StateObject</code> property wrapper internally to ensure that the lifetime of the bloc is bound to the lifespan of the window. To request a bloc via the <code node="[object Object]">BlocProvider</code> we only need to provide the bloc&#x27;s initial state as well as its reducer function that is used for handling state changes of the window. Finally, given the bloc, the <code node="[object Object]">ViewStoreProvider</code> establishes the mapping between the view-specific state/actions as well as the domain-specific state/actions using the <code node="[object Object]">WindowContentViewStateMapper</code> and <code node="[object Object]">WindowContentViewActionMapper</code> respectively. Injecting providers via container views keeps our content views lean and facilitates UI development using SwiftUI previews.</p>
<pre><code class="language-swift" node="[object Object]">struct WindowContentContainerView: View {
    var body: some View {
        BlocProvider&lt;AppState, AppAction, AppEnvironment&gt;(
            initialState: .initial,
            reducer: AppReducer().eraseToAnyBlocReducer(),
            environment: DefaultEnvironment()
        ) { bloc in
            ViewStoreProvider(
                statePublisher: AnyStatePublisher(
                    publisher: bloc,
                    stateMapper: WindowContentViewStateMapper.map(state:)
                ),
                actionReceiver: AnyActionReceiver(
                    receiver: bloc,
                    actionMapper: WindowContentViewActionMapper.map(action:)
                )
            ) { store in
                WindowContentView(store: store)
            }
        }
    }
}
</code></pre>
<h2>Window Content</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">In <em>Licenses</em> the <code node="[object Object]">WindowContentView</code> is made of smaller views that together compose the UI:</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_appStructure.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Hence, the content view uses the <code node="[object Object]">ViewStore</code> of its parent to derive smaller stores that are dedicated for each child. As an example, the file drop area&#x27;s store is derived from the parent by limiting its scope to the <code node="[object Object]">fileDropAreaState</code> property. In addition, the <code node="[object Object]">actionMapper</code> establishes the mapping between <code node="[object Object]">FileDropAreaViewActions</code> and <code node="[object Object]">WindowActions</code>.</p>
<pre><code class="language-swift" node="[object Object]">struct WindowContentView: View {
    @ObservedObject var store: ViewStore&lt;WindowContentViewState, WindowContentViewAction&gt;

    var body: some View {
        FileDropAreaView(
            store: store.derived(
                stateMapper: \.fileDropAreaState,
                actionMapper: WindowContentViewAction.fileDropArea(action:)
            )
        ) {
            NavigationView {
                MasterView(
                    store: store.derived(
                        stateMapper: \.masterState,
                        actionMapper: WindowContentViewAction.master(action:)
                    )
                )
                DetailView(
                    store: store.derived(
                        stateMapper: \.detailState,
                        actionMapper: WindowContentViewAction.detail(action:)
                    )
                )
            }
            .toolbar {
                ToolbarItems(
                    store: store.derived(
                        stateMapper: \.toolbarState,
                        actionMapper: WindowContentViewAction.toolbar(action:)
                    )
                )
            }
        }
        .sheet(
            isPresented: store.binding(
                get: \.isOnboardingPresented,
                send: { isOnboardingPresented in .updateIsOnboardingCompleted(!isOnboardingPresented) }
            ),
            content: {
                OnboardingView(
                    store: store.derived(
                        stateMapper: \.onboardingState,
                        actionMapper: WindowContentViewAction.onboarding(action:)
                    )
                )
            }
        )
        .onAppear { store.send(.didAppear) }
        .onDisappear { store.send(.didDisappear) }
    }
}
</code></pre>
<h3>File Drop Area</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that SwiftUI features the <code node="[object Object]">onDrop(of:isTargeted:content)</code> modifier which is well-suited for our needs. In addition to the supported file type, i.e., &quot;public.file-url&quot;, we also specify a binding to <code node="[object Object]">isTargeted</code> property of the store. Note that the binding is derived from the store such that it sends a <code node="[object Object]">.didUpdateIsTargeted(Bool)</code> action as soon as a change is made. Similarly, the view store is notified by the view when files of the specified type are detected (<code node="[object Object]">.didSelectProviders([NSItemProvider]</code>).</p>
<pre><code class="language-swift" node="[object Object]">import SwiftUI

struct FileDropAreaView&lt;Content: View&gt;: View {
    @ObservedObject var store: ViewStore&lt;FileDropAreaViewState, FileDropAreaViewAction&gt;

    private let content: () -&gt; Content

    init(
        store: ViewStore&lt;FileDropAreaViewState, FileDropAreaViewAction&gt;,
        @ViewBuilder content: @escaping () -&gt; Content
    ) {
        self._store = .init(initialValue: store)
        self.content = content
    }

    var body: some View {
        GeometryReader { geometry in
            Group {
                VStack {
                    self.content()
                        .onDrop(
                            of: store.supportedFileTypes,
                            isTargeted: store.binding(
                                get: \.isTargeted,
                                send: { isTargeted in .didUpdateIsTargeted(isTargeted) }
                            )
                        ) { providers -&gt; Bool in
                            store.send(.didSelectProviders(providers))
                            return true
                        }
                        .border(store.borderColor)
                }
                .frame(width: geometry.size.width, height: geometry.size.height)
            }
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">The file drop area&#x27;s content consists of the <code node="[object Object]">NavigationView</code> that establishes the master-detail relationship between the repository list (master) and the repository&#x27;s detail view. Note that the latter is only shown when repositories exist. Otherwise, a placeholder is shown asking the user to either import manifests manually from disk or to use one of the example-manifests that are bundled with the app.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_placeholder.png"/></p>
<h3>Repository List (Master)</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">As soon as manifests are selected, detected repositories are shown in NavigationView&#x27;s sidebar. Unfortunately, I could not find a solution to specify different styles for the background of a list item, similar to what is offered by the <code node="[object Object]">.emphasized</code> style of <code node="[object Object]">NSTableViewCell</code>. The behavior is desired since we can improve the readability of the selected item by adapting the font color of the title and subtitle label in case that the item is selected:</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_emphasizedState.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Although you can pass a binding to access the selected item, it does not account for the emphasized state of the cell and is only changed when the selection got made. To provide feedback even before the cursor is lifted, I decided to bridge to a standard <code node="[object Object]">NSTableView</code> using the <code node="[object Object]">NSViewControllerRepresentable</code> protocol:</p>
<pre><code class="language-swift" node="[object Object]">import SwiftUI

struct RepositoryListView: NSViewControllerRepresentable {
    @ObservedObject var store: ViewStore&lt;RepositoryListViewState, RepositoryListViewAction&gt;

    func updateNSViewController(_ nsViewController: RepositoryListViewController, context: Context) {
        return
    }

    func makeNSViewController(context: Context) -&gt; RepositoryListViewController {
        return .init(store: store)
    }
}

struct RepositoryListView_Previews: PreviewProvider {
    static var previews: some View {
        RepositoryListView(store: .constant(state: PreviewData.RepositoryList.state))
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that in the future we can drop the <code node="[object Object]">NSTableView</code> and rather use SwiftUI&#x27;s default <code node="[object Object]">List</code> component as soon as the emphasized state is supported. If you are interested in the detailed implementation of the <code node="[object Object]">NSTableView</code> please have a look at the source code on Github (<a href="https://github.com/LinkAndreas/Licenses">Link</a>).</p>
<h3>Repository Metadata (Detail)</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">The detail view of the <code node="[object Object]">NavigationView</code> provides additional metadata about the selected repository, like the license&#x27;s type and content that was fetched using the Github API:</p>
<pre><code class="language-swift" node="[object Object]">struct DetailView: View {
    @ObservedObject var store: ViewStore&lt;DetailViewState, DetailViewAction&gt;

    var body: some View {
        Group {
            ViewStoreWithNonOptionalStateProvider(
                from: store.derived(stateMapper: \.listState).withoutActions,
                success: DetailListView.init(store:),
                failure: ViewStoreWithNonOptionalStateProvider(
                    from: store.derived(
                        stateMapper: \.placeholderState,
                        actionMapper: DetailViewAction.placeholder(action:)
                    ),
                    success: DetailPlaceholderView.init(store:)
                )
            )
        }
        .navigationTitle(store.navigationTitle)
        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that the detail view uses the <code node="[object Object]">ViewStoreWithNonOptionalStateProvider</code> instead of the default <code node="[object Object]">ViewStoreProvider</code> since the parent&#x27;s <code node="[object Object]">listState</code> and <code node="[object Object]">placeholderState</code> may be <code node="[object Object]">nil</code>. The <code node="[object Object]">DetailViewStateMapper</code> decides whether the placeholder or a repository&#x27;s metadata is shown. Hence, the <code node="[object Object]">ViewStoreWithNonOptionalStateProvider</code> only renders the <code node="[object Object]">DetailListView</code> in case that the parent&#x27;s <code node="[object Object]">listState</code> is not <code node="[object Object]">nil</code>. Otherwise the provider fallbacks to the failure case and renders the provided component in case it exists. Similarly, the <code node="[object Object]">DetailPlaceholderView</code> is only shown if the parent&#x27;s <code node="[object Object]">placeholderState</code> is not <code node="[object Object]">nil</code>. This way, the <code node="[object Object]">ViewStoreWithNonOptionalStateProvider</code> provides a non-optional state to the child if the parent&#x27;s state is not <code node="[object Object]">nil</code>. Otherwise, it the <code node="[object Object]">failure</code> view is rendered.</p>
<h3>Toolbar</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">The toolbar provides quick access to the main features of the app. As an example, users can import manifests using the toolbar&#x27;s primary action. Besides, users can toggle the sidebar&#x27;s visibility using the navigation button of the bar. Unfortunately, <code node="[object Object]">NavigationView</code> does not offer a modifier to specify the sidebar&#x27;s visibility. Instead, we can search for the <code node="[object Object]">SplitViewController</code> that is the first responder in the key window and toggle its sidebar:</p>
<pre><code class="language-swift" node="[object Object]">import SwiftUI

struct ToolbarItems: ToolbarContent {
    @ObservedObject var store: ViewStore&lt;ToolbarItemsState, ToolbarItemsAction&gt;

    var body: some ToolbarContent {
        ToolbarItem(placement: .navigation) {
            Button(
                action: {
                    NSApp.keyWindow?.firstResponder?.tryToPerform(
                        #selector(NSSplitViewController.toggleSidebar(_:)),
                        with: nil
                    )
                },
                label: {
                    Image(systemName: store.toggleMenuItemState.imageSystemName)
                        .foregroundColor(Color(store.toggleMenuItemState.tintColor))
                }
            )
            .help(store.toggleMenuItemState.hint)
            .disabled(store.toggleMenuItemState.isDisabled)
        }

        ToolbarItem(placement: .primaryAction) {
            Button(
                action: {
                    FileImporter.openFiles { filePaths in
                        store.send(.didChooseManifests(filePaths))
                    }
                },
                label: {
                    Image(systemName: store.chooseManifestsItemState.imageSystemName)
                        .foregroundColor(Color(store.chooseManifestsItemState.tintColor))
                }
            )
            .help(store.chooseManifestsItemState.hint)
            .disabled(store.chooseManifestsItemState.isDisabled)
        }
        ToolbarItemGroup(placement: .automatic) {
            Button(
                action: { store.send(.didTriggerRefresh) },
                label: {
                    Image(systemName: store.refreshItemState.imageSystemName)
                        .foregroundColor(Color(store.refreshItemState.tintColor))
                }
            )
            .disabled(store.refreshItemState.isDisabled)
            .help(store.refreshItemState.hint)
            Button(
                action: {
                    FileExporter.exportFile { destination in
                        store.send(.didChooseExportDestination(destination))
                    }
                },
                label: {
                    Image(systemName: store.exportItemState.imageSystemName)
                        .foregroundColor(Color(store.exportItemState.tintColor))
                }
            )
            .disabled(store.exportItemState.isDisabled)
            .help(store.exportItemState.hint)
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">To prevent unintended behavior while licenses are fetched, we disable the toolbar buttons using the <code node="[object Object]">.disabled()</code> modifier. Also, the <code node="[object Object]">.help()</code> modifier attaches a tooltip to each button, providing additional guidance for the user.</p>
<h3>Onboarding</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Finally, the <code node="[object Object]">.sheet()</code> modifier is used to present the <code node="[object Object]">OnboardingView</code> in case that <em>Licenses</em> is opened for the very first time.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock__t65UQ" style="color:transparent" src="/images/article_09_03_2021_onboarding.png"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Note that we do not specify an action mapper, since the <code node="[object Object]">SupportedManifestsView</code> is static and does not include any interaction. Instead, we use the <code node="[object Object]">.withoutActions</code> property to derive an actionless store from the parent.</p>
<pre><code class="language-swift" node="[object Object]">import SwiftUI

struct OnboardingView: View {
    @ObservedObject var store: ViewStore&lt;OnboardingViewState, OnboardingViewAction&gt;

    var body: some View {
        VStack(spacing: 16) {
            VStack(spacing: 0) {
                Image(&quot;icon&quot;)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 90, height: 90, alignment: .center)
                Spacer()
                    .frame(height: 16)
                Text(store.title)
                    .font(.largeTitle)
                Spacer()
                    .frame(height: 16)
                Text(store.subtitle)
                    .multilineTextAlignment(.center)
                Spacer()
                    .frame(height: 16)
                SupportedManifestsView(
                    store: store.derived(stateMapper: \.supportedManifestsState).withoutActions
                )
            }

            Spacer()

            Button(store.primaryButtonTitle) {
                store.send(.didTriggerPrimaryButton)
            }
            .buttonStyle(BrandedButtonStyle())
        }
        .padding(48)
        .frame(width: 500, height: 500, alignment: .center)
    }
}
</code></pre>
<h1>Conclusion</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">This article walked you through the steps that I took when building a native Mac app using <em>SwiftUI 2.0</em> and <em>Combine</em> from scratch. This way, I wanted to explore the capabilities of Swift UI and tried to examine whether it can be used in production. Even though a lot of the things that are offered by UIKit, like the <code node="[object Object]">.emphasized</code> background style of a cell, are still missing, I appreciate the declarative nature of SwiftUI on the Mac. This way, we can avoid spending time on standard components like the master-detail view and rather focus on features that make up the app.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__kuQm3">Happy Coding 🚀</p>
<h1>References:</h1>
<ul>
<li><a href="https://github.com/mono0926/LicensePlist">LicensePlist</a> - Masayuki Ono</li>
<li><a href="https://github.com/pointfreeco/swift-composable-architecture">The Composable Architecture</a> - Point-Free</li>
<li><a href="https://swiftwithmajid.com/2019/09/18/redux-like-state-container-in-swiftui/">Redux like state Containers in SwiftUI</a> - Swift with Majid</li>
</ul></div></div><footer class="Footer_footer__pJUho"><p>Made by<!-- --> <a class="inline" href="/about">Andreas Link</a> <!-- -->in Karlsruhe</p><div><div><a href="https://www.iubenda.com/privacy-policy/86928215" class="iubenda-black no-brand iubenda-noiframe iubenda-embed iubenda-noiframe ">Privacy Policy</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"09_03_2021","date":"9th of March 2021","markdown":"![Licenses App](article_09_03_2021_app.png)\n\n# Building a native macOS app using SwiftUI and Combine\n\nHave you ever been asked to put together the list of licenses of all frameworks that are used within your iOS, iPad OS, or macOS app? Manually completing this task quickly becomes tedious but may be required due to legal- or customer requests.\n\nTo mitigate this issue, I developed **Licenses**, a native macOS app that automates this procedure by collecting and exporting your licenses into a single spreadsheet (CSV) file.\n\nIn this article, I want to share my experience as well as the challenges that I faced when developing the app using _SwiftUI 2.0_ and _Combine_. This way, I hope to provide additional documentation on how declarative macOS apps can be built and to encourage others to also bring their ideas to the Mac.\n\nYou can get the latest version of Licenses in the Mac AppStore ([Link](https://apps.apple.com/us/app/licenses/id1545822966)) or check out the project on GitHub ([Link](https://github.com/LinkAndreas/Licenses)).\n\n# Architecture\n\n_Licenses_, uses a redux-inspired architecture, as illustrated in figure 1, consisting of Data-, Bloc-, ViewStore- and UI-related components. This way, state changes only occur within the bloc's reducer function, transforming incoming actions as well as the current state to an updated state that is ultimately consumed by the UI.\n\n![Architecture](article_09_03_2021_architecture.png)\n\nAlso, side effects are performed by returning publishers from the reducer resulting in additional actions that are sent to the bloc. Hence, asynchronous work is treated similarly to synchronous work in the way that it only affects the state from within the reducer. Thus, the correctness of the reducer and as such the correctness of all state changes becomes testable through unit tests.\n\nNote that blocs are not directly connected to the UI, but rather via view stores that act as the main communication gateway of the view. As a result, domain-specific knowledge is not exposed, but rather gets translated into view-specific models that only include the formatted data that is ready to be shown in the UI. As an example, instead of passing repositories, i.e., `[GitHubRepository]`, to the view directly, we can rather pass a list of items, i.e., `[ListItem]`, where each item only consists of UI-related data (e.g., `title` or `subtitle`) and omits any internal data that is repository-specific. Similarly, view actions are translated into domain-specific actions that are forwarded by the view store to the bloc. Excluding business- and domain-specific knowledge out of the view keeps them lean and facilitates simplified previews using mock data in Xcode.\n\nHaving established an architectural overview of the app, let's focus on the business logic in terms of the processing pipeline and CSV export.\n\n# Business Logic:\n\nUsers can select manifests in _Licenses_ by either dragging them on top of the application's window or choosing them manually from disk. In this regard, it does not matter whether a single or multiple files are selected or whether they are kept in an enclosing folder. Either way, _Licenses_ searches for manifests at the specified location and forwards their `filePaths: [URL]` to the processing pipeline. As soon as licenses could be derived, the user can export them into a single spreadsheet file (CSV).\n\n## The Manifest Processing Pipeline:\n\nAs illustrated in figure 2, decoding and extracting licenses involves three consecutive steps:\n\n![Manifest Processing Pipeline](article_09_03_2021_flow.png)\n\n### Step 1: Manifest Publisher:\n\nFirst, _Licenses_ searches for files named \"Package.resolved\" (SwiftPm), \"Cartfile.resolved\" (Carthage) or \"Podfile.lock\" (CocoaPods) and instantiates a `Manifest` for each occurence respectively.\n\n```swift\nimport Combine\nimport Foundation\n\nstruct ManifestPublisher: Publisher {\n    typealias Output = Manifest\n    typealias Failure = Never\n\n    private let subject: PassthroughSubject\u003cManifest, Never\u003e = .init()\n    private let dispatchGroup: DispatchGroup = .init()\n    private let dispatchQueue: DispatchQueue = .global(qos: .userInitiated)\n    private let filePaths: [URL]\n\n    init(filePaths: [URL] = []) {\n        self.filePaths = filePaths\n    }\n\n    func receive\u003cS\u003e(subscriber: S) where S: Subscriber, Self.Failure == S.Failure, Self.Output == S.Input {\n        subject.subscribe(subscriber)\n\n        search(at: filePaths)\n    }\n\n    private func search(at filePaths: [URL] = []) {\n        filePaths.forEach { filePath in\n            dispatchGroup.enter()\n            dispatchQueue.async(group: dispatchGroup) {\n                defer { self.dispatchGroup.leave() }\n\n                var isDirectory: ObjCBool = false\n                let fileManager: FileManager = .init()\n\n                guard fileManager.fileExists(atPath: filePath.path, isDirectory: \u0026isDirectory) else { return }\n\n                if isDirectory.boolValue {\n                    let enumerator = fileManager.enumerator(at: filePath, includingPropertiesForKeys: nil)\n                    while let nextFilePath: URL = enumerator?.nextObject() as? URL {\n                        guard let manifest = Manifest(fromFilePath: nextFilePath) else { continue }\n\n                        self.subject.send(manifest)\n                    }\n                } else {\n                    guard let manifest = Manifest(fromFilePath: filePath) else { return }\n\n                    self.subject.send(manifest)\n                }\n            }\n        }\n\n        dispatchGroup.notify(queue: .main) {\n            self.subject.send(completion: .finished)\n        }\n    }\n}\n```\n\nThe initializer matches the last component of the given file path against a predefined set of identifiers. As soon as a match is made, the package manager associated with the file name is assigned to the manifest. Note that the latter is required to determine the decoding strategy that is used to derive packages from the manifest.\n\n```swift\nstruct Manifest: Equatable {\n    var packageManager: PackageManager\n    var content: String\n    var filePath: URL\n\n    init(\n        packageManager: PackageManager,\n        content: String,\n        filePath: URL\n    ) {\n        self.packageManager = packageManager\n        self.content = content\n        self.filePath = filePath\n    }\n\n    init?(fromFilePath filePath: URL) {\n        switch filePath.lastPathComponent {\n        case \"Cartfile.resolved\":\n            self.packageManager = .carthage\n\n        case \"Podfile.lock\":\n            self.packageManager = .cocoaPods\n\n        case \"Package.resolved\":\n            self.packageManager = .swiftPm\n\n        default:\n            return nil\n        }\n\n        guard let content = try? String(contentsOf: filePath, encoding: .utf8) else { return nil }\n\n        self.content = content\n        self.filePath = filePath\n    }\n}\n\n```\n\n### Step 2: ManifestDecodingStrategy\n\nSecond, _Licenses_ tries to retrieve the minimum set of data, like the name, author, and version of the package by applying the decoding strategy that is associated with its type. Since the decoding may fail due to syntax errors or missing information, _Licenses_ tries to handle these cases gracefully by continuing decoding the remaining set of manifests.\n\nNote that the algorithm makes use of the strategy pattern to be easily extensible in the future if new package managers come along. This way, we can define additional strategies by conforming to the `ManifestDecodingStrategy` protocol:\n\n```swift\nprotocol ManifestDecodingStrategy {\n    func decode(content: String) -\u003e AnyPublisher\u003cGithubRepository, Never\u003e\n}\n\n```\n\nAs an example, please consider the implementation of the `SwiftPmManifestDecodingStrategy` as stated below. If the strategy could decode the given content as `ResolvedPackagesEntity` it publishes an instance of `GithubRepository` for each package respectively.\n\n```swift\nimport Combine\nimport Foundation\n\nstruct SwiftPmManifestDecodingStrategy: ManifestDecodingStrategy {\n    func decode(content: String) -\u003e AnyPublisher\u003cGithubRepository, Never\u003e {\n        guard\n            let data = content.data(using: .utf8),\n            let resolvedPackages = try? JSONDecoder().decode(ResolvedPackagesEntity.self, from: data)\n        else {\n            return Empty\u003cGithubRepository, Never\u003e().eraseToAnyPublisher()\n        }\n\n        return resolvedPackages\n            .object\n            .pins\n            .publisher\n            .compactMap { (package: PinEntity) -\u003e GithubRepository? in\n                guard\n                    let (name, author) = GithubRepositoryUrlDecoder.decode(repositoryUrlString: package.repositoryUrl)\n                else { return nil }\n\n                let url: URL = GithubRepositoryUrlEncoder.encode(name: name, author: author)\n\n                return .init(\n                    packageManager: .swiftPm,\n                    name: name,\n                    version: package.state.version,\n                    author: author,\n                    url: url\n                )\n            }\n            .eraseToAnyPublisher()\n    }\n}\n```\n\nIt is important to note that packages derived from CocoaPod manifests do not include their author and hence require additional processing before licenses are fetched using the GitHub API.\nThe `CocoaPodsRepositoryProcessor` takes care of this requirement and uses the package manager's centralized registry named \"CocoaPodsTrunk\" to retrieve the missing information of the package.\n\n### Step 3: LicenseProcessor - Retrieving Licenses from GitHub:\n\nFinally, given the name and author of a package we have collected sufficient information to retrieve its licenses using the Github API:\n\n```swift\nstruct LicenseRepositoryProcessor: RepositoryProcessor {\n    func process(repository: GithubRepository) -\u003e AnyPublisher\u003cGithubRepository, Never\u003e {\n        guard\n            repository.license == nil,\n            let (name, author) = GithubRepositoryUrlDecoder.decode(repositoryURL: repository.url)\n        else {\n            return Just\u003cGithubRepository\u003e(repository)\n                .eraseToAnyPublisher()\n        }\n\n        return API.requestMappedModel(\n            Github.license(name: name, author: author),\n            mapper: GithubLicenseModelMapper.map\n        )\n        .receive(on: RunLoop.main)\n        .map { license in\n            let modifiedRepository: GithubRepository = repository\n            modifiedRepository.license = license\n            return modifiedRepository\n        }\n        .catch { _ in Just\u003cGithubRepository\u003e(repository) }\n        .eraseToAnyPublisher()\n    }\n}\n```\n\nNote that network requests in _Licenses_ are made using _Aphrodite_ ([Link](https://github.com/LinkAndreas/Aphrodite)), a lightweight, generic, and reactive network layer that is built on top of Combine and `NSURLSession`. This way, the `LicenseRepositoryProcessor` does not need to deal with the raw data that is returned from the Github API but rather uses a simplified model that results from the clear entity- and domain model separation offered by Aphrodite.\n\nConsequently, all the above-mentioned steps are executed by the reducer directly or returned as side effects resulting in additional actions that are fed back into the bloc. Thus, state changes can only happen at a predefined location. Subsequently, please find the handling of the `.fetchLicenses` action that corresponds to the third step of the processing pipeline:\n\n```swift\nimport Combine\nimport Foundation\n\nstruct AppReducer: BlocReducer {\n    func reduce(\n        state: inout AppState,\n        action: AppAction,\n        environment: AppEnvironment\n    ) -\u003e Effect\u003cAppAction, Never\u003e {\n        switch action {\n        case .fetchLicenses:\n            return state.repositories\n                .filter { $0.license == nil }\n                .publisher\n                .flatMap(maxPublishers: .max(3)) { repository in\n                    Just(repository)\n                        .flatMap { (repository: GithubRepository) -\u003e AnyPublisher\u003cGithubRepository, Never\u003e in\n                            environment.cocoaPodsProcessor.process(repository: repository)\n                                .eraseToAnyPublisher()\n                        }\n                        .flatMap { repository in\n                            environment.licenseProcessor.process(repository: repository)\n                                .eraseToAnyPublisher()\n                        }\n                }\n                .receive(on: RunLoop.main)\n                .map(AppAction.didProcess(repository:))\n                .prepend(AppAction.didStartFetchingLicenses)\n                .append(AppAction.didStopFetchingLicenses)\n                .eraseToEffect()\n\n            ...\n        }\n    }\n}\n```\n\nAs a result, we obtain the enriched list of repositories (`[GithubRepository]`), ready to be exported or shown in the UI.\n\n## CSV Export\n\nTo export licenses into a machine-readable format, _Licenses_ uses the `CSVRowFactory` to generate the header as well as the body including the `name`, `version`, `author`, and `license` of the given repositories. Note that the content of each row gets normalized to avoid malformed data:\n\n```swift\nstruct CSVRowFactory {\n    func makeRows(from repositories: [GithubRepository]) -\u003e [[String]] {\n        [makeHeaderRow()] + repositories.map(makeRow(from:))\n    }\n}\n\nextension CSVRowFactory {\n    private func makeHeaderRow() -\u003e [String] {\n        [\n            L10n.Csv.Header.Name.title,\n            L10n.Csv.Header.Version.title,\n            L10n.Csv.Header.PackageManager.title,\n            L10n.Csv.Header.Author.title,\n            L10n.Csv.Header.LicenseUrl.title,\n            L10n.Csv.Header.LicenseName.title,\n            L10n.Csv.Header.LicenseContent.title\n        ]\n    }\n\n    private func makeRow(from repository: GithubRepository) -\u003e [String] {\n        normalize(\n            row: [\n                repository.name,\n                repository.version,\n                repository.packageManager.rawValue,\n                repository.author ?? \"\",\n                repository.license?.downloadURL ?? \"\",\n                repository.license?.license?.name ?? \"\",\n                repository.license?.decodedContent ?? \"\"\n            ]\n        )\n    }\n\n    private func normalize(row: [String]) -\u003e [String] {\n        row.map { string in\n            guard string.contains(\"\\\"\") || string.contains(\",\") else { return string }\n\n            let doubleQuotesEscapedString: String = string.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")\n            return \"\\(\"\\\"\")\\(doubleQuotesEscapedString)\\(\"\\\"\")\"\n        }\n    }\n}\n```\n\nFinally, each generated row is written to the specified destination:\n\n```swift\nimport Foundation\n\nenum CSVExporterError: Error {\n    case columnMismatch\n}\n\nprotocol CSVExporter {\n    func exportCSV(fromRows rows: [[String]], toDestination destination: URL)\n}\n\nstruct DefaultCSVExporter: CSVExporter {\n    func exportCSV(fromRows rows: [[String]], toDestination destination: URL) {\n        do {\n            let csvString: String = try makeCSV(fromRows: rows)\n            try csvString.write(to: destination, atomically: true, encoding: .utf8)\n        } catch {\n            print(error.localizedDescription)\n        }\n    }\n\n    private func makeCSV(fromRows rows: [[String]]) throws -\u003e String {\n        var numberOfColumnsInHeader: Int?\n        return try (0 ... (rows.count - 1)).reduce(\"\") { csv, index in\n            let nextRow: [String] = rows[index]\n\n            if index == 0 {\n                numberOfColumnsInHeader = nextRow.count\n            } else {\n                guard\n                    let numberOfColumnsInHeader = numberOfColumnsInHeader,\n                    nextRow.count == numberOfColumnsInHeader\n                else {\n                    throw CSVExporterError.columnMismatch\n                }\n            }\n\n            return csv + (index \u003e 0 ? \"\\n\" : \"\") + \"\\(nextRow.joined(separator: \",\"))\"\n        }\n    }\n}\n\n```\n\n# User Interface\n\nHaving referred to the _processing pipeline_ and CSV export as the main driver of the app, let's focus on the UI as well as the challenges that I faced when bringing _Licenses_ to the Mac.\n\n## App Lifecycle\n\nWith the introduction of the SwiftUI lifecycle at WWDC 2020, Apple removed the need for an `App-/SceneDelegate` and offered a declarative API to specify the entry point of the app. _Licenses_ uses a `WindowGroup` as well as a preferences pane that is accessible via the menu as its building blocks. Additional entries like the app's privacy policy are realized using the `.commands()` modifier:\n\n![Menu Command](article_09_03_2021_menuCommand.png)\n\n```swift\nimport SwiftUI\n\n@main\nstruct LicensesApp: App {\n    @NSApplicationDelegateAdaptor(AppDelegate.self) var delegate: AppDelegate\n\n    var body: some Scene {\n        WindowGroup {\n            WindowContentContainerView()\n                .frame(\n                    minWidth: 1_000,\n                    idealWidth: 1_200,\n                    minHeight: 650,\n                    idealHeight: 800,\n                    alignment: .center\n                )\n        }.commands {\n            CommandGroup(after: .help) {\n                Button(L10n.PrivacyPolicy.title) {\n                    guard let url = URL(string: L10n.PrivacyPolicy.url) else { return }\n\n                    NSWorkspace.shared.open(url)\n                }\n            }\n        }\n\n        Settings {\n            SettingsContainerView()\n        }\n    }\n}\n```\n\nWhen adopting the SwiftUI lifecycle, it was difficult at first to come up with a solution to specify that the application should terminate as soon as the last window was closed. Luckily, Apple provides the `@NSApplicationDelegateAdaptor` property wrapper that supports functionality that is not covered by the declarative approach yet. This way, the intended behavior is specified in an additional `AppDelegate` class:\n\n```swift\nfinal class AppDelegate: NSObject, NSApplicationDelegate {\n    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -\u003e Bool {\n        return true\n    }\n}\n```\n\n## Bloc- and ViewStoreProvider\n\nWithin the window group, container views are used to provide the bloc as well as the view store for the window's content view. Note that the `BlocProvider` uses the `@StateObject` property wrapper internally to ensure that the lifetime of the bloc is bound to the lifespan of the window. To request a bloc via the `BlocProvider` we only need to provide the bloc's initial state as well as its reducer function that is used for handling state changes of the window. Finally, given the bloc, the `ViewStoreProvider` establishes the mapping between the view-specific state/actions as well as the domain-specific state/actions using the `WindowContentViewStateMapper` and `WindowContentViewActionMapper` respectively. Injecting providers via container views keeps our content views lean and facilitates UI development using SwiftUI previews.\n\n```swift\nstruct WindowContentContainerView: View {\n    var body: some View {\n        BlocProvider\u003cAppState, AppAction, AppEnvironment\u003e(\n            initialState: .initial,\n            reducer: AppReducer().eraseToAnyBlocReducer(),\n            environment: DefaultEnvironment()\n        ) { bloc in\n            ViewStoreProvider(\n                statePublisher: AnyStatePublisher(\n                    publisher: bloc,\n                    stateMapper: WindowContentViewStateMapper.map(state:)\n                ),\n                actionReceiver: AnyActionReceiver(\n                    receiver: bloc,\n                    actionMapper: WindowContentViewActionMapper.map(action:)\n                )\n            ) { store in\n                WindowContentView(store: store)\n            }\n        }\n    }\n}\n```\n\n## Window Content\n\nIn _Licenses_ the `WindowContentView` is made of smaller views that together compose the UI:\n\n![App Structure](article_09_03_2021_appStructure.png)\n\nHence, the content view uses the `ViewStore` of its parent to derive smaller stores that are dedicated for each child. As an example, the file drop area's store is derived from the parent by limiting its scope to the `fileDropAreaState` property. In addition, the `actionMapper` establishes the mapping between `FileDropAreaViewActions` and `WindowActions`.\n\n```swift\nstruct WindowContentView: View {\n    @ObservedObject var store: ViewStore\u003cWindowContentViewState, WindowContentViewAction\u003e\n\n    var body: some View {\n        FileDropAreaView(\n            store: store.derived(\n                stateMapper: \\.fileDropAreaState,\n                actionMapper: WindowContentViewAction.fileDropArea(action:)\n            )\n        ) {\n            NavigationView {\n                MasterView(\n                    store: store.derived(\n                        stateMapper: \\.masterState,\n                        actionMapper: WindowContentViewAction.master(action:)\n                    )\n                )\n                DetailView(\n                    store: store.derived(\n                        stateMapper: \\.detailState,\n                        actionMapper: WindowContentViewAction.detail(action:)\n                    )\n                )\n            }\n            .toolbar {\n                ToolbarItems(\n                    store: store.derived(\n                        stateMapper: \\.toolbarState,\n                        actionMapper: WindowContentViewAction.toolbar(action:)\n                    )\n                )\n            }\n        }\n        .sheet(\n            isPresented: store.binding(\n                get: \\.isOnboardingPresented,\n                send: { isOnboardingPresented in .updateIsOnboardingCompleted(!isOnboardingPresented) }\n            ),\n            content: {\n                OnboardingView(\n                    store: store.derived(\n                        stateMapper: \\.onboardingState,\n                        actionMapper: WindowContentViewAction.onboarding(action:)\n                    )\n                )\n            }\n        )\n        .onAppear { store.send(.didAppear) }\n        .onDisappear { store.send(.didDisappear) }\n    }\n}\n```\n\n### File Drop Area\n\nNote that SwiftUI features the `onDrop(of:isTargeted:content)` modifier which is well-suited for our needs. In addition to the supported file type, i.e., \"public.file-url\", we also specify a binding to `isTargeted` property of the store. Note that the binding is derived from the store such that it sends a `.didUpdateIsTargeted(Bool)` action as soon as a change is made. Similarly, the view store is notified by the view when files of the specified type are detected (`.didSelectProviders([NSItemProvider]`).\n\n```swift\nimport SwiftUI\n\nstruct FileDropAreaView\u003cContent: View\u003e: View {\n    @ObservedObject var store: ViewStore\u003cFileDropAreaViewState, FileDropAreaViewAction\u003e\n\n    private let content: () -\u003e Content\n\n    init(\n        store: ViewStore\u003cFileDropAreaViewState, FileDropAreaViewAction\u003e,\n        @ViewBuilder content: @escaping () -\u003e Content\n    ) {\n        self._store = .init(initialValue: store)\n        self.content = content\n    }\n\n    var body: some View {\n        GeometryReader { geometry in\n            Group {\n                VStack {\n                    self.content()\n                        .onDrop(\n                            of: store.supportedFileTypes,\n                            isTargeted: store.binding(\n                                get: \\.isTargeted,\n                                send: { isTargeted in .didUpdateIsTargeted(isTargeted) }\n                            )\n                        ) { providers -\u003e Bool in\n                            store.send(.didSelectProviders(providers))\n                            return true\n                        }\n                        .border(store.borderColor)\n                }\n                .frame(width: geometry.size.width, height: geometry.size.height)\n            }\n        }\n    }\n}\n```\n\nThe file drop area's content consists of the `NavigationView` that establishes the master-detail relationship between the repository list (master) and the repository's detail view. Note that the latter is only shown when repositories exist. Otherwise, a placeholder is shown asking the user to either import manifests manually from disk or to use one of the example-manifests that are bundled with the app.\n\n![Detail Placeholder](article_09_03_2021_placeholder.png)\n\n### Repository List (Master)\n\nAs soon as manifests are selected, detected repositories are shown in NavigationView's sidebar. Unfortunately, I could not find a solution to specify different styles for the background of a list item, similar to what is offered by the `.emphasized` style of `NSTableViewCell`. The behavior is desired since we can improve the readability of the selected item by adapting the font color of the title and subtitle label in case that the item is selected:\n\n![Emphasized State](article_09_03_2021_emphasizedState.png)\n\nAlthough you can pass a binding to access the selected item, it does not account for the emphasized state of the cell and is only changed when the selection got made. To provide feedback even before the cursor is lifted, I decided to bridge to a standard `NSTableView` using the `NSViewControllerRepresentable` protocol:\n\n```swift\nimport SwiftUI\n\nstruct RepositoryListView: NSViewControllerRepresentable {\n    @ObservedObject var store: ViewStore\u003cRepositoryListViewState, RepositoryListViewAction\u003e\n\n    func updateNSViewController(_ nsViewController: RepositoryListViewController, context: Context) {\n        return\n    }\n\n    func makeNSViewController(context: Context) -\u003e RepositoryListViewController {\n        return .init(store: store)\n    }\n}\n\nstruct RepositoryListView_Previews: PreviewProvider {\n    static var previews: some View {\n        RepositoryListView(store: .constant(state: PreviewData.RepositoryList.state))\n    }\n}\n```\n\nNote that in the future we can drop the `NSTableView` and rather use SwiftUI's default `List` component as soon as the emphasized state is supported. If you are interested in the detailed implementation of the `NSTableView` please have a look at the source code on Github ([Link](https://github.com/LinkAndreas/Licenses)).\n\n### Repository Metadata (Detail)\n\nThe detail view of the `NavigationView` provides additional metadata about the selected repository, like the license's type and content that was fetched using the Github API:\n\n```swift\nstruct DetailView: View {\n    @ObservedObject var store: ViewStore\u003cDetailViewState, DetailViewAction\u003e\n\n    var body: some View {\n        Group {\n            ViewStoreWithNonOptionalStateProvider(\n                from: store.derived(stateMapper: \\.listState).withoutActions,\n                success: DetailListView.init(store:),\n                failure: ViewStoreWithNonOptionalStateProvider(\n                    from: store.derived(\n                        stateMapper: \\.placeholderState,\n                        actionMapper: DetailViewAction.placeholder(action:)\n                    ),\n                    success: DetailPlaceholderView.init(store:)\n                )\n            )\n        }\n        .navigationTitle(store.navigationTitle)\n        .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity, alignment: .center)\n    }\n}\n```\n\nNote that the detail view uses the `ViewStoreWithNonOptionalStateProvider` instead of the default `ViewStoreProvider` since the parent's `listState` and `placeholderState` may be `nil`. The `DetailViewStateMapper` decides whether the placeholder or a repository's metadata is shown. Hence, the `ViewStoreWithNonOptionalStateProvider` only renders the `DetailListView` in case that the parent's `listState` is not `nil`. Otherwise the provider fallbacks to the failure case and renders the provided component in case it exists. Similarly, the `DetailPlaceholderView` is only shown if the parent's `placeholderState` is not `nil`. This way, the `ViewStoreWithNonOptionalStateProvider` provides a non-optional state to the child if the parent's state is not `nil`. Otherwise, it the `failure` view is rendered.\n\n### Toolbar\n\nThe toolbar provides quick access to the main features of the app. As an example, users can import manifests using the toolbar's primary action. Besides, users can toggle the sidebar's visibility using the navigation button of the bar. Unfortunately, `NavigationView` does not offer a modifier to specify the sidebar's visibility. Instead, we can search for the `SplitViewController` that is the first responder in the key window and toggle its sidebar:\n\n```swift\nimport SwiftUI\n\nstruct ToolbarItems: ToolbarContent {\n    @ObservedObject var store: ViewStore\u003cToolbarItemsState, ToolbarItemsAction\u003e\n\n    var body: some ToolbarContent {\n        ToolbarItem(placement: .navigation) {\n            Button(\n                action: {\n                    NSApp.keyWindow?.firstResponder?.tryToPerform(\n                        #selector(NSSplitViewController.toggleSidebar(_:)),\n                        with: nil\n                    )\n                },\n                label: {\n                    Image(systemName: store.toggleMenuItemState.imageSystemName)\n                        .foregroundColor(Color(store.toggleMenuItemState.tintColor))\n                }\n            )\n            .help(store.toggleMenuItemState.hint)\n            .disabled(store.toggleMenuItemState.isDisabled)\n        }\n\n        ToolbarItem(placement: .primaryAction) {\n            Button(\n                action: {\n                    FileImporter.openFiles { filePaths in\n                        store.send(.didChooseManifests(filePaths))\n                    }\n                },\n                label: {\n                    Image(systemName: store.chooseManifestsItemState.imageSystemName)\n                        .foregroundColor(Color(store.chooseManifestsItemState.tintColor))\n                }\n            )\n            .help(store.chooseManifestsItemState.hint)\n            .disabled(store.chooseManifestsItemState.isDisabled)\n        }\n        ToolbarItemGroup(placement: .automatic) {\n            Button(\n                action: { store.send(.didTriggerRefresh) },\n                label: {\n                    Image(systemName: store.refreshItemState.imageSystemName)\n                        .foregroundColor(Color(store.refreshItemState.tintColor))\n                }\n            )\n            .disabled(store.refreshItemState.isDisabled)\n            .help(store.refreshItemState.hint)\n            Button(\n                action: {\n                    FileExporter.exportFile { destination in\n                        store.send(.didChooseExportDestination(destination))\n                    }\n                },\n                label: {\n                    Image(systemName: store.exportItemState.imageSystemName)\n                        .foregroundColor(Color(store.exportItemState.tintColor))\n                }\n            )\n            .disabled(store.exportItemState.isDisabled)\n            .help(store.exportItemState.hint)\n        }\n    }\n}\n```\n\nTo prevent unintended behavior while licenses are fetched, we disable the toolbar buttons using the `.disabled()` modifier. Also, the `.help()` modifier attaches a tooltip to each button, providing additional guidance for the user.\n\n### Onboarding\n\nFinally, the `.sheet()` modifier is used to present the `OnboardingView` in case that _Licenses_ is opened for the very first time.\n\n![Onboarding](article_09_03_2021_onboarding.png)\n\nNote that we do not specify an action mapper, since the `SupportedManifestsView` is static and does not include any interaction. Instead, we use the `.withoutActions` property to derive an actionless store from the parent.\n\n```swift\nimport SwiftUI\n\nstruct OnboardingView: View {\n    @ObservedObject var store: ViewStore\u003cOnboardingViewState, OnboardingViewAction\u003e\n\n    var body: some View {\n        VStack(spacing: 16) {\n            VStack(spacing: 0) {\n                Image(\"icon\")\n                    .resizable()\n                    .aspectRatio(contentMode: .fit)\n                    .frame(width: 90, height: 90, alignment: .center)\n                Spacer()\n                    .frame(height: 16)\n                Text(store.title)\n                    .font(.largeTitle)\n                Spacer()\n                    .frame(height: 16)\n                Text(store.subtitle)\n                    .multilineTextAlignment(.center)\n                Spacer()\n                    .frame(height: 16)\n                SupportedManifestsView(\n                    store: store.derived(stateMapper: \\.supportedManifestsState).withoutActions\n                )\n            }\n\n            Spacer()\n\n            Button(store.primaryButtonTitle) {\n                store.send(.didTriggerPrimaryButton)\n            }\n            .buttonStyle(BrandedButtonStyle())\n        }\n        .padding(48)\n        .frame(width: 500, height: 500, alignment: .center)\n    }\n}\n```\n\n# Conclusion\n\nThis article walked you through the steps that I took when building a native Mac app using _SwiftUI 2.0_ and _Combine_ from scratch. This way, I wanted to explore the capabilities of Swift UI and tried to examine whether it can be used in production. Even though a lot of the things that are offered by UIKit, like the `.emphasized` background style of a cell, are still missing, I appreciate the declarative nature of SwiftUI on the Mac. This way, we can avoid spending time on standard components like the master-detail view and rather focus on features that make up the app.\n\nHappy Coding 🚀\n\n# References:\n\n- [LicensePlist](https://github.com/mono0926/LicensePlist) - Masayuki Ono\n- [The Composable Architecture](https://github.com/pointfreeco/swift-composable-architecture) - Point-Free\n- [Redux like state Containers in SwiftUI](https://swiftwithmajid.com/2019/09/18/redux-like-state-container-in-swiftui/) - Swift with Majid\n","title":"Building a native macOS app using SwiftUI and Combine","description":"Have you ever been asked to put together the list of licenses \n            of all frameworks that are used within your iOS, iPad OS, or\n            macOS app? Manually completing this task quickly becomes\n            tedious but may be required due to legal- or customer\n            requests.\n    \n            To mitigate this issue, I developed Licenses, a native macOS\n            app that automates this procedure by collecting and exporting\n            your licenses into a single spreadsheet (CSV) file."}},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"09_03_2021"},"buildId":"wGHrzav0idxTY_Smbjgd9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>