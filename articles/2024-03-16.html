<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1.0" data-next-head=""/><meta property="og:type" content="website" data-next-head=""/><meta property="og:locale" content="en_US" data-next-head=""/><title data-next-head="">Networking for Large-Scale iOS Applications</title><meta name="robots" content="index,follow" data-next-head=""/><meta name="description" content="Networking serves as the backbone of mobile applications, 
            facilitating seamless communication and enabling rich user experiences. 
            However, it also introduces complexity, especially when dealing with 
            modular applications that are built from independent features.
            Modularity offers many benefits, such as a faster development cycle 
            and better scalability. But it also requires a robust approach to handle 
            cross-cutting concerns among features. Since networking is a 
            cross-cutting concern, it cannot be easily encapsulated in any of them.
            In this article, we explore a lightweight approach for dealing with 
            networking in modular iOS applications." data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><meta name="twitter:site" content="@site" data-next-head=""/><meta name="twitter:creator" content="@handle" data-next-head=""/><meta property="og:title" content="Networking for Large-Scale iOS Applications" data-next-head=""/><meta property="og:description" content="Networking serves as the backbone of mobile applications, 
            facilitating seamless communication and enabling rich user experiences. 
            However, it also introduces complexity, especially when dealing with 
            modular applications that are built from independent features.
            Modularity offers many benefits, such as a faster development cycle 
            and better scalability. But it also requires a robust approach to handle 
            cross-cutting concerns among features. Since networking is a 
            cross-cutting concern, it cannot be easily encapsulated in any of them.
            In this article, we explore a lightweight approach for dealing with 
            networking in modular iOS applications." data-next-head=""/><meta property="og:url" content="https://www.linkandreas.de/articles/2024-03-16" data-next-head=""/><meta property="og:image" content="https://www.linkandreas.de/images/previews/2024-03-16.jpeg" data-next-head=""/><meta property="og:image:alt" content="Link Preview Image" data-next-head=""/><meta property="og:image:width" content="1200" data-next-head=""/><meta property="og:image:height" content="630" data-next-head=""/><meta property="og:site_name" content="Andreas Link" data-next-head=""/><link rel="canonical" href="https://www.linkandreas.de/articles/2024-03-16" data-next-head=""/><link rel="alternate" type="application/rss+xml" title="linkandreas.de" href="https://linkandreas.de/rss"/><script id="show-banner" data-nscript="beforeInteractive">(function (w,d) {var loader = function () {var s = d.createElement("script"), tag = d.getElementsByTagName("script")[0]; s.src="https://cdn.iubenda.com/iubenda.js"; tag.parentNode.insertBefore(s,tag);}; if(w.addEventListener){w.addEventListener("load", loader, false);}else if(w.attachEvent){w.attachEvent("onload", loader);}else{w.onload = loader;}})(window, document);</script><link rel="preload" href="/_next/static/css/44be9a558f814fbc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/44be9a558f814fbc.css" data-n-g=""/><link rel="preload" href="/_next/static/css/c7e751a366bdd662.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c7e751a366bdd662.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-055d654813485002.js" defer=""></script><script src="/_next/static/chunks/framework-5757d75364ce2279.js" defer=""></script><script src="/_next/static/chunks/main-26ea3299654e380a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a3ee1b13dc5bba02.js" defer=""></script><script src="/_next/static/chunks/587-5f9d9739613bfa25.js" defer=""></script><script src="/_next/static/chunks/881-256a47b766c2830f.js" defer=""></script><script src="/_next/static/chunks/pages/articles/%5Bid%5D-08b52d6dea500653.js" defer=""></script><script src="/_next/static/4waqnF4so0EMGSgX2Zk5E/_buildManifest.js" defer=""></script><script src="/_next/static/4waqnF4so0EMGSgX2Zk5E/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="App_appContainer__O9sO8"><div class="container-fluid"><nav class="navbar navbar-expand-md navbar-dark bg-transparent"><a class="navbar-brand" href="/articles">Andreas Link</a><button aria-controls="responsive-navbar-nav" type="button" aria-label="Toggle navigation" class="navbar-toggler collapsed"><span class="navbar-toggler-icon"></span></button><div class="navbar-collapse collapse" id="responsive-navbar-nav"><div class="ml-auto navbar-nav"><a data-rr-ui-event-key="/articles" class="nav-link" href="/articles">Articles</a><a data-rr-ui-event-key="/licenses" class="nav-link" href="/licenses">Licenses</a><a data-rr-ui-event-key="/timity" class="nav-link" href="/timity">Timity</a><a data-rr-ui-event-key="/publications" class="nav-link" href="/publications">Publications</a><a data-rr-ui-event-key="/about" class="nav-link" href="/about">About</a></div></div></nav></div><div class="App_content__e_Cib"><div class="_id__articleContainer__MKOgu"><h1>Networking for Large-Scale iOS Applications</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Networking serves as the backbone of mobile applications, facilitating seamless communication and enabling rich user experiences. However, it also introduces complexity, especially when dealing with modular applications that are built from independent features.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Modularity offers many benefits, such as a faster development cycle and better scalability. But it also requires a robust approach to handle cross-cutting concerns among features. Since networking is a cross-cutting concern, it cannot be easily encapsulated in any of them.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">In this article, we explore a lightweight approach for dealing with networking in modular iOS applications.</p>
<h2>Naive Approach</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">First, let&#x27;s take a look at the naive approach, where multiple independent features directly depend on the networking package.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_18_02_2024_naive_approach.svg"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Even though the latter encapsulates the ability to communicate over the network, it adds up to the total build time of each feature, since compiling the feature requires compilation of the entire network package as well. Especially when working in feature teams, it is desirable to minimize the amount of direct dependencies so that we can benefit from shorter build times and a fast feedback loop.</p>
<h2>Lightweight Approach in modular Applications</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">To ensure that we do not need to compile the network-related code when working on a feature, we introduce a lightweight abstraction called <code node="[object Object]">HTTPClient</code> that is exposed to every feature but does not contain a concrete implementation.</p>
<pre><code class="language-swift" node="[object Object]">/// Abstraction for executing HTTP network requests.
public protocol HTTPClient {
    /// Executes the given request and returns the received data and response including the StatusCode.
    /// - Parameter request: The request to be executed.
    /// - Returns: The received data and response (including the StatusCode).
    @discardableResult
    func load(request: HTTPRequest) async throws -&gt; (Data, HTTPResponse)
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The abstraction only consists of the <code node="[object Object]">load(request:)</code> method, that given an <code node="[object Object]">HTTPRequest</code> returns the received data along with the <code node="[object Object]">HTTPResponse</code>. The <code node="[object Object]">HTTPRequest</code> contains all information necessary to perform the request, like the <code node="[object Object]">method</code>, <code node="[object Object]">path</code>, <code node="[object Object]">headers</code> and <code node="[object Object]">queryParameters</code>. In addition, the <code node="[object Object]">body</code> parameter is used to specify the content that is transmitted with the request.</p>
<pre><code class="language-swift" node="[object Object]">/// Abstraction describing an HTTP network request.
public protocol HTTPRequest {
    /// The HTTP method of the request.
    var method: HTTPMethod { get }
    /// The path of the request endpoint.
    var path: HTTPPath { get }
    /// The endpoint version of the request.
    var version: HTTPVersion { get }
    /// The headers to be transmitted with the request.
    var headers: HTTPHeaders? { get }
    /// The query parameters to be transmitted with the request.
    var queryParameter: HTTPQueryParameter? { get }
    /// The content to be transmitted with the request.
    var body: Data? { get }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Some parameters are declared <em>optional</em> since they may not be necessary for every request. Hence, developers have the flexibility to omit these parameters, streamlining the implementation and improving code readability.</p>
<pre><code class="language-swift" node="[object Object]">extension HTTPRequest {
    public var headers: HTTPHeaders? { nil }
    public var queryParameter: HTTPQueryParameter? { nil }
    public var body: Data? { nil }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Let&#x27;s briefly go through the meaning of each of the parameters.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">First, the <code node="[object Object]">HTTPMethod</code> enumeration corresponds to the methods permitted for HTTP requests. Alongside <code node="[object Object]">GET</code> for data retrieval, it also includes <code node="[object Object]">POST</code> for creating a resource, as well as <code node="[object Object]">PUT</code> and <code node="[object Object]">PATCH</code> for updating the resource, and <code node="[object Object]">DELETE</code> for removing it when no longer needed.</p>
<pre><code class="language-swift" node="[object Object]">/// The HTTP method of the network request.
public enum HTTPMethod: String, Equatable {
    case get = &quot;GET&quot;
    case post = &quot;POST&quot;
    case put = &quot;PUT&quot;
    case patch = &quot;PATCH&quot;
    case delete = &quot;DELETE&quot;
}

extension HTTPMethod {
    public var name: String {
        rawValue
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Next, the <code node="[object Object]">HTTPPath</code> in conjunction with the <code node="[object Object]">HTTPVersion</code> specifies the endpoint targeted by the request. Both are defined as type aliases of <code node="[object Object]">String</code> to better derive a semantic meaning when looking at the type itself.</p>
<pre><code class="language-swift" node="[object Object]">/// The path of the network request.
public typealias HTTPPath = String
/// The version of the HTTP endpoint.
public typealias HTTPVersion = String
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Next, <code node="[object Object]">HTTPHeader</code> defines standard headers that are included in most requests. For instance, the <code node="[object Object]">contentType</code> attribute specifies the type of content being transmitted in the request body.</p>
<pre><code class="language-swift" node="[object Object]">/// Standard headers that can be transmitted in requests to the backend.
public enum HTTPHeader: String {
    /// The data format accepted by the client (e.g., `application/json`).
    case accept = &quot;Accept&quot;
    /// The type of content being sent in the body (e.g., `application/json`).
    case contentType = &quot;Content-Type&quot;
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Finally, similar to <code node="[object Object]">HTTPPath</code>, both <code node="[object Object]">HTTPHeaders</code> and <code node="[object Object]">HTTPQueryParameter</code> utilize type aliases to give meaning to the underlying <code node="[object Object]">String</code> key-value pairs.</p>
<pre><code class="language-swift" node="[object Object]">/// Dictionary of headers sent or received as key-value pairs in network requests.
public typealias HTTPHeaders = [String: String]
/// Key-value pairs transmitted as query parameters in network requests.
public typealias HTTPQueryParameter = [String: String]
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Having referred to the properties of an <code node="[object Object]">HTTPRequest</code>, let&#x27;s now shift our focus to the <code node="[object Object]">HTTPResponse</code> that is received upon successful execution of <code node="[object Object]">load(request:)</code>.</p>
<pre><code class="language-swift" node="[object Object]">/// Contains the response to a network request.
public struct HTTPResponse {
    /// The StatusCode of the response.
    public let statusCode: HTTPStatusCode
    /// The headers of the response.
    public let headers: HTTPHeaders?

    /// Initializes a `HTTPResponse` for a given StatusCode and Header.
    /// - Parameters:
    ///   - statusCode: The StatusCode of the response.
    ///   - headers: The headers of the response.
    public init(statusCode: HTTPStatusCode, headers: HTTPHeaders? = nil) {
        self.statusCode = statusCode
        self.headers = headers
    }
}

/// The StatusCode contained in a response to a network request.
public typealias HTTPStatusCode = Int
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">In contrast to the request, the <code node="[object Object]">HTTPResponse</code> only comprises two properties: the <code node="[object Object]">statusCode</code> and <code node="[object Object]">headers</code>. While the status code communicates the outcome of the request, the <code node="[object Object]">headers</code> are optional and enable the server to provide supplementary information to the client alongside the response.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Furthermore, extensions are implemented to streamline the determination of the response&#x27;s nature, categorizing it into types such as <code node="[object Object]">informational</code>, <code node="[object Object]">successful</code>, <code node="[object Object]">redirection</code>, <code node="[object Object]">client error</code>, or <code node="[object Object]">server error</code>. This eliminates the need to memorize status code ranges.</p>
<pre><code class="language-swift" node="[object Object]">extension HTTPResponse {
    /// Status indicating whether it is an informational response.
    /// - seealso: For more information, see [mdm web docs - Information responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#information_responses)
    public var isInformational: Bool {
        (100 ..&lt; 200).contains(statusCode)
    }

    /// Status indicating whether it is a successful response.
    /// - seealso: For more information, see [mdm web docs - Successful responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses)
    public var isSuccess: Bool {
        (200 ..&lt; 300).contains(statusCode)
    }

    /// Status indicating whether it is a redirection response.
    /// - seealso: For more information, see [mdm web docs - Redirection messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages)
    public var isRedirectional: Bool {
        (300 ..&lt; 400).contains(statusCode)
    }

    /// Status indicating whether it is a client error response.
    /// - seealso: For more information, see [mdm web docs - Client error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)
    public var isClientError: Bool {
        (400 ..&lt; 500).contains(statusCode)
    }

    /// Status indicating whether it is a server error response.
    /// - seealso: For more information, see [mdm web docs - Server error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)
    public var isServerError: Bool {
        (500 ..&lt; 600).contains(statusCode)
    }

    /// Status indicating whether it is an error response.
    public var isError: Bool {
        (400 ..&lt; 600).contains(statusCode)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">As a result, relying solely on the <code node="[object Object]">HTTPClient</code> abstraction has a negligible impact on the feature&#x27;s build time. Moreover, the feature avoids dealing with 3rd party dependencies like <code node="[object Object]">Moya</code>, <code node="[object Object]">Alamofire</code> or Apple&#x27;s <code node="[object Object]">URLSession</code>. Instead, it only uses the abstraction to communicate over the network and assumes that a concrete implementation will be provided by another entity. This assumption is key for decoupling features from cross-cutting concerns and developing them in isolation.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_18_02_2024_feature_abstraction.svg"/></p>
<h2>Infrastructure: &quot;URLSessionInfrastructure&quot;</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Still, when integrating the feature, we need to ensure that its requirements are fulfilled by a concrete implementation. The latter is provided by infrastructure modules that may use a third-party library to achieve the intended result. For instance, the <code node="[object Object]">URLSessionInfrastructure</code> package may use Apple&#x27;s <code node="[object Object]">URLSession</code> to execute the request.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_18_02_2024_feature_abstraction_infrastructure.svg"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">In this manner, only the infrastructure package directly relies on third-party frameworks, such that each feature stays agnostic from infrastructure details. Below you can find an example implementation of the <code node="[object Object]">URLSessionClient</code>:</p>
<pre><code class="language-swift" node="[object Object]">import Foundation

public final class URLSessionClient: HTTPClient {
    enum Error: Swift.Error {
        case noHttpURLResponse
        case invalidHeaderArguments
    }

    private let baseURL: URL
    private let session: URLSession

    public init(baseURL: URL, session: URLSession = .shared) {
        self.baseURL = baseURL
        self.session = session
    }

    public func load(request: HTTPRequest) async throws -&gt; (Data, HTTPResponse) {
        let url = baseURL
            .appending(path: request.version)
            .appending(path: request.path)

        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = request.method.name
        urlRequest.httpBody = request.body
        urlRequest.allHTTPHeaderFields = request.headers
        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        components?.queryItems = request.queryParameter?.reduce(into: [URLQueryItem]()) { current, next in
            let item = URLQueryItem(name: next.key, value: next.value)
            current.append(item)
        }

        let (data, response) = try await session.data(for: urlRequest)

        guard let httpURLResponse = response as? HTTPURLResponse else {
            throw Error.noHttpURLResponse
        }

        guard let headers = httpURLResponse.allHeaderFields as? [String: String] else {
            throw Error.invalidHeaderArguments
        }

        let HttpResponse = HTTPResponse(statusCode: httpURLResponse.statusCode, headers: headers)
        return (data, HttpResponse)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">First, the <code node="[object Object]">load(request:)</code> method constructs a <code node="[object Object]">URLRequest</code> along with its query items based on the information given in the <code node="[object Object]">HTTPRequest</code>. It&#x27;s important to note that <code node="[object Object]">URLRequest</code> is considered an infrastructure detail, as it&#x27;s provided by Apple&#x27;s <code node="[object Object]">URLSession</code>. Second, the <code node="[object Object]">session</code> is used to execute the request and wait for the reception of a response. Finally, the received response is interpreted as an <code node="[object Object]">HTTPURLResponse</code> from which <code node="[object Object]">headers</code> and <code node="[object Object]">statusCode</code> are extracted.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">By separating the feature from infrastructure details, we can integrate all components within the <em>composition root</em>. The latter serves as the translation layer between modules without requiring them to have knowledge of each other. This way, features can be developed in isolation by different feature teams, which is essential for large-scale modular applications.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_18_02_2024_architecture.svg"/></p>
<h2>Adding Functionality: Decorators</h2>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Especially within large-scale applications, we frequently encounter new or evolving business requirements, such as <em>logging</em> or <em>authentication</em>. Instead of modifying the infrastructure module, we can utilize the decorator pattern to add functionality without altering the underlying implementation. Consider the <code node="[object Object]">AuthenticatedHTTPClient</code> as an illustration: it provides the same interface as the <code node="[object Object]">HTTPClient</code>, yet it injects a Bearer token with every request. Through this approach, decorations are linked together until the desired behavior is achieved.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O"><img alt="Image" loading="lazy" width="500" height="500" decoding="async" data-nimg="1" class="ImageRenderer_imageBlock___5diy" style="color:transparent" src="/images/article_18_02_2024_decorators.svg"/></p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Let&#x27;s take a moment to highlight four decorations of the <code node="[object Object]">HTTPClient</code> to deal with <em>authentication</em>, <em>error handling</em>, <em>header injection</em> as well as <em>logging</em></p>
<h3>Authentication</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">First, let&#x27;s start by taking a look at how we can add <em>authentication</em> to an existing <code node="[object Object]">HTTPClient</code>. Given the client, as well as a closure that returns an access token, the <code node="[object Object]">AuthenticatedHTTPClient</code> injects the token as an <code node="[object Object]">Authentication</code> header into every request. Note that the closure providing the token is asynchronous and may return an error when the token retrieval fails. In case, no token could be retrieved, the client throws the <code node="[object Object]">missingAccessToken</code> error.</p>
<pre><code class="language-swift" node="[object Object]">/// A `HTTPClient` decorator that extends requests to a client with an authentication token.
public class AuthenticatedHTTPClient: HTTPClient {
    enum Error: Swift.Error {
        /// Error if no AccessToken exists.
        case missingAccessToken
    }

    private let client: HTTPClient
    private let accessToken: () async throws -&gt; String

    /// Decorates requests to a `HTTPClient` with the authentication token.
    /// - Parameters:
    ///   - client: The `HTTPClient` to be decorated.
    ///   - accessToken: A closure providing the AccessToken.
    public init(client: HTTPClient, accessToken: @escaping () async throws -&gt; String) {
        self.client = client
        self.accessToken = accessToken
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -&gt; (Data, HTTPResponse) {
        var modifiedRequest = ModifiedRequest(request)
        var headers = modifiedRequest.headers ?? [:]

        do {
            headers[&quot;Authorization&quot;] = try await accessToken()
        } catch {
            throw Error.missingAccessToken
        }

        modifiedRequest.headers = headers
        return try await client.load(request: modifiedRequest)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The following extension allows to easily chain the <code node="[object Object]">AuthenticatedHttpClient</code> with an existing client:</p>
<pre><code class="language-swift" node="[object Object]">extension HTTPClient {
    /// Extends requests to a `HTTPClient` with the authentication token.
    /// - Returns: The `HTTPClient` extended with the authentication token.
    public func authenticated(accessToken: @escaping () async throws -&gt; String) -&gt; HTTPClient {
        AuthenticatedHTTPClient(client: self, accessToken: accessToken)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Then, an existing client is augmented by calling <code node="[object Object]">.authenticated</code> with a closure providing the access token.</p>
<pre><code class="language-swift" node="[object Object]">URLSessionClient(baseURL: baseURL, session: session)
    .authenticated(
        accessToken: {
            try await Task.sleep(nanoseconds: 1_000_000)
            return &quot;Bearer &lt;Token&gt;&quot;
        }
    )
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Note that the access token retrieval is asynchronous because the token may expire. If the token becomes invalid, the client can request a new token using the refresh token from the authentication server.</p>
<h3>Error Handling</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Like <code node="[object Object]">authentication</code>, we can introduce an additional decorator that handles errors for responses with status codes outside <code node="[object Object]">200..&lt;300</code> by default. However, this does not prevent us from handling the error on the call side. Rather, handlers can be chained to deal with the error suitably, thanks to their composable nature.</p>
<pre><code class="language-swift" node="[object Object]">/// Error type encompassing errors that may occur during the execution of network requests.
public enum HTTPError: Error, Equatable {
    /// Error for responses to network requests containing a StatusCode not within `200..&lt;300`.
    case httpCode(statusCode: HTTPStatusCode, data: Data)
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The <code node="[object Object]">ErrorHandlingHTTPClient</code> examines the response status code and throws an <code node="[object Object]">HTTPError.httpCode(statusCode:data:)</code> error if it falls outside the expected range. This simplifies error handling for the client. Within the feature, where we have a better understanding of the error, we can provide more specific details on how to handle it.</p>
<pre><code class="language-swift" node="[object Object]">/// A `HTTPClient` decorator implementing error handling for standard errors.
public class ErrorHandlingHTTPClient: HTTPClient {
    private let client: HTTPClient

    /// Decorates a HTTPClient with standard error handling.
    /// - Parameter client: The client to be decorated.
    public init(client: HTTPClient) {
        self.client = client
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -&gt; (Data, HTTPResponse) {
        let (data, response) = try await client.load(request: request)

        if !(200 ..&lt; 300).contains(response.statusCode) {
            throw HTTPError.httpCode(statusCode: response.statusCode, data: data)
        } else {
            return (data, response)
        }
    }
}

extension HTTPClient {
    /// Decorates a `HTTPClient` with standard error handling.
    /// - Returns: The `HTTPClient` extended with standard error handling.
    public func handlingErrors() -&gt; HTTPClient {
        ErrorHandlingHTTPClient(client: self)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Similar to the previous extensions, default error handling is added by calling <code node="[object Object]">handlingErrors()</code> on an existing client.</p>
<pre><code class="language-swift" node="[object Object]">URLSessionClient(baseURL: baseURL, session: session)
    .handlingErrors()
</code></pre>
<h3>Header Injection</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Now, we will discuss the <code node="[object Object]">HeadersInjectingHTTPClient</code>. This client enables the injection of custom headers into the request.</p>
<pre><code class="language-swift" node="[object Object]">/// A `HTTPClient` decorator that extends requests with additional HTTP headers.
public class HeadersInjectingHTTPClient: HTTPClient {
    private let client: HTTPClient
    private let headers: HTTPHeaders

    /// Decorates requests to a HTTPClient with additional headers.
    /// - Parameter client: The client to be decorated.
    /// - Parameter headers: The additional headers to be added to requests to the client.
    /// &gt; Warning: Identically named headers that already exist will be overwritten.
    public init(client: HTTPClient, headers: HTTPHeaders) {
        self.client = client
        self.headers = headers
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -&gt; (Data, HTTPResponse) {
        var modifiedRequest = ModifiedRequest(request)
        var headers = modifiedRequest.headers ?? [:]
        self.headers.forEach { header in
            headers[header.key] = header.value
        }
        modifiedRequest.headers = headers
        return try await client.load(request: modifiedRequest)
    }
}

extension HTTPClient {
    /// Decorates requests to a `HTTPClient` with additional headers.
    /// - Returns: The `HTTPClient` extended with the additional headers.
    public func injecting(headers: HTTPHeaders) -&gt; HTTPClient {
        HeadersInjectingHTTPClient(client: self, headers: headers)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Custom headers are frequently utilized to provide additional information about the client, such as its version or the operating system on which the application is running. Additionally, the client may need to specify the desired data format for the response. In both of these cases, the required information can be injected by calling the <code node="[object Object]">injecting(headers:)</code> extension on an existing client.</p>
<pre><code class="language-swift" node="[object Object]">URLSessionClient(baseURL: baseURL, session: session)
    .injecting(
        headers: [
            &quot;header1&quot;: &quot;value1&quot;,
            &quot;header2&quot;: &quot;value2&quot;,
            &quot;header3&quot;: &quot;value3&quot;
        ]
    )
</code></pre>
<h3>Logging Request and Responses</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Finally, we will discuss how to handle logging with the <code node="[object Object]">LoggingHTTPClient</code>. Similar to the previous decorators, this client follows the <code node="[object Object]">HTTPClient</code> protocol and describes the request and response after the call. Please note that we utilized <code node="[object Object]">print</code> statements for the sake of simplicity. In a production-level application, a dedicated logger with an appropriate queuing mechanism would be used to ensure that events are logged in the order in which they occur.</p>
<pre><code class="language-swift" node="[object Object]">/// A `HTTPClient` decorator that logs requests.
public class LoggingHTTPClient: HTTPClient {
    private let client: HTTPClient

    /// Logs requests to a HTTPClient
    /// - Parameter client: The client to be decorated.
    public init(client: HTTPClient) {
        self.client = client
    }

    /// Executes the given network request.
    /// - Parameter request: The request to be executed.
    /// - Returns: The response including the data to the network request.
    public func load(request: HTTPRequest) async throws -&gt; (Data, HTTPResponse) {
        print(describe(request: request))
        let (data, response) = try await client.load(request: request)
        print(describe(response: response, data: data))
        return (data, response)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Below, you can find utility functions that prepare the request and response in a human-readable format. This allows developers to quickly verify whether the request was successful or if the server responded with the expected status code. To enhance the implementation, consider storing the log on disk or exporting it for further investigation.</p>
<pre><code class="language-swift" node="[object Object]">extension LoggingHTTPClient {
    private func describe(request: HTTPRequest) -&gt; String {
        [
            &quot;Outgoing Network Request ⬆️:&quot;,
            &quot;-------------------------------&quot;,
            &quot;Method: \(request.method.name)&quot;,
            &quot;Path: \(request.path)&quot;,
            &quot;Version: \(request.version)&quot;,
            request.headers.map { &quot;Headers:\n\(describe(dict: $0))&quot; },
            request.queryParameter.map { &quot;Query-Parameter: \(String(describing: $0))&quot; },
            request.body.map { &quot;Body:\n\(describe(data: $0))&quot; },
        ]
        .compactMap { $0 }
        .joined(separator: &quot;\n&quot;)
    }

    private func describe(response: HTTPResponse, data: Data) -&gt; String {
        [
            &quot;Incoming Network Response ⬇️:&quot;,
            &quot;------------------------------------------&quot;,
            &quot;\(describe(response: response))&quot;,
            &quot;Body:&quot;,
            &quot;\(describe(data: data))&quot;,
        ]
        .joined(separator: &quot;\n&quot;)
    }

    private func describe(response: HTTPResponse) -&gt; String {
        [
            &quot;StatusCode: \(response.statusCode)&quot;,
            response.headers.map { &quot;Headers:\n\(describe(dict: $0))&quot; },
        ]
        .compactMap { $0 }
        .joined(separator: &quot;\n&quot;)
    }

    private func describe(data: Data) -&gt; String {
        guard
            let object = try? JSONSerialization.jsonObject(with: data, options: []),
            let data = try? JSONSerialization.data(withJSONObject: object, options: [.prettyPrinted]),
            let value = NSString(data: data, encoding: String.Encoding.utf8.rawValue) 
        else {
            return String(data: data, encoding: .utf8) ?? &quot;&quot;
        }
        
        return String(value)
    }

    private func describe(dict: [String: String]) -&gt; String {
        &quot;\(dict.reduce(&quot;&quot;) { $0 + &quot;    - \($1.key): \($1.value)\n&quot; })&quot;
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Using the following extension, we can activate logging for all network requests:</p>
<pre><code class="language-swift" node="[object Object]">extension HTTPClient {
    /// Logs requests to a `HTTPClient`
    /// - Returns: The `HTTPClient` extended with request logging.
    public func loggingRequestAndResponse() -&gt; HTTPClient {
        LoggingHTTPClient(client: self)
    }
}

URLSessionClient(baseURL: baseURL, session: session)
    .loggingRequestAndResponse()
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Here is an example of a human-readable printout of a request/response pair. The log clearly breaks down the outgoing request, including its <code node="[object Object]">method</code>, <code node="[object Object]">path</code>, <code node="[object Object]">version</code>, and <code node="[object Object]">headers</code>. The incoming response is also detailed, including its status code, headers, and body content.</p>
<pre><code node="[object Object]">Outgoing Network Request ⬆️:
-------------------------------
Method: GET
Path: token
Version: v1
Headers:
    - Authorization: Bearer &lt;Token&gt;
    - header1: value1
    - header2: value2
    - header3: value3

Incoming Network Response ⬇️:
------------------------------------------
StatusCode: 200
Headers:
    - Content-Type: application/json; charset=utf-8
    - Connection: keep-alive
    - Date: Sun, 11 Feb 2024 09:48:46 GMT
    - Keep-Alive: timeout=5
    - Content-Length: 5

Body:
token
</code></pre>
<h3>Usage Example: Token API</h3>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The <code node="[object Object]">HTTPClient</code> protocol is a suitable abstraction for making features agnostic of infrastructure details. Decorators allow for the dynamic addition of functionality without having to adapt the underlying implementation. Let&#x27;s examine a usage example to see how these components interact.</p>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Consider a simple REST API (<code node="[object Object]">TokenAPI</code>) that enables users to retrieve and update a token. While the <code node="[object Object]">token</code> endpoint does not require a request body, the <code node="[object Object]">update</code> endpoint expects the new token to be stored on the server.</p>
<pre><code class="language-swift" node="[object Object]">enum TokenAPI: HTTPRequest {
    case token
    case update(token: String)
    
    var method: HTTPMethod {
        switch self {
        case .token:
            return .get
        case .update:
            return .post
        }
    }
    
    var path: HTTPPath {
        return &quot;token&quot;
    }
    
    var version: HTTPVersion {
        return &quot;v1&quot;
    }
    
    var body: Data? {
        switch self {
        case let .update(token):
            return token.data(using: .utf8)
        default:
            return nil
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Additionally, we define the <code node="[object Object]">TokenMapper</code> to translate the received data and <code node="[object Object]">HTTPResponse</code> into a token. Please note that the mapping may fail if invalid data is received.</p>
<pre><code class="language-swift" node="[object Object]">enum TokenMapper {
    enum Error: Swift.Error {
        case invalidData
    }

    static func map(data: Data, response: HTTPResponse) throws -&gt; String {
        guard
            response.isSuccess,
            let token = String(data: data, encoding: .utf8)
        else {
            throw Error.invalidData
        }
        
        return token
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Next, we instantiate a concrete <code node="[object Object]">HTTPClient</code> to perform the request. In this case, we decided to use Apple&#x27;s <code node="[object Object]">URLSession</code> by using the <code node="[object Object]">URLSessionClient</code> with an <code node="[object Object]">ephemeral</code> session and a request timeout interval of 30 seconds.</p>
<pre><code class="language-swift" node="[object Object]">enum HTTPClientFactory {
    static func make(_ baseUrl: String) -&gt; HTTPClient {
        let baseURL: URL = URL(string: baseUrl)!
        let configuration = URLSessionConfiguration.ephemeral
        configuration.timeoutIntervalForRequest = 30.0
        let session: URLSession = URLSession(configuration: configuration)
        return URLSessionClient(baseURL: baseURL, session: session)
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">By utilizing the extensions, we can include <code node="[object Object]">logging</code> and <code node="[object Object]">authentication</code>, as well as the necessary <code node="[object Object]">headers</code> to execute the request. It is important to note that the order in which the extensions are applied is significant, as it determines the sequence in which the decorations are applied.</p>
<pre><code class="language-swift" node="[object Object]">enum HTTPClientFactory {
    static func make(_ baseUrl: String) -&gt; HTTPClient {
        let baseURL: URL = URL(string: baseUrl)!
        let configuration = URLSessionConfiguration.ephemeral
        configuration.timeoutIntervalForRequest = 30.0
        let session: URLSession = URLSession(configuration: configuration)
        return URLSessionClient(baseURL: baseURL, session: session)
            .loggingRequestAndResponse()
            .injecting(
                headers: [
                    &quot;header1&quot;: &quot;value1&quot;,
                    &quot;header2&quot;: &quot;value2&quot;,
                    &quot;header3&quot;: &quot;value3&quot;
                ]
            )
            .authenticated(
                accessToken: {
                    try await Task.sleep(nanoseconds: 1_000_000)
                    return &quot;Bearer &lt;Token&gt;&quot;
                }
            )
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The <code node="[object Object]">ContentView</code> requires a token to be retrieved through the <code node="[object Object]">loadToken</code> closure provided in its initializer. This approach ensures that the UI is not dependent on the specific <code node="[object Object]">HTTPClient</code> used to execute the request. By using SwiftUI&#x27;s <code node="[object Object]">task</code> modifier, the request is automatically made when the content is loaded on screen.</p>
<pre><code class="language-swift" node="[object Object]">struct ContentView: View {
    @State private var token: String?
    
    private let loadToken: () async throws -&gt; String
    
    init(loadToken: @escaping () async throws -&gt; String) {
        self.loadToken = loadToken
    }

    var body: some View {
        NavigationStack {
            Text(token ?? &quot;&quot;)
                .navigationTitle(&quot;Networking&quot;)
                .task { token = try? await loadToken() }
        }
    }
}
</code></pre>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">The UI and <code node="[object Object]">httpClient</code> are connected in the <code node="[object Object]">composition root</code>. This layer translates the view&#x27;s request and passes it to the <code node="[object Object]">httpClient</code>. The response is then mapped using the <code node="[object Object]">TokenMapper</code> to match the signature of the <code node="[object Object]">loadToken</code> method.</p>
<pre><code class="language-swift" node="[object Object]">@main
struct NetworkingApp: App {
    private let httpClient: HTTPClient = HTTPClientFactory.make(&quot;http://localhost:3000/&quot;)

    var body: some Scene {
        WindowGroup {
            ContentView(loadToken: httpClient.loadToken)
        }
    }
}

private extension HTTPClient {
    func loadToken() async throws -&gt; String {
        let (data, response) = try await self.load(request: TokenAPI.token)
        return try TokenMapper.map(data: data, response: response)
    }
}
</code></pre>
<h1>Conclusion</h1>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">In this article, we introduced a lightweight approach to dealing with cross-cutting concerns like networking in modular iOS applications. By following the principles outlined here, developers can keep features agnostic of infrastructure details and benefit from a faster development cycle and the scalability of their modular iOS applications.</p>
<h1>References:</h1>
<ul>
<li><a href="https://developer.apple.com/documentation/foundation/url_loading_system">The URL loading system</a> - Apple</li>
<li><a href="https://blog.ploeh.dk/2011/07/28/CompositionRoot/">Composition Root</a> - Mark Seemann</li>
</ul>
<p node="[object Object]" class="ParagraphRenderer_paragraphBlock__YVI1O">Happy Coding 🚀</p></div></div><footer class="Footer_footer__JrJN9"><p>Made by<!-- --> <a class="inline" href="/about">Andreas Link</a> <!-- -->in Karlsruhe</p><div><div><a href="https://www.iubenda.com/privacy-policy/86928215" class="iubenda-black no-brand iubenda-noiframe iubenda-embed iubenda-noiframe ">Privacy Policy</a></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"2024-03-16","date":"Sat, 16 Mar 2024 00:00:00 +0000","markdown":"# Networking for Large-Scale iOS Applications\n\nNetworking serves as the backbone of mobile applications, facilitating seamless communication and enabling rich user experiences. However, it also introduces complexity, especially when dealing with modular applications that are built from independent features. \n\nModularity offers many benefits, such as a faster development cycle and better scalability. But it also requires a robust approach to handle cross-cutting concerns among features. Since networking is a cross-cutting concern, it cannot be easily encapsulated in any of them. \n\nIn this article, we explore a lightweight approach for dealing with networking in modular iOS applications.\n\n## Naive Approach\n\nFirst, let's take a look at the naive approach, where multiple independent features directly depend on the networking package.\n\n![Naive Approach](article_18_02_2024_naive_approach.svg)\n\nEven though the latter encapsulates the ability to communicate over the network, it adds up to the total build time of each feature, since compiling the feature requires compilation of the entire network package as well. Especially when working in feature teams, it is desirable to minimize the amount of direct dependencies so that we can benefit from shorter build times and a fast feedback loop.\n\n## Lightweight Approach in modular Applications\n\nTo ensure that we do not need to compile the network-related code when working on a feature, we introduce a lightweight abstraction called `HTTPClient` that is exposed to every feature but does not contain a concrete implementation.\n\n```swift\n/// Abstraction for executing HTTP network requests.\npublic protocol HTTPClient {\n    /// Executes the given request and returns the received data and response including the StatusCode.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The received data and response (including the StatusCode).\n    @discardableResult\n    func load(request: HTTPRequest) async throws -\u003e (Data, HTTPResponse)\n}\n```\n\nThe abstraction only consists of the `load(request:)` method, that given an `HTTPRequest` returns the received data along with the `HTTPResponse`. The `HTTPRequest` contains all information necessary to perform the request, like the `method`, `path`, `headers` and `queryParameters`. In addition, the `body` parameter is used to specify the content that is transmitted with the request.\n\n```swift\n/// Abstraction describing an HTTP network request.\npublic protocol HTTPRequest {\n    /// The HTTP method of the request.\n    var method: HTTPMethod { get }\n    /// The path of the request endpoint.\n    var path: HTTPPath { get }\n    /// The endpoint version of the request.\n    var version: HTTPVersion { get }\n    /// The headers to be transmitted with the request.\n    var headers: HTTPHeaders? { get }\n    /// The query parameters to be transmitted with the request.\n    var queryParameter: HTTPQueryParameter? { get }\n    /// The content to be transmitted with the request.\n    var body: Data? { get }\n}\n```\n\nSome parameters are declared *optional* since they may not be necessary for every request. Hence, developers have the flexibility to omit these parameters, streamlining the implementation and improving code readability.\n\n```swift\nextension HTTPRequest {\n    public var headers: HTTPHeaders? { nil }\n    public var queryParameter: HTTPQueryParameter? { nil }\n    public var body: Data? { nil }\n}\n```\n\nLet's briefly go through the meaning of each of the parameters.\n\nFirst, the `HTTPMethod` enumeration corresponds to the methods permitted for HTTP requests. Alongside `GET` for data retrieval, it also includes `POST` for creating a resource, as well as `PUT` and `PATCH` for updating the resource, and `DELETE` for removing it when no longer needed.\n\n```swift\n/// The HTTP method of the network request.\npublic enum HTTPMethod: String, Equatable {\n    case get = \"GET\"\n    case post = \"POST\"\n    case put = \"PUT\"\n    case patch = \"PATCH\"\n    case delete = \"DELETE\"\n}\n\nextension HTTPMethod {\n    public var name: String {\n        rawValue\n    }\n}\n```\n\nNext, the `HTTPPath` in conjunction with the `HTTPVersion` specifies the endpoint targeted by the request. Both are defined as type aliases of `String` to better derive a semantic meaning when looking at the type itself.\n\n```swift\n/// The path of the network request.\npublic typealias HTTPPath = String\n/// The version of the HTTP endpoint.\npublic typealias HTTPVersion = String\n```\n\nNext, `HTTPHeader` defines standard headers that are included in most requests. For instance, the `contentType` attribute specifies the type of content being transmitted in the request body.\n\n```swift\n/// Standard headers that can be transmitted in requests to the backend.\npublic enum HTTPHeader: String {\n    /// The data format accepted by the client (e.g., `application/json`).\n    case accept = \"Accept\"\n    /// The type of content being sent in the body (e.g., `application/json`).\n    case contentType = \"Content-Type\"\n}\n```\n\nFinally, similar to `HTTPPath`, both `HTTPHeaders` and `HTTPQueryParameter` utilize type aliases to give meaning to the underlying `String` key-value pairs.\n\n```swift\n/// Dictionary of headers sent or received as key-value pairs in network requests.\npublic typealias HTTPHeaders = [String: String]\n/// Key-value pairs transmitted as query parameters in network requests.\npublic typealias HTTPQueryParameter = [String: String]\n```\n\nHaving referred to the properties of an `HTTPRequest`, let's now shift our focus to the `HTTPResponse` that is received upon successful execution of `load(request:)`.\n\n```swift\n/// Contains the response to a network request.\npublic struct HTTPResponse {\n    /// The StatusCode of the response.\n    public let statusCode: HTTPStatusCode\n    /// The headers of the response.\n    public let headers: HTTPHeaders?\n\n    /// Initializes a `HTTPResponse` for a given StatusCode and Header.\n    /// - Parameters:\n    ///   - statusCode: The StatusCode of the response.\n    ///   - headers: The headers of the response.\n    public init(statusCode: HTTPStatusCode, headers: HTTPHeaders? = nil) {\n        self.statusCode = statusCode\n        self.headers = headers\n    }\n}\n\n/// The StatusCode contained in a response to a network request.\npublic typealias HTTPStatusCode = Int\n```\n\nIn contrast to the request, the `HTTPResponse` only comprises two properties: the `statusCode` and `headers`. While the status code communicates the outcome of the request, the `headers` are optional and enable the server to provide supplementary information to the client alongside the response.\n\nFurthermore, extensions are implemented to streamline the determination of the response's nature, categorizing it into types such as `informational`, `successful`, `redirection`, `client error`, or `server error`. This eliminates the need to memorize status code ranges.\n\n```swift\nextension HTTPResponse {\n    /// Status indicating whether it is an informational response.\n    /// - seealso: For more information, see [mdm web docs - Information responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#information_responses)\n    public var isInformational: Bool {\n        (100 ..\u003c 200).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a successful response.\n    /// - seealso: For more information, see [mdm web docs - Successful responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#successful_responses)\n    public var isSuccess: Bool {\n        (200 ..\u003c 300).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a redirection response.\n    /// - seealso: For more information, see [mdm web docs - Redirection messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages)\n    public var isRedirectional: Bool {\n        (300 ..\u003c 400).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a client error response.\n    /// - seealso: For more information, see [mdm web docs - Client error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)\n    public var isClientError: Bool {\n        (400 ..\u003c 500).contains(statusCode)\n    }\n\n    /// Status indicating whether it is a server error response.\n    /// - seealso: For more information, see [mdm web docs - Server error responses](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)\n    public var isServerError: Bool {\n        (500 ..\u003c 600).contains(statusCode)\n    }\n\n    /// Status indicating whether it is an error response.\n    public var isError: Bool {\n        (400 ..\u003c 600).contains(statusCode)\n    }\n}\n```\n\nAs a result, relying solely on the `HTTPClient` abstraction has a negligible impact on the feature's build time. Moreover, the feature avoids dealing with 3rd party dependencies like `Moya`, `Alamofire` or Apple's `URLSession`. Instead, it only uses the abstraction to communicate over the network and assumes that a concrete implementation will be provided by another entity. This assumption is key for decoupling features from cross-cutting concerns and developing them in isolation.\n\n![Architecture](article_18_02_2024_feature_abstraction.svg)\n\n## Infrastructure: \"URLSessionInfrastructure\"\n\nStill, when integrating the feature, we need to ensure that its requirements are fulfilled by a concrete implementation. The latter is provided by infrastructure modules that may use a third-party library to achieve the intended result. For instance, the `URLSessionInfrastructure` package may use Apple's `URLSession` to execute the request.\n\n![Architecture](article_18_02_2024_feature_abstraction_infrastructure.svg)\n\nIn this manner, only the infrastructure package directly relies on third-party frameworks, such that each feature stays agnostic from infrastructure details. Below you can find an example implementation of the `URLSessionClient`:\n\n```swift\nimport Foundation\n\npublic final class URLSessionClient: HTTPClient {\n    enum Error: Swift.Error {\n        case noHttpURLResponse\n        case invalidHeaderArguments\n    }\n\n    private let baseURL: URL\n    private let session: URLSession\n\n    public init(baseURL: URL, session: URLSession = .shared) {\n        self.baseURL = baseURL\n        self.session = session\n    }\n\n    public func load(request: HTTPRequest) async throws -\u003e (Data, HTTPResponse) {\n        let url = baseURL\n            .appending(path: request.version)\n            .appending(path: request.path)\n\n        var urlRequest = URLRequest(url: url)\n        urlRequest.httpMethod = request.method.name\n        urlRequest.httpBody = request.body\n        urlRequest.allHTTPHeaderFields = request.headers\n        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)\n        components?.queryItems = request.queryParameter?.reduce(into: [URLQueryItem]()) { current, next in\n            let item = URLQueryItem(name: next.key, value: next.value)\n            current.append(item)\n        }\n\n        let (data, response) = try await session.data(for: urlRequest)\n\n        guard let httpURLResponse = response as? HTTPURLResponse else {\n            throw Error.noHttpURLResponse\n        }\n\n        guard let headers = httpURLResponse.allHeaderFields as? [String: String] else {\n            throw Error.invalidHeaderArguments\n        }\n\n        let HttpResponse = HTTPResponse(statusCode: httpURLResponse.statusCode, headers: headers)\n        return (data, HttpResponse)\n    }\n}\n```\n\nFirst, the `load(request:)` method constructs a `URLRequest` along with its query items based on the information given in the `HTTPRequest`. It's important to note that `URLRequest` is considered an infrastructure detail, as it's provided by Apple's `URLSession`. Second, the `session` is used to execute the request and wait for the reception of a response. Finally, the received response is interpreted as an `HTTPURLResponse` from which `headers` and `statusCode` are extracted.\n\nBy separating the feature from infrastructure details, we can integrate all components within the *composition root*. The latter serves as the translation layer between modules without requiring them to have knowledge of each other. This way, features can be developed in isolation by different feature teams, which is essential for large-scale modular applications.\n\n![Architecture](article_18_02_2024_architecture.svg)\n\n## Adding Functionality: Decorators\n\nEspecially within large-scale applications, we frequently encounter new or evolving business requirements, such as *logging* or *authentication*. Instead of modifying the infrastructure module, we can utilize the decorator pattern to add functionality without altering the underlying implementation. Consider the `AuthenticatedHTTPClient` as an illustration: it provides the same interface as the `HTTPClient`, yet it injects a Bearer token with every request. Through this approach, decorations are linked together until the desired behavior is achieved.\n\n![Decorators](article_18_02_2024_decorators.svg)\n\nLet's take a moment to highlight four decorations of the `HTTPClient` to deal with *authentication*, *error handling*, *header injection* as well as *logging*\n\n### Authentication\n\nFirst, let's start by taking a look at how we can add *authentication* to an existing `HTTPClient`. Given the client, as well as a closure that returns an access token, the `AuthenticatedHTTPClient` injects the token as an `Authentication` header into every request. Note that the closure providing the token is asynchronous and may return an error when the token retrieval fails. In case, no token could be retrieved, the client throws the `missingAccessToken` error.\n\n```swift\n/// A `HTTPClient` decorator that extends requests to a client with an authentication token.\npublic class AuthenticatedHTTPClient: HTTPClient {\n    enum Error: Swift.Error {\n        /// Error if no AccessToken exists.\n        case missingAccessToken\n    }\n\n    private let client: HTTPClient\n    private let accessToken: () async throws -\u003e String\n\n    /// Decorates requests to a `HTTPClient` with the authentication token.\n    /// - Parameters:\n    ///   - client: The `HTTPClient` to be decorated.\n    ///   - accessToken: A closure providing the AccessToken.\n    public init(client: HTTPClient, accessToken: @escaping () async throws -\u003e String) {\n        self.client = client\n        self.accessToken = accessToken\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -\u003e (Data, HTTPResponse) {\n        var modifiedRequest = ModifiedRequest(request)\n        var headers = modifiedRequest.headers ?? [:]\n\n        do {\n            headers[\"Authorization\"] = try await accessToken()\n        } catch {\n            throw Error.missingAccessToken\n        }\n\n        modifiedRequest.headers = headers\n        return try await client.load(request: modifiedRequest)\n    }\n}\n```\n\nThe following extension allows to easily chain the `AuthenticatedHttpClient` with an existing client:\n\n```swift\nextension HTTPClient {\n    /// Extends requests to a `HTTPClient` with the authentication token.\n    /// - Returns: The `HTTPClient` extended with the authentication token.\n    public func authenticated(accessToken: @escaping () async throws -\u003e String) -\u003e HTTPClient {\n        AuthenticatedHTTPClient(client: self, accessToken: accessToken)\n    }\n}\n```\n\nThen, an existing client is augmented by calling `.authenticated` with a closure providing the access token.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .authenticated(\n        accessToken: {\n            try await Task.sleep(nanoseconds: 1_000_000)\n            return \"Bearer \u003cToken\u003e\"\n        }\n    )\n```\n\nNote that the access token retrieval is asynchronous because the token may expire. If the token becomes invalid, the client can request a new token using the refresh token from the authentication server.\n\n### Error Handling\n\nLike `authentication`, we can introduce an additional decorator that handles errors for responses with status codes outside `200..\u003c300` by default. However, this does not prevent us from handling the error on the call side. Rather, handlers can be chained to deal with the error suitably, thanks to their composable nature.\n\n```swift\n/// Error type encompassing errors that may occur during the execution of network requests.\npublic enum HTTPError: Error, Equatable {\n    /// Error for responses to network requests containing a StatusCode not within `200..\u003c300`.\n    case httpCode(statusCode: HTTPStatusCode, data: Data)\n}\n```\n\nThe `ErrorHandlingHTTPClient` examines the response status code and throws an `HTTPError.httpCode(statusCode:data:)` error if it falls outside the expected range. This simplifies error handling for the client. Within the feature, where we have a better understanding of the error, we can provide more specific details on how to handle it.\n\n```swift\n/// A `HTTPClient` decorator implementing error handling for standard errors.\npublic class ErrorHandlingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n\n    /// Decorates a HTTPClient with standard error handling.\n    /// - Parameter client: The client to be decorated.\n    public init(client: HTTPClient) {\n        self.client = client\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -\u003e (Data, HTTPResponse) {\n        let (data, response) = try await client.load(request: request)\n\n        if !(200 ..\u003c 300).contains(response.statusCode) {\n            throw HTTPError.httpCode(statusCode: response.statusCode, data: data)\n        } else {\n            return (data, response)\n        }\n    }\n}\n\nextension HTTPClient {\n    /// Decorates a `HTTPClient` with standard error handling.\n    /// - Returns: The `HTTPClient` extended with standard error handling.\n    public func handlingErrors() -\u003e HTTPClient {\n        ErrorHandlingHTTPClient(client: self)\n    }\n}\n```\n\nSimilar to the previous extensions, default error handling is added by calling `handlingErrors()` on an existing client.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .handlingErrors()\n```\n\n### Header Injection\n\nNow, we will discuss the `HeadersInjectingHTTPClient`. This client enables the injection of custom headers into the request.\n\n```swift\n/// A `HTTPClient` decorator that extends requests with additional HTTP headers.\npublic class HeadersInjectingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n    private let headers: HTTPHeaders\n\n    /// Decorates requests to a HTTPClient with additional headers.\n    /// - Parameter client: The client to be decorated.\n    /// - Parameter headers: The additional headers to be added to requests to the client.\n    /// \u003e Warning: Identically named headers that already exist will be overwritten.\n    public init(client: HTTPClient, headers: HTTPHeaders) {\n        self.client = client\n        self.headers = headers\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -\u003e (Data, HTTPResponse) {\n        var modifiedRequest = ModifiedRequest(request)\n        var headers = modifiedRequest.headers ?? [:]\n        self.headers.forEach { header in\n            headers[header.key] = header.value\n        }\n        modifiedRequest.headers = headers\n        return try await client.load(request: modifiedRequest)\n    }\n}\n\nextension HTTPClient {\n    /// Decorates requests to a `HTTPClient` with additional headers.\n    /// - Returns: The `HTTPClient` extended with the additional headers.\n    public func injecting(headers: HTTPHeaders) -\u003e HTTPClient {\n        HeadersInjectingHTTPClient(client: self, headers: headers)\n    }\n}\n```\n\nCustom headers are frequently utilized to provide additional information about the client, such as its version or the operating system on which the application is running. Additionally, the client may need to specify the desired data format for the response. In both of these cases, the required information can be injected by calling the `injecting(headers:)` extension on an existing client.\n\n```swift\nURLSessionClient(baseURL: baseURL, session: session)\n    .injecting(\n        headers: [\n            \"header1\": \"value1\",\n            \"header2\": \"value2\",\n            \"header3\": \"value3\"\n        ]\n    )\n```\n\n### Logging Request and Responses\n\nFinally, we will discuss how to handle logging with the `LoggingHTTPClient`. Similar to the previous decorators, this client follows the `HTTPClient` protocol and describes the request and response after the call. Please note that we utilized `print` statements for the sake of simplicity. In a production-level application, a dedicated logger with an appropriate queuing mechanism would be used to ensure that events are logged in the order in which they occur.\n\n```swift\n/// A `HTTPClient` decorator that logs requests.\npublic class LoggingHTTPClient: HTTPClient {\n    private let client: HTTPClient\n\n    /// Logs requests to a HTTPClient\n    /// - Parameter client: The client to be decorated.\n    public init(client: HTTPClient) {\n        self.client = client\n    }\n\n    /// Executes the given network request.\n    /// - Parameter request: The request to be executed.\n    /// - Returns: The response including the data to the network request.\n    public func load(request: HTTPRequest) async throws -\u003e (Data, HTTPResponse) {\n        print(describe(request: request))\n        let (data, response) = try await client.load(request: request)\n        print(describe(response: response, data: data))\n        return (data, response)\n    }\n}\n```\n\nBelow, you can find utility functions that prepare the request and response in a human-readable format. This allows developers to quickly verify whether the request was successful or if the server responded with the expected status code. To enhance the implementation, consider storing the log on disk or exporting it for further investigation.\n\n```swift\nextension LoggingHTTPClient {\n    private func describe(request: HTTPRequest) -\u003e String {\n        [\n            \"Outgoing Network Request ⬆️:\",\n            \"-------------------------------\",\n            \"Method: \\(request.method.name)\",\n            \"Path: \\(request.path)\",\n            \"Version: \\(request.version)\",\n            request.headers.map { \"Headers:\\n\\(describe(dict: $0))\" },\n            request.queryParameter.map { \"Query-Parameter: \\(String(describing: $0))\" },\n            request.body.map { \"Body:\\n\\(describe(data: $0))\" },\n        ]\n        .compactMap { $0 }\n        .joined(separator: \"\\n\")\n    }\n\n    private func describe(response: HTTPResponse, data: Data) -\u003e String {\n        [\n            \"Incoming Network Response ⬇️:\",\n            \"------------------------------------------\",\n            \"\\(describe(response: response))\",\n            \"Body:\",\n            \"\\(describe(data: data))\",\n        ]\n        .joined(separator: \"\\n\")\n    }\n\n    private func describe(response: HTTPResponse) -\u003e String {\n        [\n            \"StatusCode: \\(response.statusCode)\",\n            response.headers.map { \"Headers:\\n\\(describe(dict: $0))\" },\n        ]\n        .compactMap { $0 }\n        .joined(separator: \"\\n\")\n    }\n\n    private func describe(data: Data) -\u003e String {\n        guard\n            let object = try? JSONSerialization.jsonObject(with: data, options: []),\n            let data = try? JSONSerialization.data(withJSONObject: object, options: [.prettyPrinted]),\n            let value = NSString(data: data, encoding: String.Encoding.utf8.rawValue) \n        else {\n            return String(data: data, encoding: .utf8) ?? \"\"\n        }\n        \n        return String(value)\n    }\n\n    private func describe(dict: [String: String]) -\u003e String {\n        \"\\(dict.reduce(\"\") { $0 + \"    - \\($1.key): \\($1.value)\\n\" })\"\n    }\n}\n```\n\nUsing the following extension, we can activate logging for all network requests:\n\n```swift\nextension HTTPClient {\n    /// Logs requests to a `HTTPClient`\n    /// - Returns: The `HTTPClient` extended with request logging.\n    public func loggingRequestAndResponse() -\u003e HTTPClient {\n        LoggingHTTPClient(client: self)\n    }\n}\n\nURLSessionClient(baseURL: baseURL, session: session)\n    .loggingRequestAndResponse()\n```\n\nHere is an example of a human-readable printout of a request/response pair. The log clearly breaks down the outgoing request, including its `method`, `path`, `version`, and `headers`. The incoming response is also detailed, including its status code, headers, and body content.\n\n```\nOutgoing Network Request ⬆️:\n-------------------------------\nMethod: GET\nPath: token\nVersion: v1\nHeaders:\n    - Authorization: Bearer \u003cToken\u003e\n    - header1: value1\n    - header2: value2\n    - header3: value3\n\nIncoming Network Response ⬇️:\n------------------------------------------\nStatusCode: 200\nHeaders:\n    - Content-Type: application/json; charset=utf-8\n    - Connection: keep-alive\n    - Date: Sun, 11 Feb 2024 09:48:46 GMT\n    - Keep-Alive: timeout=5\n    - Content-Length: 5\n\nBody:\ntoken\n```\n\n### Usage Example: Token API\n\nThe `HTTPClient` protocol is a suitable abstraction for making features agnostic of infrastructure details. Decorators allow for the dynamic addition of functionality without having to adapt the underlying implementation. Let's examine a usage example to see how these components interact.\n\nConsider a simple REST API (`TokenAPI`) that enables users to retrieve and update a token. While the `token` endpoint does not require a request body, the `update` endpoint expects the new token to be stored on the server.\n\n```swift\nenum TokenAPI: HTTPRequest {\n    case token\n    case update(token: String)\n    \n    var method: HTTPMethod {\n        switch self {\n        case .token:\n            return .get\n        case .update:\n            return .post\n        }\n    }\n    \n    var path: HTTPPath {\n        return \"token\"\n    }\n    \n    var version: HTTPVersion {\n        return \"v1\"\n    }\n    \n    var body: Data? {\n        switch self {\n        case let .update(token):\n            return token.data(using: .utf8)\n        default:\n            return nil\n        }\n    }\n}\n```\n\nAdditionally, we define the `TokenMapper` to translate the received data and `HTTPResponse` into a token. Please note that the mapping may fail if invalid data is received.\n\n```swift\nenum TokenMapper {\n    enum Error: Swift.Error {\n        case invalidData\n    }\n\n    static func map(data: Data, response: HTTPResponse) throws -\u003e String {\n        guard\n            response.isSuccess,\n            let token = String(data: data, encoding: .utf8)\n        else {\n            throw Error.invalidData\n        }\n        \n        return token\n    }\n}\n```\n\nNext, we instantiate a concrete `HTTPClient` to perform the request. In this case, we decided to use Apple's `URLSession` by using the `URLSessionClient` with an `ephemeral` session and a request timeout interval of 30 seconds.\n\n```swift\nenum HTTPClientFactory {\n    static func make(_ baseUrl: String) -\u003e HTTPClient {\n        let baseURL: URL = URL(string: baseUrl)!\n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.timeoutIntervalForRequest = 30.0\n        let session: URLSession = URLSession(configuration: configuration)\n        return URLSessionClient(baseURL: baseURL, session: session)\n    }\n}\n```\n\nBy utilizing the extensions, we can include `logging` and `authentication`, as well as the necessary `headers` to execute the request. It is important to note that the order in which the extensions are applied is significant, as it determines the sequence in which the decorations are applied.\n\n```swift\nenum HTTPClientFactory {\n    static func make(_ baseUrl: String) -\u003e HTTPClient {\n        let baseURL: URL = URL(string: baseUrl)!\n        let configuration = URLSessionConfiguration.ephemeral\n        configuration.timeoutIntervalForRequest = 30.0\n        let session: URLSession = URLSession(configuration: configuration)\n        return URLSessionClient(baseURL: baseURL, session: session)\n            .loggingRequestAndResponse()\n            .injecting(\n                headers: [\n                    \"header1\": \"value1\",\n                    \"header2\": \"value2\",\n                    \"header3\": \"value3\"\n                ]\n            )\n            .authenticated(\n                accessToken: {\n                    try await Task.sleep(nanoseconds: 1_000_000)\n                    return \"Bearer \u003cToken\u003e\"\n                }\n            )\n    }\n}\n```\n\nThe `ContentView` requires a token to be retrieved through the `loadToken` closure provided in its initializer. This approach ensures that the UI is not dependent on the specific `HTTPClient` used to execute the request. By using SwiftUI's `task` modifier, the request is automatically made when the content is loaded on screen.\n\n```swift\nstruct ContentView: View {\n    @State private var token: String?\n    \n    private let loadToken: () async throws -\u003e String\n    \n    init(loadToken: @escaping () async throws -\u003e String) {\n        self.loadToken = loadToken\n    }\n\n    var body: some View {\n        NavigationStack {\n            Text(token ?? \"\")\n                .navigationTitle(\"Networking\")\n                .task { token = try? await loadToken() }\n        }\n    }\n}\n```\n\nThe UI and `httpClient` are connected in the `composition root`. This layer translates the view's request and passes it to the `httpClient`. The response is then mapped using the `TokenMapper` to match the signature of the `loadToken` method.\n\n```swift\n@main\nstruct NetworkingApp: App {\n    private let httpClient: HTTPClient = HTTPClientFactory.make(\"http://localhost:3000/\")\n\n    var body: some Scene {\n        WindowGroup {\n            ContentView(loadToken: httpClient.loadToken)\n        }\n    }\n}\n\nprivate extension HTTPClient {\n    func loadToken() async throws -\u003e String {\n        let (data, response) = try await self.load(request: TokenAPI.token)\n        return try TokenMapper.map(data: data, response: response)\n    }\n}\n```\n\n# Conclusion\n\nIn this article, we introduced a lightweight approach to dealing with cross-cutting concerns like networking in modular iOS applications. By following the principles outlined here, developers can keep features agnostic of infrastructure details and benefit from a faster development cycle and the scalability of their modular iOS applications.\n\n# References:\n\n- [The URL loading system](https://developer.apple.com/documentation/foundation/url_loading_system) - Apple\n- [Composition Root](https://blog.ploeh.dk/2011/07/28/CompositionRoot/) - Mark Seemann\n\nHappy Coding 🚀","title":"Networking for Large-Scale iOS Applications","description":"Networking serves as the backbone of mobile applications, \n            facilitating seamless communication and enabling rich user experiences. \n            However, it also introduces complexity, especially when dealing with \n            modular applications that are built from independent features.\n            Modularity offers many benefits, such as a faster development cycle \n            and better scalability. But it also requires a robust approach to handle \n            cross-cutting concerns among features. Since networking is a \n            cross-cutting concern, it cannot be easily encapsulated in any of them.\n            In this article, we explore a lightweight approach for dealing with \n            networking in modular iOS applications."}},"__N_SSG":true},"page":"/articles/[id]","query":{"id":"2024-03-16"},"buildId":"4waqnF4so0EMGSgX2Zk5E","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>